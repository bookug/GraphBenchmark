/** \file
 *  This C source file was generated by $ANTLR version 3.4
 *
 *     -  From the grammar source file : Sparql.g
 *     -                            On : 2012-10-05 15:14:39
 *     -                 for the lexer : SparqlLexerLexer
 *
 * Editing it, at least manually, is not wise.
 *
 * C language generator and runtime by Jim Idle, jimi|hereisanat|idle|dotgoeshere|ws.
 *
 *
*/
// [The "BSD license"]
// Copyright (c) 2005-2009 Jim Idle, Temporal Wave LLC
// http://www.temporal-wave.com
// http://www.linkedin.com/in/jimidle
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#include    "SparqlLexer.h"
/* ----------------------------------------- */


/** String literals used by SparqlLexer that we must do things like MATCHS() with.
 *  C will normally just lay down 8 bit characters, and you can use L"xxx" to
 *  get wchar_t, but wchar_t is 16 bits on Windows, which is not UTF32 and so
 *  we perform this little trick of defining the literals as arrays of UINT32
 *  and passing in the address of these.
 */
static ANTLR3_UCHAR	lit_1[]  = { 0x32, 0x32, 0x34,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_2[]  = { 0x32, 0x35, 0x36,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_3[]  = { 0x33, 0x38, 0x34,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_4[]  = { 0x35, 0x31, 0x32,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_5[]  = { 0x5F, 0x3A,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_6[]  = { 0x27, 0x27, 0x27,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_7[]  = { 0x27, 0x27,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_8[]  = { 0x22, 0x22, 0x22,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_9[]  = { 0x22, 0x22,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_10[]  = { 0x5E, 0x5E,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_11[]  = { 0x3C, 0x3D,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_12[]  = { 0x3E, 0x3D,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_13[]  = { 0x21, 0x3D,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_14[]  = { 0x26, 0x26,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_15[]  = { 0x7C, 0x7C,  ANTLR3_STRING_TERMINATOR};





/* MACROS that hide the C interface implementations from the
 * generated code, which makes it a little more understandable to the human eye.
 * I am very much against using C pre-processor macros for function calls and bits
 * of code as you cannot see what is happening when single stepping in debuggers
 * and so on. The exception (in my book at least) is for generated code, where you are
 * not maintaining it, but may wish to read and understand it. If you single step it, you know that input()
 * hides some indirect calls, but is always referring to the input stream. This is
 * probably more readable than ctx->input->istream->input(snarfle0->blarg) and allows me to rejig
 * the runtime interfaces without changing the generated code too often, without
 * confusing the reader of the generated output, who may not wish to know the gory
 * details of the interface inheritance.
 */

#define		CTX	ctx

/* Aids in accessing scopes for grammar programmers
 */
#undef	SCOPE_TYPE
#undef	SCOPE_STACK
#undef	SCOPE_TOP
#define	SCOPE_TYPE(scope)   pSparqlLexer_##scope##_SCOPE
#define SCOPE_STACK(scope)  pSparqlLexer_##scope##Stack
#define	SCOPE_TOP(scope)    ctx->pSparqlLexer_##scope##Top
#define	SCOPE_SIZE(scope)		ctx->pSparqlLexer_##scope##Stack_limit
#define SCOPE_INSTANCE(scope, i)	(ctx->SCOPE_STACK(scope)->get(ctx->SCOPE_STACK(scope),i))


/* Macros for accessing things in a lexer
 */
#undef	    LEXER
#undef	    RECOGNIZER
#undef	    RULEMEMO
#undef	    GETCHARINDEX
#undef	    GETLINE
#undef	    GETCHARPOSITIONINLINE
#undef	    EMIT
#undef	    EMITNEW
#undef	    MATCHC
#undef	    MATCHS
#undef	    MATCHRANGE
#undef	    LTOKEN
#undef	    HASFAILED
#undef	    FAILEDFLAG
#undef	    INPUT
#undef	    STRSTREAM
#undef	    LA
#undef	    HASEXCEPTION
#undef	    EXCEPTION
#undef	    CONSTRUCTEX
#undef	    CONSUME
#undef	    LRECOVER
#undef	    MARK
#undef	    REWIND
#undef	    REWINDLAST
#undef	    BACKTRACKING
#undef		MATCHANY
#undef		MEMOIZE
#undef		HAVEPARSEDRULE
#undef		GETTEXT
#undef		INDEX
#undef		SEEK
#undef		PUSHSTREAM
#undef		POPSTREAM
#undef		SETTEXT
#undef		SETTEXT8

#define	    LEXER					ctx->pLexer
#define	    RECOGNIZER			    LEXER->rec
#define		LEXSTATE				RECOGNIZER->state
#define		TOKSOURCE				LEXSTATE->tokSource
#define	    GETCHARINDEX()			LEXER->getCharIndex(LEXER)
#define	    GETLINE()				LEXER->getLine(LEXER)
#define	    GETTEXT()				LEXER->getText(LEXER)
#define	    GETCHARPOSITIONINLINE() LEXER->getCharPositionInLine(LEXER)
#define	    EMIT()					LEXSTATE->type = _type; LEXER->emit(LEXER)
#define	    EMITNEW(t)				LEXER->emitNew(LEXER, t)
#define	    MATCHC(c)				LEXER->matchc(LEXER, c)
#define	    MATCHS(s)				LEXER->matchs(LEXER, s)
#define	    MATCHRANGE(c1,c2)	    LEXER->matchRange(LEXER, c1, c2)
#define	    MATCHANY()				LEXER->matchAny(LEXER)
#define	    LTOKEN  				LEXSTATE->token
#define	    HASFAILED()				(LEXSTATE->failed == ANTLR3_TRUE)
#define	    BACKTRACKING			LEXSTATE->backtracking
#define	    FAILEDFLAG				LEXSTATE->failed
#define	    INPUT					LEXER->input
#define	    STRSTREAM				INPUT
#define		ISTREAM					INPUT->istream
#define		INDEX()					ISTREAM->index(ISTREAM)
#define		SEEK(n)					ISTREAM->seek(ISTREAM, n)
#define	    EOF_TOKEN				&(LEXSTATE->tokSource->eofToken)
#define	    HASEXCEPTION()			(LEXSTATE->error == ANTLR3_TRUE)
#define	    EXCEPTION				LEXSTATE->exception
#define	    CONSTRUCTEX()			RECOGNIZER->exConstruct(RECOGNIZER)
#define	    LRECOVER()				LEXER->recover(LEXER)
#define	    MARK()					ISTREAM->mark(ISTREAM)
#define	    REWIND(m)				ISTREAM->rewind(ISTREAM, m)
#define	    REWINDLAST()			ISTREAM->rewindLast(ISTREAM)
#define		MEMOIZE(ri,si)			RECOGNIZER->memoize(RECOGNIZER, ri, si)
#define		HAVEPARSEDRULE(r)		RECOGNIZER->alreadyParsedRule(RECOGNIZER, r)
#define		PUSHSTREAM(str)			LEXER->pushCharStream(LEXER, str)
#define		POPSTREAM()				LEXER->popCharStream(LEXER)
#define		SETTEXT(str)			LEXSTATE->text = str
#define		SKIP()					LEXSTATE->token = &(TOKSOURCE->skipToken)
#define		USER1					LEXSTATE->user1
#define		USER2					LEXSTATE->user2
#define		USER3					LEXSTATE->user3
#define		CUSTOM					LEXSTATE->custom
#define		RULEMEMO				LEXSTATE->ruleMemo
#define		DBG						RECOGNIZER->debugger

/* If we have been told we can rely on the standard 8 bit or UTF16 input
 * stream, then we can define our macros to use the direct pointers
 * in the input object, which is much faster than indirect calls. This
 * is really only significant to lexers with a lot of fragment rules (which
 * do not place LA(1) in a temporary at the moment) and even then
 * only if there is a lot of input (order of say 1M or so).
 */
#if	defined(ANTLR3_INLINE_INPUT_8BIT) || defined(ANTLR3_INLINE_INPUT_UTF16)

# ifdef	ANTLR3_INLINE_INPUT_8BIT

/* 8 bit character set */

#  define	    NEXTCHAR	((pANTLR3_UINT8)(INPUT->nextChar))
#  define	    DATAP	((pANTLR3_UINT8)(INPUT->data))

# else

#  define	    NEXTCHAR	((pANTLR3_UINT16)(INPUT->nextChar))
#  define	    DATAP	((pANTLR3_UINT16)(INPUT->data))

# endif

# define	    LA(n) ((NEXTCHAR + n) > (DATAP + INPUT->sizeBuf) ? ANTLR3_CHARSTREAM_EOF : (ANTLR3_UCHAR)(*(NEXTCHAR + n - 1)))
# define            CONSUME()                                           \
{                                                                       \
    if        (NEXTCHAR < (DATAP + INPUT->sizeBuf))                     \
    {                                                                   \
        INPUT->charPositionInLine++;                                    \
        if  ((ANTLR3_UCHAR)(*NEXTCHAR) == INPUT->newlineChar)           \
        {                                                               \
            INPUT->line++;                                              \
            INPUT->charPositionInLine        = 0;                       \
            INPUT->currentLine                = (void *)(NEXTCHAR + 1); \
        }                                                               \
        INPUT->nextChar = (void *)(NEXTCHAR + 1);                       \
    }                                                                   \
}

#else

// Pick up the input character by calling the input stream implementation.
//
#define	    CONSUME()   INPUT->istream->consume(INPUT->istream)
#define	    LA(n)       INPUT->istream->_LA(INPUT->istream, n)

#endif

#define		TOKTEXT(tok, txt)				tok, (pANTLR3_UINT8)txt

/* The 4 tokens defined below may well clash with your own #defines or token types. If so
 * then for the present you must use different names for your defines as these are hard coded
 * in the code generator. It would be better not to use such names internally, and maybe
 * we can change this in a forthcoming release. I deliberately do not #undef these
 * here as this will at least give you a redefined error somewhere if they clash.
 */
#define	    UP	    ANTLR3_TOKEN_UP
#define	    DOWN    ANTLR3_TOKEN_DOWN
#define	    EOR	    ANTLR3_TOKEN_EOR
#define	    INVALID ANTLR3_TOKEN_INVALID


/* =============================================================================
 * Functions to create and destroy scopes. First come the rule scopes, followed
 * by the global declared scopes.
 */



/* ============================================================================= */

/* =============================================================================
 * Start of recognizer
 */

/* Forward declare the locally static matching functions we have generated and any predicate functions.
 */
static ANTLR3_INLINE 
 void
	mWS    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mBASE    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mPREFIX    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mSELECT    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mDISTINCT    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mREDUCED    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mCONSTRUCT    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mDESCRIBE    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mASK    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mFROM    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mNAMED    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mWHERE    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mORDER    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mBY    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mASC    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mDESC    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mLIMIT    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mOFFSET    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mOPTIONAL    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mGRAPH    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mUNION    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mFILTER    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mA    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mSTR    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mLANG    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mLANGMATCHES    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mDATATYPE    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mBOUND    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mSAMETERM    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mISIRI    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mISURI    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mISBLANK    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mISLITERAL    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mREGEX    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mSUBSTR    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mTRUE    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mFALSE    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mLOAD    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mCLEAR    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mDROP    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mADD    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mMOVE    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mCOPY    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mCREATE    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mDELETE    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mINSERT    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mUSING    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mSILENT    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mDEFAULT    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mALL    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mDATA    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mWITH    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mINTO    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mTO    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mAS    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mGROUP    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mHAVING    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mUNDEF    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mBINDINGS    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mSERVICE    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mBIND    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mMINUS_KEYWORD    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mIRI    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mURI    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mBNODE    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mRAND    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mABS    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mCEIL    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mFLOOR    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mROUND    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mCONCAT    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mSTRLEN    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mUCASE    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mLCASE    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mENCODE_FOR_URI    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mCONTAINS    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mSTRSTARTS    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mSTRENDS    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mYEAR    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mMONTH    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mDAY    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mHOURS    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mMINUTES    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mSECONDS    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mTIMEZONE    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mTZ    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mNOW    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mMD5    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mSHA1    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mSHA224    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mSHA256    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mSHA384    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mSHA512    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mCOALESCE    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mIF    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mSTRLANG    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mSTRDT    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mISNUMERIC    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mCOUNT    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mSUM    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mMIN    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mMAX    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mAVG    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mSAMPLE    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mGROUP_CONCAT    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mNOT    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mIN    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mEXISTS    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mSEPARATOR    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mPNAME_NS    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mPNAME_LN    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mBLANK_NODE_LABEL    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mVAR1    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mVAR2    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mLANGTAG    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mINTEGER    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mDECIMAL    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mDOUBLE    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mINTEGER_POSITIVE    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mDECIMAL_POSITIVE    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mDOUBLE_POSITIVE    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mINTEGER_NEGATIVE    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mDECIMAL_NEGATIVE    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mDOUBLE_NEGATIVE    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mEXPONENT    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mSTRING_LITERAL1    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mSTRING_LITERAL2    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mSTRING_LITERAL_LONG1    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mSTRING_LITERAL_LONG2    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mECHAR    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mIRI_REF    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mIRI_REF_CHARACTERS    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mPN_CHARS_U    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mVARNAME    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mPN_CHARS    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mPN_PREFIX    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mPN_LOCAL    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mPN_CHARS_BASE    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mDIGIT    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mCOMMENT    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mEOL    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mREFERENCE    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mLESS_EQUAL    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mGREATER_EQUAL    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mNOT_EQUAL    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mAND    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mOR    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mINVERSE    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mOPEN_BRACE    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mCLOSE_BRACE    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mOPEN_CURLY_BRACE    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mCLOSE_CURLY_BRACE    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mOPEN_SQUARE_BRACKET    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mCLOSE_SQUARE_BRACKET    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mSEMICOLON    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mDOT    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mPLUS    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mMINUS    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mSIGN    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mASTERISK    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mQUESTION_MARK    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mCOMMA    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mNEGATION    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mDIVIDE    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mEQUAL    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mLESS    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mGREATER    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mPIPE    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mANY    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 void
	mTokens    (pSparqlLexer ctx);
static ANTLR3_INLINE 
 ANTLR3_BOOLEAN
	synpred1_Sparql    (pSparqlLexer ctx);
static void	SparqlLexerFree(pSparqlLexer ctx);

/* =========================================================================
 * Lexer matching rules end.
 * =========================================================================
 */



static void
SparqlLexerFree  (pSparqlLexer ctx)
{
    LEXER->free(LEXER);

    ANTLR3_FREE(ctx);
}

static void
SparqlLexerReset (pSparqlLexer ctx)
{
    RECOGNIZER->reset(RECOGNIZER);
}

/** \brief Name of the grammar file that generated this code
 */
static const char fileName[] = "Sparql.g";

/** \brief Return the name of the grammar file that generated this code.
 */
static const char * getGrammarFileName()
{
	return fileName;
}

/** \brief Create a new lexer called SparqlLexer
 *
 * \param[in]    instream Pointer to an initialized input stream
 * \return
 *     - Success pSparqlLexer initialized for the lex start
 *     - Fail NULL
 */
ANTLR3_API pSparqlLexer SparqlLexerNew
(
pANTLR3_INPUT_STREAM
 instream)
{
	// See if we can create a new lexer with the standard constructor
	//
	return SparqlLexerNewSSD(instream, NULL);
}

/** \brief Create a new lexer called SparqlLexer
 *
 * \param[in]    instream Pointer to an initialized input stream
 * \param[state] state Previously created shared recognizer stat
 * \return
 *     - Success pSparqlLexer initialized for the lex start
 *     - Fail NULL
 */
ANTLR3_API pSparqlLexer SparqlLexerNewSSD
(pANTLR3_INPUT_STREAM instream, pANTLR3_RECOGNIZER_SHARED_STATE state)
{
    pSparqlLexer ctx; // Context structure we will build and return

    ctx = (pSparqlLexer) ANTLR3_CALLOC(1, sizeof(SparqlLexer));

    if  (ctx == NULL)
    {
        // Failed to allocate memory for lexer context
        return  NULL;
    }

    /* -------------------------------------------------------------------
     * Memory for basic structure is allocated, now to fill in
     * in base ANTLR3 structures. We initialize the function pointers
     * for the standard ANTLR3 lexer function set, but upon return
     * from here, the programmer may set the pointers to provide custom
     * implementations of each function.
     *
     * We don't use the macros defined in SparqlLexer.h here so you can get a sense
     * of what goes where.
     */

    /* Create a base lexer, using the supplied input stream
     */
    ctx->pLexer	= antlr3LexerNewStream(ANTLR3_SIZE_HINT, instream, state);

    /* Check that we allocated the memory correctly
     */
    if	(ctx->pLexer == NULL)
    {
		ANTLR3_FREE(ctx);
		return  NULL;
    }
    /* Install the implementation of our SparqlLexer interface
     */
    ctx->mWS	= mWS;
    ctx->mBASE	= mBASE;
    ctx->mPREFIX	= mPREFIX;
    ctx->mSELECT	= mSELECT;
    ctx->mDISTINCT	= mDISTINCT;
    ctx->mREDUCED	= mREDUCED;
    ctx->mCONSTRUCT	= mCONSTRUCT;
    ctx->mDESCRIBE	= mDESCRIBE;
    ctx->mASK	= mASK;
    ctx->mFROM	= mFROM;
    ctx->mNAMED	= mNAMED;
    ctx->mWHERE	= mWHERE;
    ctx->mORDER	= mORDER;
    ctx->mBY	= mBY;
    ctx->mASC	= mASC;
    ctx->mDESC	= mDESC;
    ctx->mLIMIT	= mLIMIT;
    ctx->mOFFSET	= mOFFSET;
    ctx->mOPTIONAL	= mOPTIONAL;
    ctx->mGRAPH	= mGRAPH;
    ctx->mUNION	= mUNION;
    ctx->mFILTER	= mFILTER;
    ctx->mA	= mA;
    ctx->mSTR	= mSTR;
    ctx->mLANG	= mLANG;
    ctx->mLANGMATCHES	= mLANGMATCHES;
    ctx->mDATATYPE	= mDATATYPE;
    ctx->mBOUND	= mBOUND;
    ctx->mSAMETERM	= mSAMETERM;
    ctx->mISIRI	= mISIRI;
    ctx->mISURI	= mISURI;
    ctx->mISBLANK	= mISBLANK;
    ctx->mISLITERAL	= mISLITERAL;
    ctx->mREGEX	= mREGEX;
    ctx->mSUBSTR	= mSUBSTR;
    ctx->mTRUE	= mTRUE;
    ctx->mFALSE	= mFALSE;
    ctx->mLOAD	= mLOAD;
    ctx->mCLEAR	= mCLEAR;
    ctx->mDROP	= mDROP;
    ctx->mADD	= mADD;
    ctx->mMOVE	= mMOVE;
    ctx->mCOPY	= mCOPY;
    ctx->mCREATE	= mCREATE;
    ctx->mDELETE	= mDELETE;
    ctx->mINSERT	= mINSERT;
    ctx->mUSING	= mUSING;
    ctx->mSILENT	= mSILENT;
    ctx->mDEFAULT	= mDEFAULT;
    ctx->mALL	= mALL;
    ctx->mDATA	= mDATA;
    ctx->mWITH	= mWITH;
    ctx->mINTO	= mINTO;
    ctx->mTO	= mTO;
    ctx->mAS	= mAS;
    ctx->mGROUP	= mGROUP;
    ctx->mHAVING	= mHAVING;
    ctx->mUNDEF	= mUNDEF;
    ctx->mBINDINGS	= mBINDINGS;
    ctx->mSERVICE	= mSERVICE;
    ctx->mBIND	= mBIND;
    ctx->mMINUS_KEYWORD	= mMINUS_KEYWORD;
    ctx->mIRI	= mIRI;
    ctx->mURI	= mURI;
    ctx->mBNODE	= mBNODE;
    ctx->mRAND	= mRAND;
    ctx->mABS	= mABS;
    ctx->mCEIL	= mCEIL;
    ctx->mFLOOR	= mFLOOR;
    ctx->mROUND	= mROUND;
    ctx->mCONCAT	= mCONCAT;
    ctx->mSTRLEN	= mSTRLEN;
    ctx->mUCASE	= mUCASE;
    ctx->mLCASE	= mLCASE;
    ctx->mENCODE_FOR_URI	= mENCODE_FOR_URI;
    ctx->mCONTAINS	= mCONTAINS;
    ctx->mSTRSTARTS	= mSTRSTARTS;
    ctx->mSTRENDS	= mSTRENDS;
    ctx->mYEAR	= mYEAR;
    ctx->mMONTH	= mMONTH;
    ctx->mDAY	= mDAY;
    ctx->mHOURS	= mHOURS;
    ctx->mMINUTES	= mMINUTES;
    ctx->mSECONDS	= mSECONDS;
    ctx->mTIMEZONE	= mTIMEZONE;
    ctx->mTZ	= mTZ;
    ctx->mNOW	= mNOW;
    ctx->mMD5	= mMD5;
    ctx->mSHA1	= mSHA1;
    ctx->mSHA224	= mSHA224;
    ctx->mSHA256	= mSHA256;
    ctx->mSHA384	= mSHA384;
    ctx->mSHA512	= mSHA512;
    ctx->mCOALESCE	= mCOALESCE;
    ctx->mIF	= mIF;
    ctx->mSTRLANG	= mSTRLANG;
    ctx->mSTRDT	= mSTRDT;
    ctx->mISNUMERIC	= mISNUMERIC;
    ctx->mCOUNT	= mCOUNT;
    ctx->mSUM	= mSUM;
    ctx->mMIN	= mMIN;
    ctx->mMAX	= mMAX;
    ctx->mAVG	= mAVG;
    ctx->mSAMPLE	= mSAMPLE;
    ctx->mGROUP_CONCAT	= mGROUP_CONCAT;
    ctx->mNOT	= mNOT;
    ctx->mIN	= mIN;
    ctx->mEXISTS	= mEXISTS;
    ctx->mSEPARATOR	= mSEPARATOR;
    ctx->mPNAME_NS	= mPNAME_NS;
    ctx->mPNAME_LN	= mPNAME_LN;
    ctx->mBLANK_NODE_LABEL	= mBLANK_NODE_LABEL;
    ctx->mVAR1	= mVAR1;
    ctx->mVAR2	= mVAR2;
    ctx->mLANGTAG	= mLANGTAG;
    ctx->mINTEGER	= mINTEGER;
    ctx->mDECIMAL	= mDECIMAL;
    ctx->mDOUBLE	= mDOUBLE;
    ctx->mINTEGER_POSITIVE	= mINTEGER_POSITIVE;
    ctx->mDECIMAL_POSITIVE	= mDECIMAL_POSITIVE;
    ctx->mDOUBLE_POSITIVE	= mDOUBLE_POSITIVE;
    ctx->mINTEGER_NEGATIVE	= mINTEGER_NEGATIVE;
    ctx->mDECIMAL_NEGATIVE	= mDECIMAL_NEGATIVE;
    ctx->mDOUBLE_NEGATIVE	= mDOUBLE_NEGATIVE;
    ctx->mEXPONENT	= mEXPONENT;
    ctx->mSTRING_LITERAL1	= mSTRING_LITERAL1;
    ctx->mSTRING_LITERAL2	= mSTRING_LITERAL2;
    ctx->mSTRING_LITERAL_LONG1	= mSTRING_LITERAL_LONG1;
    ctx->mSTRING_LITERAL_LONG2	= mSTRING_LITERAL_LONG2;
    ctx->mECHAR	= mECHAR;
    ctx->mIRI_REF	= mIRI_REF;
    ctx->mIRI_REF_CHARACTERS	= mIRI_REF_CHARACTERS;
    ctx->mPN_CHARS_U	= mPN_CHARS_U;
    ctx->mVARNAME	= mVARNAME;
    ctx->mPN_CHARS	= mPN_CHARS;
    ctx->mPN_PREFIX	= mPN_PREFIX;
    ctx->mPN_LOCAL	= mPN_LOCAL;
    ctx->mPN_CHARS_BASE	= mPN_CHARS_BASE;
    ctx->mDIGIT	= mDIGIT;
    ctx->mCOMMENT	= mCOMMENT;
    ctx->mEOL	= mEOL;
    ctx->mREFERENCE	= mREFERENCE;
    ctx->mLESS_EQUAL	= mLESS_EQUAL;
    ctx->mGREATER_EQUAL	= mGREATER_EQUAL;
    ctx->mNOT_EQUAL	= mNOT_EQUAL;
    ctx->mAND	= mAND;
    ctx->mOR	= mOR;
    ctx->mINVERSE	= mINVERSE;
    ctx->mOPEN_BRACE	= mOPEN_BRACE;
    ctx->mCLOSE_BRACE	= mCLOSE_BRACE;
    ctx->mOPEN_CURLY_BRACE	= mOPEN_CURLY_BRACE;
    ctx->mCLOSE_CURLY_BRACE	= mCLOSE_CURLY_BRACE;
    ctx->mOPEN_SQUARE_BRACKET	= mOPEN_SQUARE_BRACKET;
    ctx->mCLOSE_SQUARE_BRACKET	= mCLOSE_SQUARE_BRACKET;
    ctx->mSEMICOLON	= mSEMICOLON;
    ctx->mDOT	= mDOT;
    ctx->mPLUS	= mPLUS;
    ctx->mMINUS	= mMINUS;
    ctx->mSIGN	= mSIGN;
    ctx->mASTERISK	= mASTERISK;
    ctx->mQUESTION_MARK	= mQUESTION_MARK;
    ctx->mCOMMA	= mCOMMA;
    ctx->mNEGATION	= mNEGATION;
    ctx->mDIVIDE	= mDIVIDE;
    ctx->mEQUAL	= mEQUAL;
    ctx->mLESS	= mLESS;
    ctx->mGREATER	= mGREATER;
    ctx->mPIPE	= mPIPE;
    ctx->mANY	= mANY;
    ctx->mTokens	= mTokens;


    /** When the nextToken() call is made to this lexer's pANTLR3_TOKEN_SOURCE
     *  it will call mTokens() in this generated code, and will pass it the ctx
     * pointer of this lexer, not the context of the base lexer, so store that now.
     */
    ctx->pLexer->ctx	    = ctx;

    /**Install the token matching function
     */
    ctx->pLexer->mTokens = (void (*) (void *))(mTokens);

    ctx->getGrammarFileName	= getGrammarFileName;
    ctx->free		= SparqlLexerFree;
    ctx->reset          = SparqlLexerReset;


    /* Return the newly built lexer to the caller
     */
    return  ctx;
}

/* =========================================================================
 * DFA tables for the lexer
 */
/** Static dfa state tables for Cyclic dfa:
 *    920:1: DOUBLE : ( ( DIGIT )+ DOT ( DIGIT )* EXPONENT | DOT ( DIGIT )+ EXPONENT | ( DIGIT )+ EXPONENT );
 */
static const ANTLR3_INT32 dfa15_eot[5] =
    {
	-1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa15_eof[5] =
    {
	-1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa15_min[5] =
    {
	46, 46, -1, -1, -1
    };
static const ANTLR3_INT32 dfa15_max[5] =
    {
	57, 101, -1, -1, -1
    };
static const ANTLR3_INT32 dfa15_accept[5] =
    {
	-1, -1, 2, 1, 3
    };
static const ANTLR3_INT32 dfa15_special[5] =
    {
	-1, -1, -1, -1, -1
    };

/** Used when there is no transition table entry for a particular state */
#define dfa15_T_empty	    NULL

static const ANTLR3_INT32 dfa15_T0[] =
    {
	3, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4
    };

static const ANTLR3_INT32 dfa15_T1[] =
    {
	2, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1
    };


/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR3_INT32 * const dfa15_transitions[] =
{
    dfa15_T1, dfa15_T0, NULL, NULL, NULL
};


/* Declare tracking structure for Cyclic DFA 15
 */
static
ANTLR3_CYCLIC_DFA cdfa15
    =	{
	    15,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const pANTLR3_UCHAR)"920:1: DOUBLE_PP : ( ( DIGIT )+ DOT ( DIGIT )* EXPONENT | DOT ( DIGIT )+ EXPONENT | ( DIGIT )+ EXPONENT );",
	    (CDFA_SPECIAL_FUNC) antlr3dfaspecialStateTransition,	/* Default special state transition function	*/

	    antlr3dfaspecialTransition,		/* DFA specialTransition is currently just a default function in the runtime */
	    antlr3dfapredict,			/* DFA simulator function is in the runtime */
	    dfa15_eot,	    /* EOT table			    */
	    dfa15_eof,	    /* EOF table			    */
	    dfa15_min,	    /* Minimum tokens for each state    */
	    dfa15_max,	    /* Maximum tokens for each state    */
	    dfa15_accept,	/* Accept table			    */
	    dfa15_special,	/* Special transition states	    */
	    dfa15_transitions	/* Table of transition tables	    */

	};
/* End of Cyclic DFA 15
 * ---------------------
 *//** Static dfa state tables for Cyclic dfa:
 *    1:1: Tokens : ( WS | BASE | PREFIX | SELECT | DISTINCT | REDUCED | CONSTRUCT | DESCRIBE | ASK | FROM | NAMED | WHERE | ORDER | BY | ASC | DESC | LIMIT | OFFSET | OPTIONAL | GRAPH | UNION | FILTER | A | STR | LANG | LANGMATCHES | DATATYPE | BOUND | SAMETERM | ISIRI | ISURI | ISBLANK | ISLITERAL | REGEX | SUBSTR | TRUE | FALSE | LOAD | CLEAR | DROP | ADD | MOVE | COPY | CREATE | DELETE | INSERT | USING | SILENT | DEFAULT | ALL | DATA | WITH | INTO | TO | AS | GROUP | HAVING | UNDEF | BINDINGS | SERVICE | BIND | MINUS_KEYWORD | IRI | URI | BNODE | RAND | ABS | CEIL | FLOOR | ROUND | CONCAT | STRLEN | UCASE | LCASE | ENCODE_FOR_URI | CONTAINS | STRSTARTS | STRENDS | YEAR | MONTH | DAY | HOURS | MINUTES | SECONDS | TIMEZONE | TZ | NOW | MD5 | SHA1 | SHA224 | SHA256 | SHA384 | SHA512 | COALESCE | IF | STRLANG | STRDT | ISNUMERIC | COUNT | SUM | MIN | MAX | AVG | SAMPLE | GROUP_CONCAT | NOT | IN | EXISTS | SEPARATOR | PNAME_NS | PNAME_LN | BLANK_NODE_LABEL | VAR1 | VAR2 | LANGTAG | INTEGER | DECIMAL | DOUBLE | INTEGER_POSITIVE | DECIMAL_POSITIVE | DOUBLE_POSITIVE | INTEGER_NEGATIVE | DECIMAL_NEGATIVE | DOUBLE_NEGATIVE | STRING_LITERAL1 | STRING_LITERAL2 | STRING_LITERAL_LONG1 | STRING_LITERAL_LONG2 | IRI_REF | COMMENT | REFERENCE | LESS_EQUAL | GREATER_EQUAL | NOT_EQUAL | AND | OR | INVERSE | OPEN_BRACE | CLOSE_BRACE | OPEN_CURLY_BRACE | CLOSE_CURLY_BRACE | OPEN_SQUARE_BRACKET | CLOSE_SQUARE_BRACKET | SEMICOLON | DOT | PLUS | MINUS | ASTERISK | QUESTION_MARK | COMMA | NEGATION | DIVIDE | EQUAL | GREATER | PIPE | ANY );
 */
static const ANTLR3_INT32 dfa34_eot[623] =
    {
	-1, -1, 53, 53, 53, 53, 53, 53, 86, 53, 53, 53, 53, 53, 53, 53, 53, 53, 
	53, 53, 53, 53, 53, 53, 124, 53, 127, 53, 53, 131, 135, 137, 140, 53, 53, 
	148, 53, 151, 153, 155, 53, 158, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 171, -1, -1, -1, -1, -1, 124, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 206, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 241, -1, 243, -1, 245, -1, 247, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, 131, 258, -1, -1, 258, -1, 260, -1, 
	-1, 264, -1, 144, -1, 146, -1, 270, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, 284, -1, -1, 288, -1, -1, -1, -1, -1, -1, -1, 299, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 314, 315, -1, 316, 317, 
	318, 319, -1, -1, -1, -1, -1, 325, 326, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, 341, -1, -1, -1, -1, -1, -1, -1, -1, -1, 350, -1, 
	-1, -1, -1, -1, -1, -1, 356, 357, 358, -1, -1, -1, -1, -1, -1, 258, -1, 
	364, -1, 364, -1, 366, -1, 366, -1, -1, -1, 368, -1, 371, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 387, -1, -1, -1, -1, 394, 
	-1, -1, 398, -1, 399, -1, -1, 402, -1, -1, -1, -1, 407, -1, -1, -1, -1, 
	412, -1, -1, -1, -1, -1, -1, 413, -1, -1, -1, -1, -1, -1, -1, 419, -1, 
	-1, -1, -1, 425, 426, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 440, -1, 441, -1, 443, -1, -1, -1, -1, -1, -1, -1, -1, -1, 451, -1, 
	364, -1, 366, -1, 452, -1, -1, 454, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	464, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 479, -1, 480, -1, -1, -1, -1, -1, 485, 486, -1, -1, -1, -1, 489, 490, 
	491, 492, -1, 493, -1, -1, 496, -1, -1, -1, 498, 499, 501, 502, 503, 504, 
	505, 506, 507, -1, -1, -1, -1, -1, -1, -1, -1, 513, 514, -1, -1, 517, -1, 
	-1, -1, -1, -1, -1, 521, 522, -1, -1, -1, 526, -1, -1, -1, -1, -1, 531, 
	532, 533, 534, 535, 536, 537, -1, -1, 540, -1, -1, -1, -1, -1, -1, 545, 
	-1, -1, -1, -1, 548, 549, -1, -1, -1, -1, -1, 550, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 557, -1, -1, -1, -1, 560, -1, 
	-1, 562, -1, -1, -1, 564, 565, -1, -1, 567, -1, 569, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, 573, -1, 575, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 582, -1, -1, -1, -1, 586, -1, -1, -1, 588, -1, -1, -1, -1, -1, -1, 
	591, 592, 593, -1, 594, -1, -1, 596, 597, 598, -1, -1, -1, -1, -1, 603, 
	-1, -1, -1, 605, 606, -1, -1, -1, -1, 607, -1, -1, -1, -1, -1, 610, 611, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 616, -1, -1, -1, 619, -1, -1, -1, 
	622, -1
    };
static const ANTLR3_INT32 dfa34_eof[623] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa34_min[623] =
    {
	0, -1, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 
	45, 45, 45, 45, 45, 45, 48, 58, 48, 48, 65, 46, 48, 46, 46, 0, 0, 61, 0, 
	94, 61, 61, 38, 124, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	45, 45, 45, 45, 45, 45, 45, 48, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 
	45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, -1, 45, 45, 45, 45, 
	45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 
	45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, -1, -1, -1, 
	-1, -1, -1, -1, -1, 46, 48, -1, -1, 48, -1, 46, 48, -1, 46, 48, 39, -1, 
	34, -1, 33, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, 45, -1, 45, 45, 45, 45, 45, 45, 45, 45, 45, 
	45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 
	45, 45, 45, 45, 45, 45, 45, -1, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 
	45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 
	45, 45, 45, 45, 45, 45, -1, 45, -1, 45, -1, 45, -1, 45, 45, 45, 45, 45, 
	45, 45, 45, 45, 45, -1, 48, -1, 48, -1, 48, -1, 48, -1, 48, -1, -1, -1, 
	45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, -1, 45, 45, 45, -1, 
	45, 45, 45, 45, 45, 45, 45, 45, 45, 45, -1, 45, 45, 45, 45, 45, 45, 45, 
	45, 45, 45, 45, 45, 45, 45, -1, -1, -1, -1, -1, -1, 45, 45, 45, 45, 45, 
	-1, -1, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, -1, 45, 
	45, 45, 45, 45, 45, 45, 45, -1, 45, 45, 45, 45, 45, -1, -1, -1, 45, 45, 
	45, 45, 45, -1, 48, -1, 48, -1, 45, 45, -1, 45, 45, 45, 45, 45, 45, 45, 
	45, 45, 45, 45, 45, 45, 45, 45, -1, 45, 45, 45, 45, 45, 45, -1, 45, 45, 
	45, -1, -1, 45, 45, -1, 45, 45, 45, 45, -1, 45, 45, 45, 45, -1, -1, 45, 
	45, 45, 45, 45, -1, 45, 45, 45, 45, 45, -1, -1, 45, 45, 45, 45, 45, 45, 
	45, 45, 45, 45, 45, 45, 45, -1, -1, 45, -1, 45, 45, 45, 45, 45, 45, 45, 
	-1, -1, 45, -1, 45, 45, 45, 45, 45, 45, 45, 45, 45, -1, 45, 45, 45, 45, 
	45, 45, 45, 45, 45, 45, 45, 45, 45, 45, -1, -1, 45, 45, 45, 45, -1, -1, 
	45, 45, -1, -1, -1, -1, -1, 45, 45, -1, 45, -1, -1, 45, -1, -1, -1, -1, 
	-1, -1, -1, 45, 45, 45, 45, 45, -1, -1, 45, 45, -1, 45, 45, 45, -1, -1, 
	45, 45, 45, -1, 45, 45, 45, 45, -1, -1, -1, -1, -1, -1, -1, 45, 45, -1, 
	45, 45, 45, 45, -1, 45, 45, -1, -1, -1, 45, 45, 45, 45, 45, 45, -1, 45, 
	45, -1, 45, -1, 45, -1, -1, 45, -1, 45, -1, 45, 45, 45, -1, 45, -1, 45, 
	45, 45, 45, 45, 45, -1, 45, 45, 45, -1, 45, -1, 45, 45, -1, -1, -1, -1, 
	45, -1, -1, -1, 45, 45, 45, 45, -1, 45, -1, -1, -1, 45, 45, -1, -1, 45, 
	45, 45, 45, -1, 45, 45, -1, 45, 45, -1
    };
static const ANTLR3_INT32 dfa34_max[623] =
    {
	65535, -1, 65533, 65533, 65533, 65533, 65533, 65533, 65533, 65533, 65533, 
	65533, 65533, 65533, 65533, 65533, 65533, 65533, 65533, 65533, 65533, 65533, 
	65533, 65533, 65533, 58, 65533, 65533, 122, 101, 57, 57, 57, 65535, 65535, 
	61, 65535, 94, 61, 61, 38, 124, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, 65533, 65533, 65533, 65533, 65533, 65533, 65533, 65533, 65533, 
	65533, 65533, 65533, 65533, 65533, 65533, 65533, 65533, 65533, 65533, 65533, 
	65533, 65533, 65533, 65533, 65533, 65533, 65533, 65533, 65533, 65533, 65533, 
	-1, 65533, 65533, 65533, 65533, 65533, 65533, 65533, 65533, 65533, 65533, 
	65533, 65533, 65533, 65533, 65533, 65533, 65533, 65533, 65533, 65533, 65533, 
	65533, 65533, 65533, 65533, 65533, 65533, 65533, 65533, 65533, 65533, 65533, 
	65533, 65533, 65533, 65533, 65533, -1, -1, -1, -1, -1, -1, -1, -1, 101, 
	101, -1, -1, 101, -1, 101, 57, -1, 101, 57, 39, -1, 34, -1, 65535, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, 65533, -1, 65533, 65533, 65533, 65533, 65533, 65533, 65533, 
	65533, 65533, 65533, 65533, 65533, 65533, 65533, 65533, 65533, 65533, 65533, 
	65533, 65533, 65533, 65533, 65533, 65533, 65533, 65533, 65533, 65533, 65533, 
	65533, 65533, 65533, 65533, 65533, -1, 65533, 65533, 65533, 65533, 65533, 
	65533, 65533, 65533, 65533, 65533, 65533, 65533, 65533, 65533, 65533, 65533, 
	65533, 65533, 65533, 65533, 65533, 65533, 65533, 65533, 65533, 65533, 65533, 
	65533, 65533, 65533, 65533, 65533, 65533, 65533, -1, 65533, -1, 65533, 
	-1, 65533, -1, 65533, 65533, 65533, 65533, 65533, 65533, 65533, 65533, 
	65533, 65533, -1, 101, -1, 101, -1, 101, -1, 101, -1, 101, -1, -1, -1, 
	65533, 65533, 65533, 65533, 65533, 65533, 65533, 65533, 65533, 65533, 65533, 
	65533, 65533, -1, 65533, 65533, 65533, -1, 65533, 65533, 65533, 65533, 
	65533, 65533, 65533, 65533, 65533, 65533, -1, 65533, 65533, 65533, 65533, 
	65533, 65533, 65533, 65533, 65533, 65533, 65533, 65533, 65533, 65533, -1, 
	-1, -1, -1, -1, -1, 65533, 65533, 65533, 65533, 65533, -1, -1, 65533, 65533, 
	65533, 65533, 65533, 65533, 65533, 65533, 65533, 65533, 65533, 65533, 65533, 
	65533, -1, 65533, 65533, 65533, 65533, 65533, 65533, 65533, 65533, -1, 
	65533, 65533, 65533, 65533, 65533, -1, -1, -1, 65533, 65533, 65533, 65533, 
	65533, -1, 101, -1, 101, -1, 65533, 65533, -1, 65533, 65533, 65533, 65533, 
	65533, 65533, 65533, 65533, 65533, 65533, 65533, 65533, 65533, 65533, 65533, 
	-1, 65533, 65533, 65533, 65533, 65533, 65533, -1, 65533, 65533, 65533, 
	-1, -1, 65533, 65533, -1, 65533, 65533, 65533, 65533, -1, 65533, 65533, 
	65533, 65533, -1, -1, 65533, 65533, 65533, 65533, 65533, -1, 65533, 65533, 
	65533, 65533, 65533, -1, -1, 65533, 65533, 65533, 65533, 65533, 65533, 
	65533, 65533, 65533, 65533, 65533, 65533, 65533, -1, -1, 65533, -1, 65533, 
	65533, 65533, 65533, 65533, 65533, 65533, -1, -1, 65533, -1, 65533, 65533, 
	65533, 65533, 65533, 65533, 65533, 65533, 65533, -1, 65533, 65533, 65533, 
	65533, 65533, 65533, 65533, 65533, 65533, 65533, 65533, 65533, 65533, 65533, 
	-1, -1, 65533, 65533, 65533, 65533, -1, -1, 65533, 65533, -1, -1, -1, -1, 
	-1, 65533, 65533, -1, 65533, -1, -1, 65533, -1, -1, -1, -1, -1, -1, -1, 
	65533, 65533, 65533, 65533, 65533, -1, -1, 65533, 65533, -1, 65533, 65533, 
	65533, -1, -1, 65533, 65533, 65533, -1, 65533, 65533, 65533, 65533, -1, 
	-1, -1, -1, -1, -1, -1, 65533, 65533, -1, 65533, 65533, 65533, 65533, -1, 
	65533, 65533, -1, -1, -1, 65533, 65533, 65533, 65533, 65533, 65533, -1, 
	65533, 65533, -1, 65533, -1, 65533, -1, -1, 65533, -1, 65533, -1, 65533, 
	65533, 65533, -1, 65533, -1, 65533, 65533, 65533, 65533, 65533, 65533, 
	-1, 65533, 65533, 65533, -1, 65533, -1, 65533, 65533, -1, -1, -1, -1, 65533, 
	-1, -1, -1, 65533, 65533, 65533, 65533, -1, 65533, -1, -1, -1, 65533, 65533, 
	-1, -1, 65533, 65533, 65533, 65533, -1, 65533, 65533, -1, 65533, 65533, 
	-1
    };
static const ANTLR3_INT32 dfa34_accept[623] =
    {
	-1, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, 138, 139, 140, 141, 142, 143, 144, 148, 150, 152, 
	153, 156, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 23, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	110, 111, 112, 149, 113, 114, 115, 116, -1, -1, 118, 145, -1, 146, -1, 
	-1, 147, -1, -1, -1, 125, -1, 126, -1, 129, 130, 131, 137, 133, 154, 134, 
	151, 135, 136, 155, 138, 139, 140, 141, 142, 143, 144, 148, 150, 152, 153, 
	-1, 14, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	55, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 107, 
	-1, 95, -1, 54, -1, 86, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 117, -1, 
	119, -1, 121, -1, 122, -1, 124, -1, 127, 128, 132, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 24, -1, -1, -1, 100, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, 81, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 9, 15, 41, 50, 67, 103, -1, -1, -1, -1, -1, 87, 106, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 64, -1, -1, -1, -1, -1, -1, 
	-1, -1, 63, -1, -1, -1, -1, -1, 101, 88, 102, -1, -1, -1, -1, -1, 120, 
	-1, 123, -1, 2, -1, -1, 61, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 89, -1, -1, -1, -1, -1, -1, 16, -1, -1, -1, 51, 40, -1, 
	-1, 66, -1, -1, -1, -1, 43, -1, -1, -1, -1, 68, 10, -1, -1, -1, -1, -1, 
	52, -1, -1, -1, -1, -1, 25, 38, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, 53, 36, -1, 42, -1, -1, -1, -1, -1, -1, -1, 79, 28, -1, 65, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, 97, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, 34, 70, -1, -1, -1, -1, 99, 39, -1, -1, 37, 69, 
	11, 12, 13, -1, -1, 17, -1, 74, 20, -1, 56, 21, 58, 47, 73, 30, 31, -1, 
	-1, -1, -1, -1, 80, 62, -1, -1, 82, -1, -1, -1, 3, 4, -1, -1, -1, 72, -1, 
	-1, -1, -1, 104, 35, 48, 90, 91, 92, 93, -1, -1, 45, -1, -1, -1, -1, 71, 
	-1, -1, 44, 22, 18, -1, -1, -1, -1, -1, -1, 46, -1, -1, 57, -1, 108, -1, 
	60, 84, -1, 96, -1, 78, -1, -1, -1, 49, -1, 6, -1, -1, -1, -1, -1, -1, 
	32, -1, -1, -1, 83, -1, 59, -1, -1, 29, 5, 8, 27, -1, 76, 94, 19, -1, -1, 
	-1, -1, 85, -1, 109, 77, 7, -1, -1, 33, 98, -1, -1, -1, -1, 26, -1, -1, 
	105, -1, -1, 75
    };
static const ANTLR3_INT32 dfa34_special[623] =
    {
	2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 3, -1, 1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };

/** Used when there is no transition table entry for a particular state */
#define dfa34_T_empty	    NULL

static ANTLR3_INT32 dfa34_T0[65489];
static const ANTLR3_INT32 dfa34_T0_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 18, 186, 1, 60, 7, -1,
	4, 60, 1, -1, 1, 60, 18, 186, 1, 60, 7, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T1[65489];
static const ANTLR3_INT32 dfa34_T1_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 8, 392, 1, 60, 17, -1,
	4, 60, 1, -1, 1, 60, 8, 392, 1, 60, 17, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T2[65489];
static const ANTLR3_INT32 dfa34_T2_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 7, 444, 1, 60, 18, -1,
	4, 60, 1, -1, 1, 60, 7, 444, 1, 60, 18, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T3[65489];
static const ANTLR3_INT32 dfa34_T3_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 19, 294, 1, 60, 6, -1,
	4, 60, 1, -1, 1, 60, 19, 294, 1, 60, 6, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T4[65489];
static const ANTLR3_INT32 dfa34_T4_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 19, 354, 1, 60, 6, -1,
	4, 60, 1, -1, 1, 60, 19, 354, 1, 60, 6, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T5[65489];
static const ANTLR3_INT32 dfa34_T5_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 19, 456, 1, 60, 6, -1,
	4, 60, 1, -1, 1, 60, 19, 456, 1, 60, 6, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T6[65489];
static const ANTLR3_INT32 dfa34_T6_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 2, 374, 1, 60, 23, -1,
	4, 60, 1, -1, 1, 60, 2, 374, 1, 60, 23, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T7[65489];
static const ANTLR3_INT32 dfa34_T7_compressed[71] = 
	{
	35, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 26, -1, 4, 60, 1, -1,
	1, 60, 26, -1, 60, 60, 1, -1, 8, 60, 23, -1, 1, 60, 31, -1, 1, 60, 646, -1,
	1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1, 47, 60, 288, -1, 2672, 60, 1008, -1,
	17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T8[65489];
static const ANTLR3_INT32 dfa34_T8_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 18, 448, 1, 60, 7, -1,
	4, 60, 1, -1, 1, 60, 18, 448, 1, 60, 7, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T9[1];
static const ANTLR3_INT32 dfa34_T9_compressed[3] = 
	{
	1, 154, 1 
	};

static ANTLR3_INT32 dfa34_T10[65489];
static const ANTLR3_INT32 dfa34_T10_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 17, 360, 1, 60, 8, -1,
	4, 60, 1, -1, 1, 60, 17, 360, 1, 60, 8, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T11[65489];
static const ANTLR3_INT32 dfa34_T11_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 20, 254, 1, 60, 5, -1,
	4, 60, 1, -1, 1, 60, 20, 254, 1, 60, 5, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T12[65489];
static const ANTLR3_INT32 dfa34_T12_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 20, 301, 1, 60, 5, -1,
	4, 60, 1, -1, 1, 60, 20, 301, 1, 60, 5, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T13[65489];
static const ANTLR3_INT32 dfa34_T13_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 2, 538, 1, 60, 23, -1,
	4, 60, 1, -1, 1, 60, 2, 538, 1, 60, 23, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T14[65489];
static const ANTLR3_INT32 dfa34_T14_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 13, 473, 1, 60, 12, -1,
	4, 60, 1, -1, 1, 60, 13, 473, 1, 60, 12, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T15[65489];
static const ANTLR3_INT32 dfa34_T15_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 12, 424, 1, 60, 13, -1,
	4, 60, 1, -1, 1, 60, 12, 424, 1, 60, 13, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T16[65489];
static const ANTLR3_INT32 dfa34_T16_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 19, 571, 1, 60, 6, -1,
	4, 60, 1, -1, 1, 60, 19, 571, 1, 60, 6, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T17[65489];
static const ANTLR3_INT32 dfa34_T17_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 4, 515, 1, 60, 21, -1,
	4, 60, 1, -1, 1, 60, 4, 515, 1, 60, 21, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T18[65489];
static const ANTLR3_INT32 dfa34_T18_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 18, 559, 1, 60, 7, -1,
	4, 60, 1, -1, 1, 60, 18, 559, 1, 60, 7, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T19[65489];
static const ANTLR3_INT32 dfa34_T19_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 2, 400, 1, 60, 23, -1,
	4, 60, 1, -1, 1, 60, 2, 400, 1, 60, 23, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T20[65489];
static const ANTLR3_INT32 dfa34_T20_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 4, 478, 1, 60, 21, -1,
	4, 60, 1, -1, 1, 60, 4, 478, 1, 60, 21, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T21[65489];
static const ANTLR3_INT32 dfa34_T21_compressed[75] = 
	{
	37, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 185, 1, 60, 25, -1, 4, 60,
	1, -1, 1, 185, 1, 60, 25, -1, 60, 60, 1, -1, 8, 60, 23, -1, 1, 60, 31, -1,
	1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1, 47, 60, 288, -1,
	2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T22[65489];
static const ANTLR3_INT32 dfa34_T22_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 3, 543, 1, 60, 22, -1,
	4, 60, 1, -1, 1, 60, 3, 543, 1, 60, 22, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T23[65489];
static const ANTLR3_INT32 dfa34_T23_compressed[103] = 
	{
	51, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 55, 1, 60, 7, 58, 1, 60,
	4, 59, 1, 57, 1, 60, 9, 56, 1, 60, 1, -1, 4, 60, 1, -1, 1, 55, 1, 60,
	7, 58, 1, 60, 4, 59, 1, 57, 1, 60, 9, 56, 1, 60, 1, -1, 60, 60, 1, -1,
	8, 60, 23, -1, 1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1,
	49, 60, 2, -1, 47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1,
	32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T24[54];
static const ANTLR3_INT32 dfa34_T24_compressed[11] = 
	{
	5, 367, 10, -1, 11, 266, 1, -1, 31, 266, 1 
	};

static ANTLR3_INT32 dfa34_T25[65489];
static const ANTLR3_INT32 dfa34_T25_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 19, 595, 1, 60, 6, -1,
	4, 60, 1, -1, 1, 60, 19, 595, 1, 60, 6, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T26[65489];
static const ANTLR3_INT32 dfa34_T26_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 12, 458, 1, 60, 13, -1,
	4, 60, 1, -1, 1, 60, 12, 458, 1, 60, 13, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T27[65489];
static const ANTLR3_INT32 dfa34_T27_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 18, 524, 1, 60, 7, -1,
	4, 60, 1, -1, 1, 60, 18, 524, 1, 60, 7, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T28[65489];
static const ANTLR3_INT32 dfa34_T28_compressed[83] = 
	{
	41, 60, 1, 61, 1, -1, 1, 60, 1, 290, 1, 291, 1, 292, 1, 60, 1, 293, 1, 60,
	4, 62, 1, -1, 6, 60, 26, -1, 4, 60, 1, -1, 1, 60, 26, -1, 60, 60, 1, -1,
	8, 60, 23, -1, 1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1,
	49, 60, 2, -1, 47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1,
	32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T29[65489];
static const ANTLR3_INT32 dfa34_T29_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 14, 278, 1, 60, 11, -1,
	4, 60, 1, -1, 1, 60, 14, 278, 1, 60, 11, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T30[65489];
static const ANTLR3_INT32 dfa34_T30_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 13, 376, 1, 60, 12, -1,
	4, 60, 1, -1, 1, 60, 13, 376, 1, 60, 12, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T31[65489];
static const ANTLR3_INT32 dfa34_T31_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 19, 404, 1, 60, 6, -1,
	4, 60, 1, -1, 1, 60, 19, 404, 1, 60, 6, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T32[65489];
static const ANTLR3_INT32 dfa34_T32_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 17, 481, 1, 60, 8, -1,
	4, 60, 1, -1, 1, 60, 17, 481, 1, 60, 8, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T33[65489];
static const ANTLR3_INT32 dfa34_T33_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 12, 246, 1, 60, 13, -1,
	4, 60, 1, -1, 1, 60, 12, 246, 1, 60, 13, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T34[1];
static const ANTLR3_INT32 dfa34_T34_compressed[3] = 
	{
	1, 152, 1 
	};

static ANTLR3_INT32 dfa34_T35[65489];
static const ANTLR3_INT32 dfa34_T35_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 20, 544, 1, 60, 5, -1,
	4, 60, 1, -1, 1, 60, 20, 544, 1, 60, 5, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T36[65489];
static const ANTLR3_INT32 dfa34_T36_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 2, 576, 1, 60, 23, -1,
	4, 60, 1, -1, 1, 60, 2, 576, 1, 60, 23, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T37[65489];
static const ANTLR3_INT32 dfa34_T37_compressed[75] = 
	{
	37, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 25, 442, 1, -1, 4, 60,
	1, -1, 1, 60, 25, 442, 1, -1, 60, 60, 1, -1, 8, 60, 23, -1, 1, 60, 31, -1,
	1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1, 47, 60, 288, -1,
	2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T38[65489];
static const ANTLR3_INT32 dfa34_T38_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 4, 352, 1, 60, 21, -1,
	4, 60, 1, -1, 1, 60, 4, 352, 1, 60, 21, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T39[65489];
static const ANTLR3_INT32 dfa34_T39_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 13, 558, 1, 60, 12, -1,
	4, 60, 1, -1, 1, 60, 13, 558, 1, 60, 12, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T40[65489];
static const ANTLR3_INT32 dfa34_T40_compressed[99] = 
	{
	49, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 72, 1, 60, 3, 71, 1, 60,
	3, 70, 1, 60, 8, 73, 1, 60, 8, -1, 4, 60, 1, -1, 1, 72, 1, 60, 3, 71,
	1, 60, 3, 70, 1, 60, 8, 73, 1, 60, 8, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T41[65489];
static const ANTLR3_INT32 dfa34_T41_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 14, 512, 1, 60, 11, -1,
	4, 60, 1, -1, 1, 60, 14, 512, 1, 60, 11, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T42[65489];
static const ANTLR3_INT32 dfa34_T42_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 4, 585, 1, 60, 21, -1,
	4, 60, 1, -1, 1, 60, 4, 585, 1, 60, 21, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T43[1];
static const ANTLR3_INT32 dfa34_T43_compressed[3] = 
	{
	1, 157, 1 
	};

static ANTLR3_INT32 dfa34_T44[65489];
static const ANTLR3_INT32 dfa34_T44_compressed[75] = 
	{
	37, 60, 1, 61, 1, -1, 1, 60, 5, 251, 1, 60, 4, 62, 1, -1, 6, 60, 26, -1,
	4, 60, 1, -1, 1, 60, 26, -1, 60, 60, 1, -1, 8, 60, 23, -1, 1, 60, 31, -1,
	1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1, 47, 60, 288, -1,
	2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T45[65489];
static const ANTLR3_INT32 dfa34_T45_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 4, 175, 1, 60, 21, -1,
	4, 60, 1, -1, 1, 60, 4, 175, 1, 60, 21, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T46[65489];
static const ANTLR3_INT32 dfa34_T46_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 18, 170, 1, 60, 7, -1,
	4, 60, 1, -1, 1, 60, 18, 170, 1, 60, 7, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T47[65489];
static const ANTLR3_INT32 dfa34_T47_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 4, 271, 1, 60, 21, -1,
	4, 60, 1, -1, 1, 60, 4, 271, 1, 60, 21, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T48[65489];
static const ANTLR3_INT32 dfa34_T48_compressed[83] = 
	{
	41, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 7, 93, 1, 94, 1, 60,
	17, -1, 4, 60, 1, -1, 1, 60, 7, 93, 1, 94, 1, 60, 17, -1, 60, 60, 1, -1,
	8, 60, 23, -1, 1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1,
	49, 60, 2, -1, 47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1,
	32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T49[54];
static const ANTLR3_INT32 dfa34_T49_compressed[11] = 
	{
	5, 267, 10, -1, 11, 266, 1, -1, 31, 266, 1 
	};

static ANTLR3_INT32 dfa34_T50[65489];
static const ANTLR3_INT32 dfa34_T50_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 4, 276, 1, 60, 21, -1,
	4, 60, 1, -1, 1, 60, 4, 276, 1, 60, 21, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T51[65489];
static const ANTLR3_INT32 dfa34_T51_compressed[75] = 
	{
	37, 60, 1, 61, 1, -1, 1, 60, 4, 469, 1, 60, 5, 62, 1, -1, 6, 60, 26, -1,
	4, 60, 1, -1, 1, 60, 26, -1, 60, 60, 1, -1, 8, 60, 23, -1, 1, 60, 31, -1,
	1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1, 47, 60, 288, -1,
	2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T52[65489];
static const ANTLR3_INT32 dfa34_T52_compressed[99] = 
	{
	49, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 2, 106, 1, 60, 10, 103,
	1, 60, 3, 105, 1, 104, 1, 60, 7, -1, 4, 60, 1, -1, 1, 60, 2, 106, 1, 60,
	10, 103, 1, 60, 3, 105, 1, 104, 1, 60, 7, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T53[65489];
static const ANTLR3_INT32 dfa34_T53_compressed[83] = 
	{
	41, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 18, 239, 1, 240, 1, 60,
	6, -1, 4, 60, 1, -1, 1, 60, 18, 239, 1, 240, 1, 60, 6, -1, 60, 60, 1, -1,
	8, 60, 23, -1, 1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1,
	49, 60, 2, -1, 47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1,
	32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T54[65489];
static const ANTLR3_INT32 dfa34_T54_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 23, 455, 1, 60, 2, -1,
	4, 60, 1, -1, 1, 60, 23, 455, 1, 60, 2, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T55[65489];
static const ANTLR3_INT32 dfa34_T55_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 5, 275, 1, 60, 20, -1,
	4, 60, 1, -1, 1, 60, 5, 275, 1, 60, 20, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T56[65489];
static const ANTLR3_INT32 dfa34_T56_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 8, 373, 1, 60, 17, -1,
	4, 60, 1, -1, 1, 60, 8, 373, 1, 60, 17, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T57[65489];
static const ANTLR3_INT32 dfa34_T57_compressed[75] = 
	{
	37, 60, 1, 61, 1, -1, 1, 60, 4, 471, 1, 60, 5, 62, 1, -1, 6, 60, 26, -1,
	4, 60, 1, -1, 1, 60, 26, -1, 60, 60, 1, -1, 8, 60, 23, -1, 1, 60, 31, -1,
	1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1, 47, 60, 288, -1,
	2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T58[65489];
static const ANTLR3_INT32 dfa34_T58_compressed[75] = 
	{
	37, 60, 1, 61, 1, -1, 1, 60, 8, 390, 1, 60, 1, 62, 1, -1, 6, 60, 26, -1,
	4, 60, 1, -1, 1, 60, 26, -1, 60, 60, 1, -1, 8, 60, 23, -1, 1, 60, 31, -1,
	1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1, 47, 60, 288, -1,
	2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T59[65489];
static const ANTLR3_INT32 dfa34_T59_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 17, 420, 1, 60, 8, -1,
	4, 60, 1, -1, 1, 60, 17, 420, 1, 60, 8, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T60[65536];
static const ANTLR3_INT32 dfa34_T60_compressed[15] = 
	{
	7, 144, 10, -1, 1, 144, 2, -1, 1, 144, 25, 143, 1, 144, 65496 
	};

static ANTLR3_INT32 dfa34_T61[65489];
static const ANTLR3_INT32 dfa34_T61_compressed[75] = 
	{
	37, 60, 1, 61, 1, -1, 1, 60, 6, 470, 1, 60, 3, 62, 1, -1, 6, 60, 26, -1,
	4, 60, 1, -1, 1, 60, 26, -1, 60, 60, 1, -1, 8, 60, 23, -1, 1, 60, 31, -1,
	1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1, 47, 60, 288, -1,
	2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T62[65489];
static const ANTLR3_INT32 dfa34_T62_compressed[75] = 
	{
	37, 60, 1, 61, 1, -1, 1, 60, 2, 472, 1, 60, 7, 62, 1, -1, 6, 60, 26, -1,
	4, 60, 1, -1, 1, 60, 26, -1, 60, 60, 1, -1, 8, 60, 23, -1, 1, 60, 31, -1,
	1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1, 47, 60, 288, -1,
	2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T63[65489];
static const ANTLR3_INT32 dfa34_T63_compressed[75] = 
	{
	37, 60, 1, 61, 1, -1, 1, 60, 1, 391, 1, 60, 8, 62, 1, -1, 6, 60, 26, -1,
	4, 60, 1, -1, 1, 60, 26, -1, 60, 60, 1, -1, 8, 60, 23, -1, 1, 60, 31, -1,
	1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1, 47, 60, 288, -1,
	2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T64[65489];
static const ANTLR3_INT32 dfa34_T64_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 12, 223, 1, 60, 13, -1,
	4, 60, 1, -1, 1, 60, 12, 223, 1, 60, 13, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T65[12];
static const ANTLR3_INT32 dfa34_T65_compressed[7] = 
	{
	3, 142, 1, -1, 1, 141, 10 
	};

static ANTLR3_INT32 dfa34_T66[65489];
static const ANTLR3_INT32 dfa34_T66_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 8, 332, 1, 60, 17, -1,
	4, 60, 1, -1, 1, 60, 8, 332, 1, 60, 17, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T67[65489];
static const ANTLR3_INT32 dfa34_T67_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 2, 547, 1, 60, 23, -1,
	4, 60, 1, -1, 1, 60, 2, 547, 1, 60, 23, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T68[65489];
static const ANTLR3_INT32 dfa34_T68_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 19, 423, 1, 60, 6, -1,
	4, 60, 1, -1, 1, 60, 19, 423, 1, 60, 6, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T69[65489];
static const ANTLR3_INT32 dfa34_T69_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 4, 578, 1, 60, 21, -1,
	4, 60, 1, -1, 1, 60, 4, 578, 1, 60, 21, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T70[65489];
static const ANTLR3_INT32 dfa34_T70_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 4, 408, 1, 60, 21, -1,
	4, 60, 1, -1, 1, 60, 4, 408, 1, 60, 21, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T71[65489];
static const ANTLR3_INT32 dfa34_T71_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 18, 484, 1, 60, 7, -1,
	4, 60, 1, -1, 1, 60, 18, 484, 1, 60, 7, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T72[54];
static const ANTLR3_INT32 dfa34_T72_compressed[11] = 
	{
	5, 259, 10, -1, 11, 134, 1, -1, 31, 134, 1 
	};

static ANTLR3_INT32 dfa34_T73[65489];
static const ANTLR3_INT32 dfa34_T73_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 5, 221, 1, 60, 20, -1,
	4, 60, 1, -1, 1, 60, 5, 221, 1, 60, 20, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T74[65489];
static const ANTLR3_INT32 dfa34_T74_compressed[83] = 
	{
	41, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 18, 445, 1, 446, 1, 60,
	6, -1, 4, 60, 1, -1, 1, 60, 18, 445, 1, 446, 1, 60, 6, -1, 60, 60, 1, -1,
	8, 60, 23, -1, 1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1,
	49, 60, 2, -1, 47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1,
	32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T75[65489];
static const ANTLR3_INT32 dfa34_T75_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 11, 309, 1, 60, 14, -1,
	4, 60, 1, -1, 1, 60, 11, 309, 1, 60, 14, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T76[65489];
static const ANTLR3_INT32 dfa34_T76_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 18, 330, 1, 60, 7, -1,
	4, 60, 1, -1, 1, 60, 18, 330, 1, 60, 7, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T77[65489];
static const ANTLR3_INT32 dfa34_T77_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 4, 421, 1, 60, 21, -1,
	4, 60, 1, -1, 1, 60, 4, 421, 1, 60, 21, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T78[65489];
static const ANTLR3_INT32 dfa34_T78_compressed[99] = 
	{
	49, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 118, 1, 60, 7, 116, 1, 60,
	3, 117, 1, 60, 1, 115, 1, 60, 11, -1, 4, 60, 1, -1, 1, 118, 1, 60, 7, 116,
	1, 60, 3, 117, 1, 60, 1, 115, 1, 60, 11, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T79[65489];
static const ANTLR3_INT32 dfa34_T79_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 19, 494, 1, 60, 6, -1,
	4, 60, 1, -1, 1, 60, 19, 494, 1, 60, 6, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T80[65489];
static const ANTLR3_INT32 dfa34_T80_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 13, 461, 1, 60, 12, -1,
	4, 60, 1, -1, 1, 60, 13, 461, 1, 60, 12, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T81[65489];
static const ANTLR3_INT32 dfa34_T81_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 19, 222, 1, 60, 6, -1,
	4, 60, 1, -1, 1, 60, 19, 222, 1, 60, 6, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T82[65489];
static const ANTLR3_INT32 dfa34_T82_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 8, 331, 1, 60, 17, -1,
	4, 60, 1, -1, 1, 60, 8, 331, 1, 60, 17, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T83[65536];
static const ANTLR3_INT32 dfa34_T83_compressed[3] = 
	{
	1, 149, 65536 
	};

static ANTLR3_INT32 dfa34_T84[65489];
static const ANTLR3_INT32 dfa34_T84_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 14, 422, 1, 60, 11, -1,
	4, 60, 1, -1, 1, 60, 14, 422, 1, 60, 11, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T85[65489];
static const ANTLR3_INT32 dfa34_T85_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 8, 474, 1, 60, 17, -1,
	4, 60, 1, -1, 1, 60, 8, 474, 1, 60, 17, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T86[65489];
static const ANTLR3_INT32 dfa34_T86_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 19, 382, 1, 60, 6, -1,
	4, 60, 1, -1, 1, 60, 19, 382, 1, 60, 6, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T87[65489];
static const ANTLR3_INT32 dfa34_T87_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 6, 527, 1, 60, 19, -1,
	4, 60, 1, -1, 1, 60, 6, 527, 1, 60, 19, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T88[65489];
static const ANTLR3_INT32 dfa34_T88_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 4, 572, 1, 60, 21, -1,
	4, 60, 1, -1, 1, 60, 4, 572, 1, 60, 21, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T89[65489];
static const ANTLR3_INT32 dfa34_T89_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 1, 539, 1, 60, 24, -1,
	4, 60, 1, -1, 1, 60, 1, 539, 1, 60, 24, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T90[65489];
static const ANTLR3_INT32 dfa34_T90_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 4, 510, 1, 60, 21, -1,
	4, 60, 1, -1, 1, 60, 4, 510, 1, 60, 21, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T91[65489];
static const ANTLR3_INT32 dfa34_T91_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 12, 438, 1, 60, 13, -1,
	4, 60, 1, -1, 1, 60, 12, 438, 1, 60, 13, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T92[65489];
static const ANTLR3_INT32 dfa34_T92_compressed[87] = 
	{
	43, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 1, 182, 1, 60, 10, 183,
	1, 60, 13, -1, 4, 60, 1, -1, 1, 60, 1, 182, 1, 60, 10, 183, 1, 60, 13, -1,
	60, 60, 1, -1, 8, 60, 23, -1, 1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1,
	12, 60, 2, -1, 49, 60, 2, -1, 47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1,
	8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T93[65489];
static const ANTLR3_INT32 dfa34_T93_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 8, 584, 1, 60, 17, -1,
	4, 60, 1, -1, 1, 60, 8, 584, 1, 60, 17, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T94[65489];
static const ANTLR3_INT32 dfa34_T94_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 17, 556, 1, 60, 8, -1,
	4, 60, 1, -1, 1, 60, 17, 556, 1, 60, 8, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T95[65489];
static const ANTLR3_INT32 dfa34_T95_compressed[95] = 
	{
	47, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 5, 96, 1, 60, 9, 97,
	1, 60, 1, 95, 1, 60, 8, -1, 4, 60, 1, -1, 1, 60, 5, 96, 1, 60, 9, 97,
	1, 60, 1, 95, 1, 60, 8, -1, 60, 60, 1, -1, 8, 60, 23, -1, 1, 60, 31, -1,
	1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1, 47, 60, 288, -1,
	2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T96[65489];
static const ANTLR3_INT32 dfa34_T96_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 8, 370, 1, 60, 17, -1,
	4, 60, 1, -1, 1, 60, 8, 370, 1, 60, 17, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T97[65489];
static const ANTLR3_INT32 dfa34_T97_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 12, 320, 1, 60, 13, -1,
	4, 60, 1, -1, 1, 60, 12, 320, 1, 60, 13, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T98[65489];
static const ANTLR3_INT32 dfa34_T98_compressed[83] = 
	{
	41, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 91, 1, 60, 13, 92, 1, 60,
	11, -1, 4, 60, 1, -1, 1, 91, 1, 60, 13, 92, 1, 60, 11, -1, 60, 60, 1, -1,
	8, 60, 23, -1, 1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1,
	49, 60, 2, -1, 47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1,
	32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T99[65489];
static const ANTLR3_INT32 dfa34_T99_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 14, 211, 1, 60, 11, -1,
	4, 60, 1, -1, 1, 60, 14, 211, 1, 60, 11, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T100[65489];
static const ANTLR3_INT32 dfa34_T100_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 20, 347, 1, 60, 5, -1,
	4, 60, 1, -1, 1, 60, 20, 347, 1, 60, 5, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T101[56];
static const ANTLR3_INT32 dfa34_T101_compressed[15] = 
	{
	7, 133, 1, -1, 1, 132, 10, -1, 11, 134, 1, -1, 31, 134, 1 
	};

static ANTLR3_INT32 dfa34_T102[1];
static const ANTLR3_INT32 dfa34_T102_compressed[3] = 
	{
	1, 126, 1 
	};

static ANTLR3_INT32 dfa34_T103[65489];
static const ANTLR3_INT32 dfa34_T103_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 12, 215, 1, 60, 13, -1,
	4, 60, 1, -1, 1, 60, 12, 215, 1, 60, 13, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T104[65489];
static const ANTLR3_INT32 dfa34_T104_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 13, 310, 1, 60, 12, -1,
	4, 60, 1, -1, 1, 60, 13, 310, 1, 60, 12, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T105[65489];
static const ANTLR3_INT32 dfa34_T105_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 4, 324, 1, 60, 21, -1,
	4, 60, 1, -1, 1, 60, 4, 324, 1, 60, 21, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T106[65489];
static const ANTLR3_INT32 dfa34_T106_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 19, 409, 1, 60, 6, -1,
	4, 60, 1, -1, 1, 60, 19, 409, 1, 60, 6, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T107[65489];
static const ANTLR3_INT32 dfa34_T107_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 2, 602, 1, 60, 23, -1,
	4, 60, 1, -1, 1, 60, 2, 602, 1, 60, 23, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T108[65489];
static const ANTLR3_INT32 dfa34_T108_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 3, 417, 1, 60, 22, -1,
	4, 60, 1, -1, 1, 60, 3, 417, 1, 60, 22, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T109[65489];
static const ANTLR3_INT32 dfa34_T109_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 4, 418, 1, 60, 21, -1,
	4, 60, 1, -1, 1, 60, 4, 418, 1, 60, 21, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T110[65489];
static const ANTLR3_INT32 dfa34_T110_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 4, 218, 1, 60, 21, -1,
	4, 60, 1, -1, 1, 60, 4, 218, 1, 60, 21, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T111[65489];
static const ANTLR3_INT32 dfa34_T111_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 17, 327, 1, 60, 8, -1,
	4, 60, 1, -1, 1, 60, 17, 327, 1, 60, 8, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T112[65489];
static const ANTLR3_INT32 dfa34_T112_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 3, 220, 1, 60, 22, -1,
	4, 60, 1, -1, 1, 60, 3, 220, 1, 60, 22, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T113[65489];
static const ANTLR3_INT32 dfa34_T113_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 4, 329, 1, 60, 21, -1,
	4, 60, 1, -1, 1, 60, 4, 329, 1, 60, 21, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T114[65486];
static const ANTLR3_INT32 dfa34_T114_compressed[59] = 
	{
	29, 129, 10, -1, 7, 129, 26, -1, 4, 129, 1, -1, 1, 129, 26, -1, 69, 129, 23, -1,
	1, 129, 31, -1, 1, 129, 520, -1, 112, 129, 14, -1, 1, 129, 7297, -1, 12, 129, 2, -1,
	98, 129, 288, -1, 2672, 129, 1008, -1, 17, 129, 43007, -1, 8448, 129, 1232, -1, 32, 129, 526 
	};

static ANTLR3_INT32 dfa34_T115[65489];
static const ANTLR3_INT32 dfa34_T115_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 18, 613, 1, 60, 7, -1,
	4, 60, 1, -1, 1, 60, 18, 613, 1, 60, 7, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T116[65489];
static const ANTLR3_INT32 dfa34_T116_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 19, 552, 1, 60, 6, -1,
	4, 60, 1, -1, 1, 60, 19, 552, 1, 60, 6, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T117[65489];
static const ANTLR3_INT32 dfa34_T117_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 2, 580, 1, 60, 23, -1,
	4, 60, 1, -1, 1, 60, 2, 580, 1, 60, 23, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T118[65489];
static const ANTLR3_INT32 dfa34_T118_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 7, 599, 1, 60, 18, -1,
	4, 60, 1, -1, 1, 60, 7, 599, 1, 60, 18, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T119[65489];
static const ANTLR3_INT32 dfa34_T119_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 11, 384, 1, 60, 14, -1,
	4, 60, 1, -1, 1, 60, 11, 384, 1, 60, 14, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T120[65489];
static const ANTLR3_INT32 dfa34_T120_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 4, 608, 1, 60, 21, -1,
	4, 60, 1, -1, 1, 60, 4, 608, 1, 60, 21, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T121[65489];
static const ANTLR3_INT32 dfa34_T121_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 4, 466, 1, 60, 21, -1,
	4, 60, 1, -1, 1, 60, 4, 466, 1, 60, 21, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T122[65489];
static const ANTLR3_INT32 dfa34_T122_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 23, 252, 1, 60, 2, -1,
	4, 60, 1, -1, 1, 60, 23, 252, 1, 60, 2, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T123[65489];
static const ANTLR3_INT32 dfa34_T123_compressed[87] = 
	{
	43, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 13, 121, 1, 60, 9, 122,
	1, 60, 2, -1, 4, 60, 1, -1, 1, 60, 13, 121, 1, 60, 9, 122, 1, 60, 2, -1,
	60, 60, 1, -1, 8, 60, 23, -1, 1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1,
	12, 60, 2, -1, 49, 60, 2, -1, 47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1,
	8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T124[65489];
static const ANTLR3_INT32 dfa34_T124_compressed[75] = 
	{
	37, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 497, 1, 60, 25, -1, 4, 60,
	1, -1, 1, 497, 1, 60, 25, -1, 60, 60, 1, -1, 8, 60, 23, -1, 1, 60, 31, -1,
	1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1, 47, 60, 288, -1,
	2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T125[65489];
static const ANTLR3_INT32 dfa34_T125_compressed[95] = 
	{
	47, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 5, 189, 1, 60, 5, 188,
	1, 60, 6, 187, 1, 60, 7, -1, 4, 60, 1, -1, 1, 60, 5, 189, 1, 60, 5, 188,
	1, 60, 6, 187, 1, 60, 7, -1, 60, 60, 1, -1, 8, 60, 23, -1, 1, 60, 31, -1,
	1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1, 47, 60, 288, -1,
	2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T126[65489];
static const ANTLR3_INT32 dfa34_T126_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 6, 210, 1, 60, 19, -1,
	4, 60, 1, -1, 1, 60, 6, 210, 1, 60, 19, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T127[65489];
static const ANTLR3_INT32 dfa34_T127_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 19, 617, 1, 60, 6, -1,
	4, 60, 1, -1, 1, 60, 19, 617, 1, 60, 6, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T128[65489];
static const ANTLR3_INT32 dfa34_T128_compressed[75] = 
	{
	37, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 614, 1, 60, 25, -1, 4, 60,
	1, -1, 1, 614, 1, 60, 25, -1, 60, 60, 1, -1, 8, 60, 23, -1, 1, 60, 31, -1,
	1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1, 47, 60, 288, -1,
	2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T129[65489];
static const ANTLR3_INT32 dfa34_T129_compressed[87] = 
	{
	43, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 3, 230, 1, 60, 4, 229,
	1, 60, 17, -1, 4, 60, 1, -1, 1, 60, 3, 230, 1, 60, 4, 229, 1, 60, 17, -1,
	60, 60, 1, -1, 8, 60, 23, -1, 1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1,
	12, 60, 2, -1, 49, 60, 2, -1, 47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1,
	8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T130[65489];
static const ANTLR3_INT32 dfa34_T130_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 2, 609, 1, 60, 23, -1,
	4, 60, 1, -1, 1, 60, 2, 609, 1, 60, 23, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T131[65489];
static const ANTLR3_INT32 dfa34_T131_compressed[107] = 
	{
	53, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 66, 1, 60, 3, 64, 1, 60,
	2, 69, 1, 68, 1, 60, 10, 65, 1, 67, 1, 60, 5, -1, 4, 60, 1, -1, 1, 66,
	1, 60, 3, 64, 1, 60, 2, 69, 1, 68, 1, 60, 10, 65, 1, 67, 1, 60, 5, -1,
	60, 60, 1, -1, 8, 60, 23, -1, 1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1,
	12, 60, 2, -1, 49, 60, 2, -1, 47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1,
	8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T132[65489];
static const ANTLR3_INT32 dfa34_T132_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 20, 172, 1, 60, 5, -1,
	4, 60, 1, -1, 1, 60, 20, 172, 1, 60, 5, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T133[65489];
static const ANTLR3_INT32 dfa34_T133_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 3, 369, 1, 60, 22, -1,
	4, 60, 1, -1, 1, 60, 3, 369, 1, 60, 22, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T134[65489];
static const ANTLR3_INT32 dfa34_T134_compressed[75] = 
	{
	37, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 298, 1, 60, 25, -1, 4, 60,
	1, -1, 1, 298, 1, 60, 25, -1, 60, 60, 1, -1, 8, 60, 23, -1, 1, 60, 31, -1,
	1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1, 47, 60, 288, -1,
	2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T135[65489];
static const ANTLR3_INT32 dfa34_T135_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 13, 250, 1, 60, 12, -1,
	4, 60, 1, -1, 1, 60, 13, 250, 1, 60, 12, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T136[65489];
static const ANTLR3_INT32 dfa34_T136_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 13, 272, 1, 60, 12, -1,
	4, 60, 1, -1, 1, 60, 13, 272, 1, 60, 12, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T137[65489];
static const ANTLR3_INT32 dfa34_T137_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 4, 574, 1, 60, 21, -1,
	4, 60, 1, -1, 1, 60, 4, 574, 1, 60, 21, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T138[65489];
static const ANTLR3_INT32 dfa34_T138_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 15, 542, 1, 60, 10, -1,
	4, 60, 1, -1, 1, 60, 15, 542, 1, 60, 10, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T139[65489];
static const ANTLR3_INT32 dfa34_T139_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 13, 600, 1, 60, 12, -1,
	4, 60, 1, -1, 1, 60, 13, 600, 1, 60, 12, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T140[65489];
static const ANTLR3_INT32 dfa34_T140_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 14, 581, 1, 60, 11, -1,
	4, 60, 1, -1, 1, 60, 14, 581, 1, 60, 11, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T141[65489];
static const ANTLR3_INT32 dfa34_T141_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 2, 553, 1, 60, 23, -1,
	4, 60, 1, -1, 1, 60, 2, 553, 1, 60, 23, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T142[65489];
static const ANTLR3_INT32 dfa34_T142_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 24, 477, 1, 60, 1, -1,
	4, 60, 1, -1, 1, 60, 24, 477, 1, 60, 1, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T143[65489];
static const ANTLR3_INT32 dfa34_T143_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 18, 519, 1, 60, 7, -1,
	4, 60, 1, -1, 1, 60, 18, 519, 1, 60, 7, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T144[65489];
static const ANTLR3_INT32 dfa34_T144_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 13, 430, 1, 60, 12, -1,
	4, 60, 1, -1, 1, 60, 13, 430, 1, 60, 12, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T145[65489];
static const ANTLR3_INT32 dfa34_T145_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 14, 338, 1, 60, 11, -1,
	4, 60, 1, -1, 1, 60, 14, 338, 1, 60, 11, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T146[54];
static const ANTLR3_INT32 dfa34_T146_compressed[11] = 
	{
	5, 365, 10, -1, 11, 262, 1, -1, 31, 262, 1 
	};

static ANTLR3_INT32 dfa34_T147[65489];
static const ANTLR3_INT32 dfa34_T147_compressed[75] = 
	{
	37, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 279, 1, 60, 25, -1, 4, 60,
	1, -1, 1, 279, 1, 60, 25, -1, 60, 60, 1, -1, 8, 60, 23, -1, 1, 60, 31, -1,
	1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1, 47, 60, 288, -1,
	2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T148[65503];
static const ANTLR3_INT32 dfa34_T148_compressed[27] = 
	{
	13, 148, 1, -1, 1, 148, 25, -1, 1, 148, 31, -1, 1, 148, 1, -1, 1, 148, 1, -1,
	1, 148, 26, -1, 3, 148, 65410 
	};

static ANTLR3_INT32 dfa34_T149[65489];
static const ANTLR3_INT32 dfa34_T149_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 17, 377, 1, 60, 8, -1,
	4, 60, 1, -1, 1, 60, 17, 377, 1, 60, 8, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T150[65489];
static const ANTLR3_INT32 dfa34_T150_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 7, 428, 1, 60, 18, -1,
	4, 60, 1, -1, 1, 60, 7, 428, 1, 60, 18, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T151[65489];
static const ANTLR3_INT32 dfa34_T151_compressed[75] = 
	{
	37, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 459, 1, 60, 25, -1, 4, 60,
	1, -1, 1, 459, 1, 60, 25, -1, 60, 60, 1, -1, 8, 60, 23, -1, 1, 60, 31, -1,
	1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1, 47, 60, 288, -1,
	2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T152[65489];
static const ANTLR3_INT32 dfa34_T152_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 15, 336, 1, 60, 10, -1,
	4, 60, 1, -1, 1, 60, 15, 336, 1, 60, 10, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T153[65489];
static const ANTLR3_INT32 dfa34_T153_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 11, 579, 1, 60, 14, -1,
	4, 60, 1, -1, 1, 60, 11, 579, 1, 60, 14, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T154[65489];
static const ANTLR3_INT32 dfa34_T154_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 8, 256, 1, 60, 17, -1,
	4, 60, 1, -1, 1, 60, 8, 256, 1, 60, 17, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T155[65489];
static const ANTLR3_INT32 dfa34_T155_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 13, 495, 1, 60, 12, -1,
	4, 60, 1, -1, 1, 60, 13, 495, 1, 60, 12, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T156[65489];
static const ANTLR3_INT32 dfa34_T156_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 18, 362, 1, 60, 7, -1,
	4, 60, 1, -1, 1, 60, 18, 362, 1, 60, 7, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T157[65489];
static const ANTLR3_INT32 dfa34_T157_compressed[75] = 
	{
	37, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 551, 1, 60, 25, -1, 4, 60,
	1, -1, 1, 551, 1, 60, 25, -1, 60, 60, 1, -1, 8, 60, 23, -1, 1, 60, 31, -1,
	1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1, 47, 60, 288, -1,
	2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T158[65489];
static const ANTLR3_INT32 dfa34_T158_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 19, 450, 1, 60, 6, -1,
	4, 60, 1, -1, 1, 60, 19, 450, 1, 60, 6, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T159[65489];
static const ANTLR3_INT32 dfa34_T159_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 14, 566, 1, 60, 11, -1,
	4, 60, 1, -1, 1, 60, 14, 566, 1, 60, 11, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T160[65489];
static const ANTLR3_INT32 dfa34_T160_compressed[99] = 
	{
	49, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 8, 113, 1, 60, 5, 112,
	1, 60, 2, 111, 1, 60, 7, 114, 1, -1, 4, 60, 1, -1, 1, 60, 8, 113, 1, 60,
	5, 112, 1, 60, 2, 111, 1, 60, 7, 114, 1, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T161[65489];
static const ANTLR3_INT32 dfa34_T161_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 19, 525, 1, 60, 6, -1,
	4, 60, 1, -1, 1, 60, 19, 525, 1, 60, 6, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T162[65489];
static const ANTLR3_INT32 dfa34_T162_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 17, 488, 1, 60, 8, -1,
	4, 60, 1, -1, 1, 60, 17, 488, 1, 60, 8, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T163[65489];
static const ANTLR3_INT32 dfa34_T163_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 17, 589, 1, 60, 8, -1,
	4, 60, 1, -1, 1, 60, 17, 589, 1, 60, 8, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T164[65489];
static const ANTLR3_INT32 dfa34_T164_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 4, 414, 1, 60, 21, -1,
	4, 60, 1, -1, 1, 60, 4, 414, 1, 60, 21, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T165[65489];
static const ANTLR3_INT32 dfa34_T165_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 19, 321, 1, 60, 6, -1,
	4, 60, 1, -1, 1, 60, 19, 321, 1, 60, 6, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T166[65489];
static const ANTLR3_INT32 dfa34_T166_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 11, 212, 1, 60, 14, -1,
	4, 60, 1, -1, 1, 60, 11, 212, 1, 60, 14, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T167[65489];
static const ANTLR3_INT32 dfa34_T167_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 23, 401, 1, 60, 2, -1,
	4, 60, 1, -1, 1, 60, 23, 401, 1, 60, 2, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T168[65489];
static const ANTLR3_INT32 dfa34_T168_compressed[111] = 
	{
	55, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 1, 84, 1, 60, 1, 82,
	1, 60, 7, 83, 1, 60, 6, 81, 1, 60, 2, 85, 1, 60, 4, -1, 4, 60, 1, -1,
	1, 60, 1, 84, 1, 60, 1, 82, 1, 60, 7, 83, 1, 60, 6, 81, 1, 60, 2, 85,
	1, 60, 4, -1, 60, 60, 1, -1, 8, 60, 23, -1, 1, 60, 31, -1, 1, 60, 646, -1,
	1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1, 47, 60, 288, -1, 2672, 60, 1008, -1,
	17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T169[65489];
static const ANTLR3_INT32 dfa34_T169_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 18, 287, 1, 60, 7, -1,
	4, 60, 1, -1, 1, 60, 18, 287, 1, 60, 7, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T170[65489];
static const ANTLR3_INT32 dfa34_T170_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 19, 385, 1, 60, 6, -1,
	4, 60, 1, -1, 1, 60, 19, 385, 1, 60, 6, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T171[65489];
static const ANTLR3_INT32 dfa34_T171_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 17, 467, 1, 60, 8, -1,
	4, 60, 1, -1, 1, 60, 17, 467, 1, 60, 8, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T172[65489];
static const ANTLR3_INT32 dfa34_T172_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 17, 555, 1, 60, 8, -1,
	4, 60, 1, -1, 1, 60, 17, 555, 1, 60, 8, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T173[10];
static const ANTLR3_INT32 dfa34_T173_compressed[3] = 
	{
	1, 263, 10 
	};

static ANTLR3_INT32 dfa34_T174[65489];
static const ANTLR3_INT32 dfa34_T174_compressed[75] = 
	{
	37, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 583, 1, 60, 25, -1, 4, 60,
	1, -1, 1, 583, 1, 60, 25, -1, 60, 60, 1, -1, 8, 60, 23, -1, 1, 60, 31, -1,
	1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1, 47, 60, 288, -1,
	2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T175[65489];
static const ANTLR3_INT32 dfa34_T175_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 11, 601, 1, 60, 14, -1,
	4, 60, 1, -1, 1, 60, 11, 601, 1, 60, 14, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T176[65489];
static const ANTLR3_INT32 dfa34_T176_compressed[87] = 
	{
	43, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 2, 205, 1, 60, 7, 204,
	1, 60, 15, -1, 4, 60, 1, -1, 1, 60, 2, 205, 1, 60, 7, 204, 1, 60, 15, -1,
	60, 60, 1, -1, 8, 60, 23, -1, 1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1,
	12, 60, 2, -1, 49, 60, 2, -1, 47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1,
	8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T177[65489];
static const ANTLR3_INT32 dfa34_T177_compressed[99] = 
	{
	49, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 99, 1, 60, 1, 101, 1, 60,
	5, 98, 1, 60, 5, 100, 1, 60, 11, -1, 4, 60, 1, -1, 1, 99, 1, 60, 1, 101,
	1, 60, 5, 98, 1, 60, 5, 100, 1, 60, 11, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T178[65489];
static const ANTLR3_INT32 dfa34_T178_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 4, 302, 1, 60, 21, -1,
	4, 60, 1, -1, 1, 60, 4, 302, 1, 60, 21, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T179[65489];
static const ANTLR3_INT32 dfa34_T179_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 18, 322, 1, 60, 7, -1,
	4, 60, 1, -1, 1, 60, 18, 322, 1, 60, 7, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T180[65489];
static const ANTLR3_INT32 dfa34_T180_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 11, 213, 1, 60, 14, -1,
	4, 60, 1, -1, 1, 60, 11, 213, 1, 60, 14, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T181[65489];
static const ANTLR3_INT32 dfa34_T181_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 4, 415, 1, 60, 21, -1,
	4, 60, 1, -1, 1, 60, 4, 415, 1, 60, 21, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T182[65489];
static const ANTLR3_INT32 dfa34_T182_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 3, 334, 1, 60, 22, -1,
	4, 60, 1, -1, 1, 60, 3, 334, 1, 60, 22, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T183[65489];
static const ANTLR3_INT32 dfa34_T183_compressed[75] = 
	{
	37, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 225, 1, 60, 25, -1, 4, 60,
	1, -1, 1, 225, 1, 60, 25, -1, 60, 60, 1, -1, 8, 60, 23, -1, 1, 60, 31, -1,
	1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1, 47, 60, 288, -1,
	2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T184[65489];
static const ANTLR3_INT32 dfa34_T184_compressed[83] = 
	{
	41, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 379, 1, 60, 3, 378, 1, 60,
	21, -1, 4, 60, 1, -1, 1, 379, 1, 60, 3, 378, 1, 60, 21, -1, 60, 60, 1, -1,
	8, 60, 23, -1, 1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1,
	49, 60, 2, -1, 47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1,
	32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T185[10];
static const ANTLR3_INT32 dfa34_T185_compressed[3] = 
	{
	1, 267, 10 
	};

static ANTLR3_INT32 dfa34_T186[65489];
static const ANTLR3_INT32 dfa34_T186_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 20, 244, 1, 60, 5, -1,
	4, 60, 1, -1, 1, 60, 20, 244, 1, 60, 5, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T187[65489];
static const ANTLR3_INT32 dfa34_T187_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 4, 351, 1, 60, 21, -1,
	4, 60, 1, -1, 1, 60, 4, 351, 1, 60, 21, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T188[65489];
static const ANTLR3_INT32 dfa34_T188_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 8, 434, 1, 60, 17, -1,
	4, 60, 1, -1, 1, 60, 8, 434, 1, 60, 17, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T189[65489];
static const ANTLR3_INT32 dfa34_T189_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 17, 343, 1, 60, 8, -1,
	4, 60, 1, -1, 1, 60, 17, 343, 1, 60, 8, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T190[65489];
static const ANTLR3_INT32 dfa34_T190_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 17, 344, 1, 60, 8, -1,
	4, 60, 1, -1, 1, 60, 17, 344, 1, 60, 8, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T191[65489];
static const ANTLR3_INT32 dfa34_T191_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 4, 465, 1, 60, 21, -1,
	4, 60, 1, -1, 1, 60, 4, 465, 1, 60, 21, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T192[65489];
static const ANTLR3_INT32 dfa34_T192_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 17, 530, 1, 60, 8, -1,
	4, 60, 1, -1, 1, 60, 17, 530, 1, 60, 8, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T193[65489];
static const ANTLR3_INT32 dfa34_T193_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 19, 383, 1, 60, 6, -1,
	4, 60, 1, -1, 1, 60, 19, 383, 1, 60, 6, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T194[65489];
static const ANTLR3_INT32 dfa34_T194_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 12, 570, 1, 60, 13, -1,
	4, 60, 1, -1, 1, 60, 12, 570, 1, 60, 13, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T195[65486];
static const ANTLR3_INT32 dfa34_T195_compressed[59] = 
	{
	29, 125, 10, -1, 7, 125, 26, -1, 4, 125, 1, -1, 1, 125, 26, -1, 69, 125, 23, -1,
	1, 125, 31, -1, 1, 125, 520, -1, 112, 125, 14, -1, 1, 125, 7297, -1, 12, 125, 2, -1,
	98, 125, 288, -1, 2672, 125, 1008, -1, 17, 125, 43007, -1, 8448, 125, 1232, -1, 32, 125, 526 
	};

static ANTLR3_INT32 dfa34_T196[65489];
static const ANTLR3_INT32 dfa34_T196_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 10, 554, 1, 60, 15, -1,
	4, 60, 1, -1, 1, 60, 10, 554, 1, 60, 15, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T197[65489];
static const ANTLR3_INT32 dfa34_T197_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 15, 429, 1, 60, 10, -1,
	4, 60, 1, -1, 1, 60, 15, 429, 1, 60, 10, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T198[65489];
static const ANTLR3_INT32 dfa34_T198_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 4, 509, 1, 60, 21, -1,
	4, 60, 1, -1, 1, 60, 4, 509, 1, 60, 21, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T199[65489];
static const ANTLR3_INT32 dfa34_T199_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 19, 437, 1, 60, 6, -1,
	4, 60, 1, -1, 1, 60, 19, 437, 1, 60, 6, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T200[65489];
static const ANTLR3_INT32 dfa34_T200_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 20, 337, 1, 60, 5, -1,
	4, 60, 1, -1, 1, 60, 20, 337, 1, 60, 5, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T201[65489];
static const ANTLR3_INT32 dfa34_T201_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 8, 346, 1, 60, 17, -1,
	4, 60, 1, -1, 1, 60, 8, 346, 1, 60, 17, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T202[65489];
static const ANTLR3_INT32 dfa34_T202_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 8, 435, 1, 60, 17, -1,
	4, 60, 1, -1, 1, 60, 8, 435, 1, 60, 17, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T203[65489];
static const ANTLR3_INT32 dfa34_T203_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 13, 508, 1, 60, 12, -1,
	4, 60, 1, -1, 1, 60, 13, 508, 1, 60, 12, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T204[65489];
static const ANTLR3_INT32 dfa34_T204_compressed[75] = 
	{
	37, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 436, 1, 60, 25, -1, 4, 60,
	1, -1, 1, 436, 1, 60, 25, -1, 60, 60, 1, -1, 8, 60, 23, -1, 1, 60, 31, -1,
	1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1, 47, 60, 288, -1,
	2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T205[65489];
static const ANTLR3_INT32 dfa34_T205_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 11, 345, 1, 60, 14, -1,
	4, 60, 1, -1, 1, 60, 11, 345, 1, 60, 14, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T206[65489];
static const ANTLR3_INT32 dfa34_T206_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 4, 353, 1, 60, 21, -1,
	4, 60, 1, -1, 1, 60, 4, 353, 1, 60, 21, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T207[65489];
static const ANTLR3_INT32 dfa34_T207_compressed[71] = 
	{
	35, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 26, -1, 4, 500, 1, -1,
	1, 60, 26, -1, 60, 60, 1, -1, 8, 60, 23, -1, 1, 60, 31, -1, 1, 60, 646, -1,
	1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1, 47, 60, 288, -1, 2672, 60, 1008, -1,
	17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T208[65489];
static const ANTLR3_INT32 dfa34_T208_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 24, 308, 1, 60, 1, -1,
	4, 60, 1, -1, 1, 60, 24, 308, 1, 60, 1, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T209[65489];
static const ANTLR3_INT32 dfa34_T209_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 4, 202, 1, 60, 21, -1,
	4, 60, 1, -1, 1, 60, 4, 202, 1, 60, 21, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T210[65489];
static const ANTLR3_INT32 dfa34_T210_compressed[75] = 
	{
	37, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 312, 1, 60, 25, -1, 4, 60,
	1, -1, 1, 312, 1, 60, 25, -1, 60, 60, 1, -1, 8, 60, 23, -1, 1, 60, 31, -1,
	1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1, 47, 60, 288, -1,
	2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T211[65489];
static const ANTLR3_INT32 dfa34_T211_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 19, 411, 1, 60, 6, -1,
	4, 60, 1, -1, 1, 60, 19, 411, 1, 60, 6, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T212[65489];
static const ANTLR3_INT32 dfa34_T212_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 4, 487, 1, 60, 21, -1,
	4, 60, 1, -1, 1, 60, 4, 487, 1, 60, 21, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T213[65489];
static const ANTLR3_INT32 dfa34_T213_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 4, 201, 1, 60, 21, -1,
	4, 60, 1, -1, 1, 60, 4, 201, 1, 60, 21, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T214[65489];
static const ANTLR3_INT32 dfa34_T214_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 17, 410, 1, 60, 8, -1,
	4, 60, 1, -1, 1, 60, 17, 410, 1, 60, 8, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T215[65489];
static const ANTLR3_INT32 dfa34_T215_compressed[75] = 
	{
	37, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 311, 1, 60, 25, -1, 4, 60,
	1, -1, 1, 311, 1, 60, 25, -1, 60, 60, 1, -1, 8, 60, 23, -1, 1, 60, 31, -1,
	1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1, 47, 60, 288, -1,
	2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T216[65489];
static const ANTLR3_INT32 dfa34_T216_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 17, 102, 1, 60, 8, -1,
	4, 60, 1, -1, 1, 60, 17, 102, 1, 60, 8, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T217[65489];
static const ANTLR3_INT32 dfa34_T217_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 14, 192, 1, 60, 11, -1,
	4, 60, 1, -1, 1, 60, 14, 192, 1, 60, 11, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T218[65489];
static const ANTLR3_INT32 dfa34_T218_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 15, 300, 1, 60, 10, -1,
	4, 60, 1, -1, 1, 60, 15, 300, 1, 60, 10, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T219[65489];
static const ANTLR3_INT32 dfa34_T219_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 3, 207, 1, 60, 22, -1,
	4, 60, 1, -1, 1, 60, 3, 207, 1, 60, 22, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T220[65489];
static const ANTLR3_INT32 dfa34_T220_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 13, 340, 1, 60, 12, -1,
	4, 60, 1, -1, 1, 60, 13, 340, 1, 60, 12, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T221[65489];
static const ANTLR3_INT32 dfa34_T221_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 6, 432, 1, 60, 19, -1,
	4, 60, 1, -1, 1, 60, 6, 432, 1, 60, 19, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T222[65489];
static const ANTLR3_INT32 dfa34_T222_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 8, 231, 1, 60, 17, -1,
	4, 60, 1, -1, 1, 60, 8, 231, 1, 60, 17, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T223[65489];
static const ANTLR3_INT32 dfa34_T223_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 11, 184, 1, 60, 14, -1,
	4, 60, 1, -1, 1, 60, 11, 184, 1, 60, 14, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T224[65489];
static const ANTLR3_INT32 dfa34_T224_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 19, 468, 1, 60, 6, -1,
	4, 60, 1, -1, 1, 60, 19, 468, 1, 60, 6, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T225[65489];
static const ANTLR3_INT32 dfa34_T225_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 4, 289, 1, 60, 21, -1,
	4, 60, 1, -1, 1, 60, 4, 289, 1, 60, 21, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T226[65489];
static const ANTLR3_INT32 dfa34_T226_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 13, 386, 1, 60, 12, -1,
	4, 60, 1, -1, 1, 60, 13, 386, 1, 60, 12, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T227[65489];
static const ANTLR3_INT32 dfa34_T227_compressed[75] = 
	{
	37, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 297, 1, 60, 25, -1, 4, 60,
	1, -1, 1, 297, 1, 60, 25, -1, 60, 60, 1, -1, 8, 60, 23, -1, 1, 60, 31, -1,
	1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1, 47, 60, 288, -1,
	2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T228[10];
static const ANTLR3_INT32 dfa34_T228_compressed[3] = 
	{
	1, 136, 10 
	};

static ANTLR3_INT32 dfa34_T229[65489];
static const ANTLR3_INT32 dfa34_T229_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 17, 393, 1, 60, 8, -1,
	4, 60, 1, -1, 1, 60, 17, 393, 1, 60, 8, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T230[65489];
static const ANTLR3_INT32 dfa34_T230_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 4, 475, 1, 60, 21, -1,
	4, 60, 1, -1, 1, 60, 4, 475, 1, 60, 21, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T231[65489];
static const ANTLR3_INT32 dfa34_T231_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 19, 395, 1, 60, 6, -1,
	4, 60, 1, -1, 1, 60, 19, 395, 1, 60, 6, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T232[65489];
static const ANTLR3_INT32 dfa34_T232_compressed[87] = 
	{
	43, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 19, 217, 1, 60, 2, 216,
	1, 60, 3, -1, 4, 60, 1, -1, 1, 60, 19, 217, 1, 60, 2, 216, 1, 60, 3, -1,
	60, 60, 1, -1, 8, 60, 23, -1, 1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1,
	12, 60, 2, -1, 49, 60, 2, -1, 47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1,
	8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T233[65489];
static const ANTLR3_INT32 dfa34_T233_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 4, 296, 1, 60, 21, -1,
	4, 60, 1, -1, 1, 60, 4, 296, 1, 60, 21, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T234[65489];
static const ANTLR3_INT32 dfa34_T234_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 4, 348, 1, 60, 21, -1,
	4, 60, 1, -1, 1, 60, 4, 348, 1, 60, 21, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T235[65489];
static const ANTLR3_INT32 dfa34_T235_compressed[103] = 
	{
	51, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 4, 80, 1, 60, 6, 78,
	1, 60, 2, 77, 1, 60, 2, 79, 1, 60, 8, -1, 4, 60, 1, -1, 1, 60, 4, 80,
	1, 60, 6, 78, 1, 60, 2, 77, 1, 60, 2, 79, 1, 60, 8, -1, 60, 60, 1, -1,
	8, 60, 23, -1, 1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1,
	49, 60, 2, -1, 47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1,
	32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T236[65489];
static const ANTLR3_INT32 dfa34_T236_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 19, 511, 1, 60, 6, -1,
	4, 60, 1, -1, 1, 60, 19, 511, 1, 60, 6, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T237[65489];
static const ANTLR3_INT32 dfa34_T237_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 19, 397, 1, 60, 6, -1,
	4, 60, 1, -1, 1, 60, 19, 397, 1, 60, 6, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T238[65489];
static const ANTLR3_INT32 dfa34_T238_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 17, 439, 1, 60, 8, -1,
	4, 60, 1, -1, 1, 60, 17, 439, 1, 60, 8, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T239[65489];
static const ANTLR3_INT32 dfa34_T239_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 14, 349, 1, 60, 11, -1,
	4, 60, 1, -1, 1, 60, 14, 349, 1, 60, 11, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T240[65489];
static const ANTLR3_INT32 dfa34_T240_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 2, 388, 1, 60, 2, 389, 1, 60, 4, 62, 1, -1,
	6, 60, 26, -1, 4, 60, 1, -1, 1, 60, 26, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T241[65489];
static const ANTLR3_INT32 dfa34_T241_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 7, 328, 1, 60, 18, -1,
	4, 60, 1, -1, 1, 60, 7, 328, 1, 60, 18, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T242[65489];
static const ANTLR3_INT32 dfa34_T242_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 20, 355, 1, 60, 5, -1,
	4, 60, 1, -1, 1, 60, 20, 355, 1, 60, 5, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T243[1];
static const ANTLR3_INT32 dfa34_T243_compressed[3] = 
	{
	1, 156, 1 
	};

static ANTLR3_INT32 dfa34_T244[65489];
static const ANTLR3_INT32 dfa34_T244_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 11, 208, 1, 60, 14, -1,
	4, 60, 1, -1, 1, 60, 11, 208, 1, 60, 14, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T245[65489];
static const ANTLR3_INT32 dfa34_T245_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 11, 476, 1, 60, 14, -1,
	4, 60, 1, -1, 1, 60, 11, 476, 1, 60, 14, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T246[65489];
static const ANTLR3_INT32 dfa34_T246_compressed[91] = 
	{
	45, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 2, 306, 1, 60, 15, 305,
	1, 307, 1, 60, 6, -1, 4, 60, 1, -1, 1, 60, 2, 306, 1, 60, 15, 305, 1, 307,
	1, 60, 6, -1, 60, 60, 1, -1, 8, 60, 23, -1, 1, 60, 31, -1, 1, 60, 646, -1,
	1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1, 47, 60, 288, -1, 2672, 60, 1008, -1,
	17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T247[65489];
static const ANTLR3_INT32 dfa34_T247_compressed[99] = 
	{
	49, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 199, 1, 60, 12, 197, 1, 60,
	1, 198, 1, 60, 4, 200, 1, 60, 5, -1, 4, 60, 1, -1, 1, 199, 1, 60, 12, 197,
	1, 60, 1, 198, 1, 60, 4, 200, 1, 60, 5, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T248[65489];
static const ANTLR3_INT32 dfa34_T248_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 20, 396, 1, 60, 5, -1,
	4, 60, 1, -1, 1, 60, 20, 396, 1, 60, 5, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T249[65489];
static const ANTLR3_INT32 dfa34_T249_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 19, 541, 1, 60, 6, -1,
	4, 60, 1, -1, 1, 60, 19, 541, 1, 60, 6, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T250[65489];
static const ANTLR3_INT32 dfa34_T250_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 2, 295, 1, 60, 23, -1,
	4, 60, 1, -1, 1, 60, 2, 295, 1, 60, 23, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T251[65489];
static const ANTLR3_INT32 dfa34_T251_compressed[99] = 
	{
	49, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 3, 283, 1, 282, 1, 60,
	6, 280, 1, 60, 6, 281, 1, 60, 7, -1, 4, 60, 1, -1, 1, 60, 3, 283, 1, 282,
	1, 60, 6, 280, 1, 60, 6, 281, 1, 60, 7, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T252[65489];
static const ANTLR3_INT32 dfa34_T252_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 19, 219, 1, 60, 6, -1,
	4, 60, 1, -1, 1, 60, 19, 219, 1, 60, 6, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T253[65489];
static const ANTLR3_INT32 dfa34_T253_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 6, 520, 1, 60, 19, -1,
	4, 60, 1, -1, 1, 60, 6, 520, 1, 60, 19, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T254[65489];
static const ANTLR3_INT32 dfa34_T254_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 18, 563, 1, 60, 7, -1,
	4, 60, 1, -1, 1, 60, 18, 563, 1, 60, 7, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T255[65489];
static const ANTLR3_INT32 dfa34_T255_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 13, 453, 1, 60, 12, -1,
	4, 60, 1, -1, 1, 60, 13, 453, 1, 60, 12, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T256[65489];
static const ANTLR3_INT32 dfa34_T256_compressed[87] = 
	{
	43, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 19, 190, 1, 60, 4, 191,
	1, 60, 1, -1, 4, 60, 1, -1, 1, 60, 19, 190, 1, 60, 4, 191, 1, 60, 1, -1,
	60, 60, 1, -1, 8, 60, 23, -1, 1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1,
	12, 60, 2, -1, 49, 60, 2, -1, 47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1,
	8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T257[65489];
static const ANTLR3_INT32 dfa34_T257_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 2, 457, 1, 60, 23, -1,
	4, 60, 1, -1, 1, 60, 2, 457, 1, 60, 23, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T258[65489];
static const ANTLR3_INT32 dfa34_T258_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 4, 523, 1, 60, 21, -1,
	4, 60, 1, -1, 1, 60, 4, 523, 1, 60, 21, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T259[65489];
static const ANTLR3_INT32 dfa34_T259_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 21, 277, 1, 60, 4, -1,
	4, 60, 1, -1, 1, 60, 21, 277, 1, 60, 4, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T260[65489];
static const ANTLR3_INT32 dfa34_T260_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 8, 375, 1, 60, 17, -1,
	4, 60, 1, -1, 1, 60, 8, 375, 1, 60, 17, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T261[56];
static const ANTLR3_INT32 dfa34_T261_compressed[15] = 
	{
	7, 265, 1, -1, 1, 141, 10, -1, 11, 266, 1, -1, 31, 266, 1 
	};

static ANTLR3_INT32 dfa34_T262[65489];
static const ANTLR3_INT32 dfa34_T262_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 13, 447, 1, 60, 12, -1,
	4, 60, 1, -1, 1, 60, 13, 447, 1, 60, 12, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T263[65489];
static const ANTLR3_INT32 dfa34_T263_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 8, 359, 1, 60, 17, -1,
	4, 60, 1, -1, 1, 60, 8, 359, 1, 60, 17, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T264[65489];
static const ANTLR3_INT32 dfa34_T264_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 21, 253, 1, 60, 4, -1,
	4, 60, 1, -1, 1, 60, 21, 253, 1, 60, 4, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T265[65489];
static const ANTLR3_INT32 dfa34_T265_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 5, 431, 1, 60, 20, -1,
	4, 60, 1, -1, 1, 60, 5, 431, 1, 60, 20, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T266[65489];
static const ANTLR3_INT32 dfa34_T266_compressed[99] = 
	{
	49, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 89, 1, 60, 7, 88, 1, 60,
	2, 90, 1, 60, 5, 87, 1, 60, 8, -1, 4, 60, 1, -1, 1, 89, 1, 60, 7, 88,
	1, 60, 2, 90, 1, 60, 5, 87, 1, 60, 8, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T267[65489];
static const ANTLR3_INT32 dfa34_T267_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 4, 339, 1, 60, 21, -1,
	4, 60, 1, -1, 1, 60, 4, 339, 1, 60, 21, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T268[65489];
static const ANTLR3_INT32 dfa34_T268_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 6, 516, 1, 60, 19, -1,
	4, 60, 1, -1, 1, 60, 6, 516, 1, 60, 19, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T269[65489];
static const ANTLR3_INT32 dfa34_T269_compressed[99] = 
	{
	49, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 5, 110, 1, 60, 7, 108,
	1, 60, 3, 109, 1, 107, 1, 60, 7, -1, 4, 60, 1, -1, 1, 60, 5, 110, 1, 60,
	7, 108, 1, 60, 3, 109, 1, 107, 1, 60, 7, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T270[65489];
static const ANTLR3_INT32 dfa34_T270_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 4, 372, 1, 60, 21, -1,
	4, 60, 1, -1, 1, 60, 4, 372, 1, 60, 21, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T271[65489];
static const ANTLR3_INT32 dfa34_T271_compressed[83] = 
	{
	41, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 119, 1, 60, 13, 120, 1, 60,
	11, -1, 4, 60, 1, -1, 1, 119, 1, 60, 13, 120, 1, 60, 11, -1, 60, 60, 1, -1,
	8, 60, 23, -1, 1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1,
	49, 60, 2, -1, 47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1,
	32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T272[65536];
static const ANTLR3_INT32 dfa34_T272_compressed[223] = 
	{
	111, 53, 9, 1, 2, 53, 2, 1, 1, 53, 18, 1, 1, 39, 1, 34, 1, 36, 1, 27,
	1, 53, 1, 40, 1, 33, 1, 42, 1, 43, 1, 49, 1, 31, 1, 50, 1, 32, 1, 30,
	1, 51, 1, 29, 10, 24, 1, 48, 1, 35, 1, 52, 1, 38, 1, 26, 1, 28, 1, 16,
	1, 2, 1, 7, 1, 5, 1, 21, 1, 9, 1, 14, 1, 20, 1, 17, 1, 23, 2, 13,
	1, 19, 1, 10, 1, 12, 1, 3, 1, 23, 1, 6, 1, 4, 1, 18, 1, 15, 1, 23,
	1, 11, 1, 23, 1, 22, 1, 23, 1, 46, 1, 53, 1, 47, 1, 37, 1, 25, 1, 53,
	1, 8, 1, 2, 1, 7, 1, 5, 1, 21, 1, 9, 1, 14, 1, 20, 1, 17, 1, 23,
	2, 13, 1, 19, 1, 10, 1, 12, 1, 3, 1, 23, 1, 6, 1, 4, 1, 18, 1, 15,
	1, 23, 1, 11, 1, 23, 1, 22, 1, 23, 1, 44, 1, 41, 1, 45, 1, 53, 66, 23,
	23, 53, 1, 23, 31, 53, 1, 23, 520, 53, 112, 23, 14, 53, 1, 23, 7297, 53, 12, 23,
	2, 53, 98, 23, 288, 53, 2672, 23, 1008, 53, 17, 23, 43007, 53, 8448, 23, 1232, 53, 32, 23,
	526, 53, 2 
	};

static ANTLR3_INT32 dfa34_T273[65489];
static const ANTLR3_INT32 dfa34_T273_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 3, 303, 1, 60, 22, -1,
	4, 60, 1, -1, 1, 60, 3, 303, 1, 60, 22, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T274[65489];
static const ANTLR3_INT32 dfa34_T274_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 13, 195, 1, 60, 12, -1,
	4, 60, 1, -1, 1, 60, 13, 195, 1, 60, 12, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T275[65489];
static const ANTLR3_INT32 dfa34_T275_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 8, 232, 1, 60, 17, -1,
	4, 60, 1, -1, 1, 60, 8, 232, 1, 60, 17, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T276[65489];
static const ANTLR3_INT32 dfa34_T276_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 3, 274, 1, 60, 22, -1,
	4, 60, 1, -1, 1, 60, 3, 274, 1, 60, 22, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T277[65489];
static const ANTLR3_INT32 dfa34_T277_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 14, 174, 1, 60, 11, -1,
	4, 60, 1, -1, 1, 60, 14, 174, 1, 60, 11, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T278[65489];
static const ANTLR3_INT32 dfa34_T278_compressed[91] = 
	{
	45, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 75, 1, 60, 3, 74, 1, 60,
	9, 76, 1, 60, 11, -1, 4, 60, 1, -1, 1, 75, 1, 60, 3, 74, 1, 60, 9, 76,
	1, 60, 11, -1, 60, 60, 1, -1, 8, 60, 23, -1, 1, 60, 31, -1, 1, 60, 646, -1,
	1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1, 47, 60, 288, -1, 2672, 60, 1008, -1,
	17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T279[65489];
static const ANTLR3_INT32 dfa34_T279_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 8, 242, 1, 60, 17, -1,
	4, 60, 1, -1, 1, 60, 8, 242, 1, 60, 17, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T280[65489];
static const ANTLR3_INT32 dfa34_T280_compressed[87] = 
	{
	43, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 4, 285, 1, 60, 10, 286,
	1, 60, 10, -1, 4, 60, 1, -1, 1, 60, 4, 285, 1, 60, 10, 286, 1, 60, 10, -1,
	60, 60, 1, -1, 8, 60, 23, -1, 1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1,
	12, 60, 2, -1, 49, 60, 2, -1, 47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1,
	8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T281[65489];
static const ANTLR3_INT32 dfa34_T281_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 4, 123, 1, 60, 21, -1,
	4, 60, 1, -1, 1, 60, 4, 123, 1, 60, 21, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T282[65489];
static const ANTLR3_INT32 dfa34_T282_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 12, 181, 1, 60, 13, -1,
	4, 60, 1, -1, 1, 60, 12, 181, 1, 60, 13, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T283[56];
static const ANTLR3_INT32 dfa34_T283_compressed[15] = 
	{
	7, 261, 1, -1, 1, 138, 10, -1, 11, 262, 1, -1, 31, 262, 1 
	};

static ANTLR3_INT32 dfa34_T284[65486];
static const ANTLR3_INT32 dfa34_T284_compressed[59] = 
	{
	29, 128, 10, -1, 7, 128, 26, -1, 4, 128, 1, -1, 1, 128, 26, -1, 69, 128, 23, -1,
	1, 128, 31, -1, 1, 128, 520, -1, 112, 128, 14, -1, 1, 128, 7297, -1, 12, 128, 2, -1,
	98, 128, 288, -1, 2672, 128, 1008, -1, 17, 128, 43007, -1, 8448, 128, 1232, -1, 32, 128, 526 
	};

static ANTLR3_INT32 dfa34_T285[65489];
static const ANTLR3_INT32 dfa34_T285_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 19, 482, 1, 60, 6, -1,
	4, 60, 1, -1, 1, 60, 19, 482, 1, 60, 6, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T286[65489];
static const ANTLR3_INT32 dfa34_T286_compressed[75] = 
	{
	37, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 405, 1, 60, 25, -1, 4, 60,
	1, -1, 1, 405, 1, 60, 25, -1, 60, 60, 1, -1, 8, 60, 23, -1, 1, 60, 31, -1,
	1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1, 47, 60, 288, -1,
	2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T287[65489];
static const ANTLR3_INT32 dfa34_T287_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 17, 180, 1, 60, 8, -1,
	4, 60, 1, -1, 1, 60, 17, 180, 1, 60, 8, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T288[65489];
static const ANTLR3_INT32 dfa34_T288_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 3, 403, 1, 60, 22, -1,
	4, 60, 1, -1, 1, 60, 3, 403, 1, 60, 22, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T289[65489];
static const ANTLR3_INT32 dfa34_T289_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 13, 304, 1, 60, 12, -1,
	4, 60, 1, -1, 1, 60, 13, 304, 1, 60, 12, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T290[65489];
static const ANTLR3_INT32 dfa34_T290_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 20, 196, 1, 60, 5, -1,
	4, 60, 1, -1, 1, 60, 20, 196, 1, 60, 5, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T291[1];
static const ANTLR3_INT32 dfa34_T291_compressed[3] = 
	{
	1, 268, 1 
	};

static ANTLR3_INT32 dfa34_T292[58];
static const ANTLR3_INT32 dfa34_T292_compressed[7] = 
	{
	3, 130, 26, -1, 6, 130, 26 
	};

static ANTLR3_INT32 dfa34_T293[65489];
static const ANTLR3_INT32 dfa34_T293_compressed[87] = 
	{
	43, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 3, 193, 1, 60, 2, 194,
	1, 60, 19, -1, 4, 60, 1, -1, 1, 60, 3, 193, 1, 60, 2, 194, 1, 60, 19, -1,
	60, 60, 1, -1, 8, 60, 23, -1, 1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1,
	12, 60, 2, -1, 49, 60, 2, -1, 47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1,
	8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T294[65489];
static const ANTLR3_INT32 dfa34_T294_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 14, 214, 1, 60, 11, -1,
	4, 60, 1, -1, 1, 60, 14, 214, 1, 60, 11, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T295[65489];
static const ANTLR3_INT32 dfa34_T295_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 14, 323, 1, 60, 11, -1,
	4, 60, 1, -1, 1, 60, 14, 323, 1, 60, 11, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T296[65489];
static const ANTLR3_INT32 dfa34_T296_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 17, 416, 1, 60, 8, -1,
	4, 60, 1, -1, 1, 60, 17, 416, 1, 60, 8, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T297[65489];
static const ANTLR3_INT32 dfa34_T297_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 18, 209, 1, 60, 7, -1,
	4, 60, 1, -1, 1, 60, 18, 209, 1, 60, 7, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T298[65489];
static const ANTLR3_INT32 dfa34_T298_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 11, 313, 1, 60, 14, -1,
	4, 60, 1, -1, 1, 60, 11, 313, 1, 60, 14, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T299[65489];
static const ANTLR3_INT32 dfa34_T299_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 8, 203, 1, 60, 17, -1,
	4, 60, 1, -1, 1, 60, 8, 203, 1, 60, 17, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T300[65489];
static const ANTLR3_INT32 dfa34_T300_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 20, 618, 1, 60, 5, -1,
	4, 60, 1, -1, 1, 60, 20, 618, 1, 60, 5, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T301[65489];
static const ANTLR3_INT32 dfa34_T301_compressed[71] = 
	{
	35, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 26, -1, 4, 615, 1, -1,
	1, 60, 26, -1, 60, 60, 1, -1, 8, 60, 23, -1, 1, 60, 31, -1, 1, 60, 646, -1,
	1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1, 47, 60, 288, -1, 2672, 60, 1008, -1,
	17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T302[12];
static const ANTLR3_INT32 dfa34_T302_compressed[7] = 
	{
	3, 139, 1, -1, 1, 138, 10 
	};

static ANTLR3_INT32 dfa34_T303[65489];
static const ANTLR3_INT32 dfa34_T303_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 8, 621, 1, 60, 17, -1,
	4, 60, 1, -1, 1, 60, 8, 621, 1, 60, 17, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T304[65489];
static const ANTLR3_INT32 dfa34_T304_compressed[87] = 
	{
	43, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 13, 249, 1, 60, 7, 248,
	1, 60, 4, -1, 4, 60, 1, -1, 1, 60, 13, 249, 1, 60, 7, 248, 1, 60, 4, -1,
	60, 60, 1, -1, 8, 60, 23, -1, 1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1,
	12, 60, 2, -1, 49, 60, 2, -1, 47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1,
	8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T305[65489];
static const ANTLR3_INT32 dfa34_T305_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 17, 620, 1, 60, 8, -1,
	4, 60, 1, -1, 1, 60, 17, 620, 1, 60, 8, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T306[65489];
static const ANTLR3_INT32 dfa34_T306_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 5, 587, 1, 60, 20, -1,
	4, 60, 1, -1, 1, 60, 5, 587, 1, 60, 20, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T307[1];
static const ANTLR3_INT32 dfa34_T307_compressed[3] = 
	{
	1, 269, 1 
	};

static ANTLR3_INT32 dfa34_T308[65489];
static const ANTLR3_INT32 dfa34_T308_compressed[71] = 
	{
	35, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 26, -1, 4, 561, 1, -1,
	1, 60, 26, -1, 60, 60, 1, -1, 8, 60, 23, -1, 1, 60, 31, -1, 1, 60, 646, -1,
	1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1, 47, 60, 288, -1, 2672, 60, 1008, -1,
	17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T309[65489];
static const ANTLR3_INT32 dfa34_T309_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 17, 612, 1, 60, 8, -1,
	4, 60, 1, -1, 1, 60, 17, 612, 1, 60, 8, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T310[65489];
static const ANTLR3_INT32 dfa34_T310_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 14, 604, 1, 60, 11, -1,
	4, 60, 1, -1, 1, 60, 14, 604, 1, 60, 11, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T311[65489];
static const ANTLR3_INT32 dfa34_T311_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 14, 361, 1, 60, 11, -1,
	4, 60, 1, -1, 1, 60, 14, 361, 1, 60, 11, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T312[65489];
static const ANTLR3_INT32 dfa34_T312_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 2, 255, 1, 60, 23, -1,
	4, 60, 1, -1, 1, 60, 2, 255, 1, 60, 23, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T313[65489];
static const ANTLR3_INT32 dfa34_T313_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 4, 518, 1, 60, 21, -1,
	4, 60, 1, -1, 1, 60, 4, 518, 1, 60, 21, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T314[65489];
static const ANTLR3_INT32 dfa34_T314_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 3, 449, 1, 60, 22, -1,
	4, 60, 1, -1, 1, 60, 3, 449, 1, 60, 22, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T315[65536];
static const ANTLR3_INT32 dfa34_T315_compressed[15] = 
	{
	7, 146, 10, -1, 1, 146, 2, -1, 1, 146, 20, 145, 1, 146, 65501 
	};

static ANTLR3_INT32 dfa34_T316[65489];
static const ANTLR3_INT32 dfa34_T316_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 4, 427, 1, 60, 21, -1,
	4, 60, 1, -1, 1, 60, 4, 427, 1, 60, 21, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T317[54];
static const ANTLR3_INT32 dfa34_T317_compressed[11] = 
	{
	5, 136, 10, -1, 11, 134, 1, -1, 31, 134, 1 
	};

static ANTLR3_INT32 dfa34_T318[65489];
static const ANTLR3_INT32 dfa34_T318_compressed[75] = 
	{
	37, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 226, 1, 60, 25, -1, 4, 60,
	1, -1, 1, 226, 1, 60, 25, -1, 60, 60, 1, -1, 8, 60, 23, -1, 1, 60, 31, -1,
	1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1, 47, 60, 288, -1,
	2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T319[65489];
static const ANTLR3_INT32 dfa34_T319_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 18, 335, 1, 60, 7, -1,
	4, 60, 1, -1, 1, 60, 18, 335, 1, 60, 7, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T320[65489];
static const ANTLR3_INT32 dfa34_T320_compressed[75] = 
	{
	37, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 233, 1, 60, 25, -1, 4, 60,
	1, -1, 1, 233, 1, 60, 25, -1, 60, 60, 1, -1, 8, 60, 23, -1, 1, 60, 31, -1,
	1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1, 47, 60, 288, -1,
	2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T321[65489];
static const ANTLR3_INT32 dfa34_T321_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 18, 342, 1, 60, 7, -1,
	4, 60, 1, -1, 1, 60, 18, 342, 1, 60, 7, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T322[65489];
static const ANTLR3_INT32 dfa34_T322_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 4, 433, 1, 60, 21, -1,
	4, 60, 1, -1, 1, 60, 4, 433, 1, 60, 21, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T323[1];
static const ANTLR3_INT32 dfa34_T323_compressed[3] = 
	{
	1, 150, 1 
	};

static ANTLR3_INT32 dfa34_T324[1];
static const ANTLR3_INT32 dfa34_T324_compressed[3] = 
	{
	1, 147, 1 
	};

static ANTLR3_INT32 dfa34_T325[65489];
static const ANTLR3_INT32 dfa34_T325_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 13, 460, 1, 60, 12, -1,
	4, 60, 1, -1, 1, 60, 13, 460, 1, 60, 12, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T326[65489];
static const ANTLR3_INT32 dfa34_T326_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 17, 63, 1, 60, 8, -1,
	4, 60, 1, -1, 1, 60, 17, 63, 1, 60, 8, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T327[65489];
static const ANTLR3_INT32 dfa34_T327_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 13, 173, 1, 60, 12, -1,
	4, 60, 1, -1, 1, 60, 13, 173, 1, 60, 12, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T328[65489];
static const ANTLR3_INT32 dfa34_T328_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 3, 273, 1, 60, 22, -1,
	4, 60, 1, -1, 1, 60, 3, 273, 1, 60, 22, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T329[65489];
static const ANTLR3_INT32 dfa34_T329_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 17, 363, 1, 60, 8, -1,
	4, 60, 1, -1, 1, 60, 17, 363, 1, 60, 8, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T330[65489];
static const ANTLR3_INT32 dfa34_T330_compressed[75] = 
	{
	37, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 257, 1, 60, 25, -1, 4, 60,
	1, -1, 1, 257, 1, 60, 25, -1, 60, 60, 1, -1, 8, 60, 23, -1, 1, 60, 31, -1,
	1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1, 47, 60, 288, -1,
	2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T331[65489];
static const ANTLR3_INT32 dfa34_T331_compressed[83] = 
	{
	41, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 227, 1, 60, 13, 228, 1, 60,
	11, -1, 4, 60, 1, -1, 1, 227, 1, 60, 13, 228, 1, 60, 11, -1, 60, 60, 1, -1,
	8, 60, 23, -1, 1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1,
	49, 60, 2, -1, 47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1,
	32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T332[65489];
static const ANTLR3_INT32 dfa34_T332_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 18, 529, 1, 60, 7, -1,
	4, 60, 1, -1, 1, 60, 18, 529, 1, 60, 7, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T333[65489];
static const ANTLR3_INT32 dfa34_T333_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 3, 463, 1, 60, 22, -1,
	4, 60, 1, -1, 1, 60, 3, 463, 1, 60, 22, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T334[65489];
static const ANTLR3_INT32 dfa34_T334_compressed[69] = 
	{
	34, 60, 1, 61, 1, -1, 1, 60, 10, -1, 7, 60, 26, -1, 4, 60, 1, -1, 1, 60,
	26, -1, 60, 60, 1, -1, 8, 60, 23, -1, 1, 60, 31, -1, 1, 60, 646, -1, 1, 60,
	7297, -1, 12, 60, 2, -1, 49, 60, 2, -1, 47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60,
	43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T335[65489];
static const ANTLR3_INT32 dfa34_T335_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 13, 381, 1, 60, 12, -1,
	4, 60, 1, -1, 1, 60, 13, 381, 1, 60, 12, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T336[65489];
static const ANTLR3_INT32 dfa34_T336_compressed[103] = 
	{
	51, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 2, 178, 1, 60, 8, 176,
	1, 60, 3, 179, 1, 60, 1, 177, 1, 60, 8, -1, 4, 60, 1, -1, 1, 60, 2, 178,
	1, 60, 8, 176, 1, 60, 3, 179, 1, 60, 1, 177, 1, 60, 8, -1, 60, 60, 1, -1,
	8, 60, 23, -1, 1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1,
	49, 60, 2, -1, 47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1,
	32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T337[65489];
static const ANTLR3_INT32 dfa34_T337_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 18, 590, 1, 60, 7, -1,
	4, 60, 1, -1, 1, 60, 18, 590, 1, 60, 7, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T338[65489];
static const ANTLR3_INT32 dfa34_T338_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 17, 528, 1, 60, 8, -1,
	4, 60, 1, -1, 1, 60, 17, 528, 1, 60, 8, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T339[65489];
static const ANTLR3_INT32 dfa34_T339_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 19, 568, 1, 60, 6, -1,
	4, 60, 1, -1, 1, 60, 19, 568, 1, 60, 6, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T340[65489];
static const ANTLR3_INT32 dfa34_T340_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 19, 380, 1, 60, 6, -1,
	4, 60, 1, -1, 1, 60, 19, 380, 1, 60, 6, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T341[65489];
static const ANTLR3_INT32 dfa34_T341_compressed[75] = 
	{
	37, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 462, 1, 60, 25, -1, 4, 60,
	1, -1, 1, 462, 1, 60, 25, -1, 60, 60, 1, -1, 8, 60, 23, -1, 1, 60, 31, -1,
	1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1, 47, 60, 288, -1,
	2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T342[65489];
static const ANTLR3_INT32 dfa34_T342_compressed[111] = 
	{
	55, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 1, 236, 1, 60, 6, 234,
	1, 60, 2, 237, 1, 60, 1, 238, 1, 60, 6, 235, 1, 60, 5, -1, 4, 60, 1, -1,
	1, 60, 1, 236, 1, 60, 6, 234, 1, 60, 2, 237, 1, 60, 1, 238, 1, 60, 6, 235,
	1, 60, 5, -1, 60, 60, 1, -1, 8, 60, 23, -1, 1, 60, 31, -1, 1, 60, 646, -1,
	1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1, 47, 60, 288, -1, 2672, 60, 1008, -1,
	17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T343[65489];
static const ANTLR3_INT32 dfa34_T343_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 18, 577, 1, 60, 7, -1,
	4, 60, 1, -1, 1, 60, 18, 577, 1, 60, 7, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T344[65489];
static const ANTLR3_INT32 dfa34_T344_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 6, 333, 1, 60, 19, -1,
	4, 60, 1, -1, 1, 60, 6, 333, 1, 60, 19, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T345[65489];
static const ANTLR3_INT32 dfa34_T345_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 8, 483, 1, 60, 17, -1,
	4, 60, 1, -1, 1, 60, 8, 483, 1, 60, 17, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T346[65489];
static const ANTLR3_INT32 dfa34_T346_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 13, 224, 1, 60, 12, -1,
	4, 60, 1, -1, 1, 60, 13, 224, 1, 60, 12, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T347[65489];
static const ANTLR3_INT32 dfa34_T347_compressed[79] = 
	{
	39, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 60, 13, 546, 1, 60, 12, -1,
	4, 60, 1, -1, 1, 60, 13, 546, 1, 60, 12, -1, 60, 60, 1, -1, 8, 60, 23, -1,
	1, 60, 31, -1, 1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1,
	47, 60, 288, -1, 2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};

static ANTLR3_INT32 dfa34_T348[54];
static const ANTLR3_INT32 dfa34_T348_compressed[11] = 
	{
	5, 263, 10, -1, 11, 262, 1, -1, 31, 262, 1 
	};

static ANTLR3_INT32 dfa34_T349[65489];
static const ANTLR3_INT32 dfa34_T349_compressed[75] = 
	{
	37, 60, 1, 61, 1, -1, 1, 60, 10, 62, 1, -1, 6, 406, 1, 60, 25, -1, 4, 60,
	1, -1, 1, 406, 1, 60, 25, -1, 60, 60, 1, -1, 8, 60, 23, -1, 1, 60, 31, -1,
	1, 60, 646, -1, 1, 60, 7297, -1, 12, 60, 2, -1, 49, 60, 2, -1, 47, 60, 288, -1,
	2672, 60, 1008, -1, 17, 60, 43007, -1, 8448, 60, 1232, -1, 32, 60, 526 
	};
	
static ANTLR3_INT32*	dfa34_Tables[700] = 
	{
	dfa34_T0, dfa34_T0_compressed, dfa34_T1, dfa34_T1_compressed, dfa34_T2, dfa34_T2_compressed, dfa34_T3, dfa34_T3_compressed, dfa34_T4, dfa34_T4_compressed, dfa34_T5, dfa34_T5_compressed, dfa34_T6, dfa34_T6_compressed, dfa34_T7, dfa34_T7_compressed, dfa34_T8, dfa34_T8_compressed, dfa34_T9, dfa34_T9_compressed, 
	dfa34_T10, dfa34_T10_compressed, dfa34_T11, dfa34_T11_compressed, dfa34_T12, dfa34_T12_compressed, dfa34_T13, dfa34_T13_compressed, dfa34_T14, dfa34_T14_compressed, dfa34_T15, dfa34_T15_compressed, dfa34_T16, dfa34_T16_compressed, dfa34_T17, dfa34_T17_compressed, dfa34_T18, dfa34_T18_compressed, dfa34_T19, dfa34_T19_compressed, 
	dfa34_T20, dfa34_T20_compressed, dfa34_T21, dfa34_T21_compressed, dfa34_T22, dfa34_T22_compressed, dfa34_T23, dfa34_T23_compressed, dfa34_T24, dfa34_T24_compressed, dfa34_T25, dfa34_T25_compressed, dfa34_T26, dfa34_T26_compressed, dfa34_T27, dfa34_T27_compressed, dfa34_T28, dfa34_T28_compressed, dfa34_T29, dfa34_T29_compressed, 
	dfa34_T30, dfa34_T30_compressed, dfa34_T31, dfa34_T31_compressed, dfa34_T32, dfa34_T32_compressed, dfa34_T33, dfa34_T33_compressed, dfa34_T34, dfa34_T34_compressed, dfa34_T35, dfa34_T35_compressed, dfa34_T36, dfa34_T36_compressed, dfa34_T37, dfa34_T37_compressed, dfa34_T38, dfa34_T38_compressed, dfa34_T39, dfa34_T39_compressed, 
	dfa34_T40, dfa34_T40_compressed, dfa34_T41, dfa34_T41_compressed, dfa34_T42, dfa34_T42_compressed, dfa34_T43, dfa34_T43_compressed, dfa34_T44, dfa34_T44_compressed, dfa34_T45, dfa34_T45_compressed, dfa34_T46, dfa34_T46_compressed, dfa34_T47, dfa34_T47_compressed, dfa34_T48, dfa34_T48_compressed, dfa34_T49, dfa34_T49_compressed, 
	dfa34_T50, dfa34_T50_compressed, dfa34_T51, dfa34_T51_compressed, dfa34_T52, dfa34_T52_compressed, dfa34_T53, dfa34_T53_compressed, dfa34_T54, dfa34_T54_compressed, dfa34_T55, dfa34_T55_compressed, dfa34_T56, dfa34_T56_compressed, dfa34_T57, dfa34_T57_compressed, dfa34_T58, dfa34_T58_compressed, dfa34_T59, dfa34_T59_compressed, 
	dfa34_T60, dfa34_T60_compressed, dfa34_T61, dfa34_T61_compressed, dfa34_T62, dfa34_T62_compressed, dfa34_T63, dfa34_T63_compressed, dfa34_T64, dfa34_T64_compressed, dfa34_T65, dfa34_T65_compressed, dfa34_T66, dfa34_T66_compressed, dfa34_T67, dfa34_T67_compressed, dfa34_T68, dfa34_T68_compressed, dfa34_T69, dfa34_T69_compressed, 
	dfa34_T70, dfa34_T70_compressed, dfa34_T71, dfa34_T71_compressed, dfa34_T72, dfa34_T72_compressed, dfa34_T73, dfa34_T73_compressed, dfa34_T74, dfa34_T74_compressed, dfa34_T75, dfa34_T75_compressed, dfa34_T76, dfa34_T76_compressed, dfa34_T77, dfa34_T77_compressed, dfa34_T78, dfa34_T78_compressed, dfa34_T79, dfa34_T79_compressed, 
	dfa34_T80, dfa34_T80_compressed, dfa34_T81, dfa34_T81_compressed, dfa34_T82, dfa34_T82_compressed, dfa34_T83, dfa34_T83_compressed, dfa34_T84, dfa34_T84_compressed, dfa34_T85, dfa34_T85_compressed, dfa34_T86, dfa34_T86_compressed, dfa34_T87, dfa34_T87_compressed, dfa34_T88, dfa34_T88_compressed, dfa34_T89, dfa34_T89_compressed, 
	dfa34_T90, dfa34_T90_compressed, dfa34_T91, dfa34_T91_compressed, dfa34_T92, dfa34_T92_compressed, dfa34_T93, dfa34_T93_compressed, dfa34_T94, dfa34_T94_compressed, dfa34_T95, dfa34_T95_compressed, dfa34_T96, dfa34_T96_compressed, dfa34_T97, dfa34_T97_compressed, dfa34_T98, dfa34_T98_compressed, dfa34_T99, dfa34_T99_compressed, 
	dfa34_T100, dfa34_T100_compressed, dfa34_T101, dfa34_T101_compressed, dfa34_T102, dfa34_T102_compressed, dfa34_T103, dfa34_T103_compressed, dfa34_T104, dfa34_T104_compressed, dfa34_T105, dfa34_T105_compressed, dfa34_T106, dfa34_T106_compressed, dfa34_T107, dfa34_T107_compressed, dfa34_T108, dfa34_T108_compressed, dfa34_T109, dfa34_T109_compressed, 
	dfa34_T110, dfa34_T110_compressed, dfa34_T111, dfa34_T111_compressed, dfa34_T112, dfa34_T112_compressed, dfa34_T113, dfa34_T113_compressed, dfa34_T114, dfa34_T114_compressed, dfa34_T115, dfa34_T115_compressed, dfa34_T116, dfa34_T116_compressed, dfa34_T117, dfa34_T117_compressed, dfa34_T118, dfa34_T118_compressed, dfa34_T119, dfa34_T119_compressed, 
	dfa34_T120, dfa34_T120_compressed, dfa34_T121, dfa34_T121_compressed, dfa34_T122, dfa34_T122_compressed, dfa34_T123, dfa34_T123_compressed, dfa34_T124, dfa34_T124_compressed, dfa34_T125, dfa34_T125_compressed, dfa34_T126, dfa34_T126_compressed, dfa34_T127, dfa34_T127_compressed, dfa34_T128, dfa34_T128_compressed, dfa34_T129, dfa34_T129_compressed, 
	dfa34_T130, dfa34_T130_compressed, dfa34_T131, dfa34_T131_compressed, dfa34_T132, dfa34_T132_compressed, dfa34_T133, dfa34_T133_compressed, dfa34_T134, dfa34_T134_compressed, dfa34_T135, dfa34_T135_compressed, dfa34_T136, dfa34_T136_compressed, dfa34_T137, dfa34_T137_compressed, dfa34_T138, dfa34_T138_compressed, dfa34_T139, dfa34_T139_compressed, 
	dfa34_T140, dfa34_T140_compressed, dfa34_T141, dfa34_T141_compressed, dfa34_T142, dfa34_T142_compressed, dfa34_T143, dfa34_T143_compressed, dfa34_T144, dfa34_T144_compressed, dfa34_T145, dfa34_T145_compressed, dfa34_T146, dfa34_T146_compressed, dfa34_T147, dfa34_T147_compressed, dfa34_T148, dfa34_T148_compressed, dfa34_T149, dfa34_T149_compressed, 
	dfa34_T150, dfa34_T150_compressed, dfa34_T151, dfa34_T151_compressed, dfa34_T152, dfa34_T152_compressed, dfa34_T153, dfa34_T153_compressed, dfa34_T154, dfa34_T154_compressed, dfa34_T155, dfa34_T155_compressed, dfa34_T156, dfa34_T156_compressed, dfa34_T157, dfa34_T157_compressed, dfa34_T158, dfa34_T158_compressed, dfa34_T159, dfa34_T159_compressed, 
	dfa34_T160, dfa34_T160_compressed, dfa34_T161, dfa34_T161_compressed, dfa34_T162, dfa34_T162_compressed, dfa34_T163, dfa34_T163_compressed, dfa34_T164, dfa34_T164_compressed, dfa34_T165, dfa34_T165_compressed, dfa34_T166, dfa34_T166_compressed, dfa34_T167, dfa34_T167_compressed, dfa34_T168, dfa34_T168_compressed, dfa34_T169, dfa34_T169_compressed, 
	dfa34_T170, dfa34_T170_compressed, dfa34_T171, dfa34_T171_compressed, dfa34_T172, dfa34_T172_compressed, dfa34_T173, dfa34_T173_compressed, dfa34_T174, dfa34_T174_compressed, dfa34_T175, dfa34_T175_compressed, dfa34_T176, dfa34_T176_compressed, dfa34_T177, dfa34_T177_compressed, dfa34_T178, dfa34_T178_compressed, dfa34_T179, dfa34_T179_compressed, 
	dfa34_T180, dfa34_T180_compressed, dfa34_T181, dfa34_T181_compressed, dfa34_T182, dfa34_T182_compressed, dfa34_T183, dfa34_T183_compressed, dfa34_T184, dfa34_T184_compressed, dfa34_T185, dfa34_T185_compressed, dfa34_T186, dfa34_T186_compressed, dfa34_T187, dfa34_T187_compressed, dfa34_T188, dfa34_T188_compressed, dfa34_T189, dfa34_T189_compressed, 
	dfa34_T190, dfa34_T190_compressed, dfa34_T191, dfa34_T191_compressed, dfa34_T192, dfa34_T192_compressed, dfa34_T193, dfa34_T193_compressed, dfa34_T194, dfa34_T194_compressed, dfa34_T195, dfa34_T195_compressed, dfa34_T196, dfa34_T196_compressed, dfa34_T197, dfa34_T197_compressed, dfa34_T198, dfa34_T198_compressed, dfa34_T199, dfa34_T199_compressed, 
	dfa34_T200, dfa34_T200_compressed, dfa34_T201, dfa34_T201_compressed, dfa34_T202, dfa34_T202_compressed, dfa34_T203, dfa34_T203_compressed, dfa34_T204, dfa34_T204_compressed, dfa34_T205, dfa34_T205_compressed, dfa34_T206, dfa34_T206_compressed, dfa34_T207, dfa34_T207_compressed, dfa34_T208, dfa34_T208_compressed, dfa34_T209, dfa34_T209_compressed, 
	dfa34_T210, dfa34_T210_compressed, dfa34_T211, dfa34_T211_compressed, dfa34_T212, dfa34_T212_compressed, dfa34_T213, dfa34_T213_compressed, dfa34_T214, dfa34_T214_compressed, dfa34_T215, dfa34_T215_compressed, dfa34_T216, dfa34_T216_compressed, dfa34_T217, dfa34_T217_compressed, dfa34_T218, dfa34_T218_compressed, dfa34_T219, dfa34_T219_compressed, 
	dfa34_T220, dfa34_T220_compressed, dfa34_T221, dfa34_T221_compressed, dfa34_T222, dfa34_T222_compressed, dfa34_T223, dfa34_T223_compressed, dfa34_T224, dfa34_T224_compressed, dfa34_T225, dfa34_T225_compressed, dfa34_T226, dfa34_T226_compressed, dfa34_T227, dfa34_T227_compressed, dfa34_T228, dfa34_T228_compressed, dfa34_T229, dfa34_T229_compressed, 
	dfa34_T230, dfa34_T230_compressed, dfa34_T231, dfa34_T231_compressed, dfa34_T232, dfa34_T232_compressed, dfa34_T233, dfa34_T233_compressed, dfa34_T234, dfa34_T234_compressed, dfa34_T235, dfa34_T235_compressed, dfa34_T236, dfa34_T236_compressed, dfa34_T237, dfa34_T237_compressed, dfa34_T238, dfa34_T238_compressed, dfa34_T239, dfa34_T239_compressed, 
	dfa34_T240, dfa34_T240_compressed, dfa34_T241, dfa34_T241_compressed, dfa34_T242, dfa34_T242_compressed, dfa34_T243, dfa34_T243_compressed, dfa34_T244, dfa34_T244_compressed, dfa34_T245, dfa34_T245_compressed, dfa34_T246, dfa34_T246_compressed, dfa34_T247, dfa34_T247_compressed, dfa34_T248, dfa34_T248_compressed, dfa34_T249, dfa34_T249_compressed, 
	dfa34_T250, dfa34_T250_compressed, dfa34_T251, dfa34_T251_compressed, dfa34_T252, dfa34_T252_compressed, dfa34_T253, dfa34_T253_compressed, dfa34_T254, dfa34_T254_compressed, dfa34_T255, dfa34_T255_compressed, dfa34_T256, dfa34_T256_compressed, dfa34_T257, dfa34_T257_compressed, dfa34_T258, dfa34_T258_compressed, dfa34_T259, dfa34_T259_compressed, 
	dfa34_T260, dfa34_T260_compressed, dfa34_T261, dfa34_T261_compressed, dfa34_T262, dfa34_T262_compressed, dfa34_T263, dfa34_T263_compressed, dfa34_T264, dfa34_T264_compressed, dfa34_T265, dfa34_T265_compressed, dfa34_T266, dfa34_T266_compressed, dfa34_T267, dfa34_T267_compressed, dfa34_T268, dfa34_T268_compressed, dfa34_T269, dfa34_T269_compressed, 
	dfa34_T270, dfa34_T270_compressed, dfa34_T271, dfa34_T271_compressed, dfa34_T272, dfa34_T272_compressed, dfa34_T273, dfa34_T273_compressed, dfa34_T274, dfa34_T274_compressed, dfa34_T275, dfa34_T275_compressed, dfa34_T276, dfa34_T276_compressed, dfa34_T277, dfa34_T277_compressed, dfa34_T278, dfa34_T278_compressed, dfa34_T279, dfa34_T279_compressed, 
	dfa34_T280, dfa34_T280_compressed, dfa34_T281, dfa34_T281_compressed, dfa34_T282, dfa34_T282_compressed, dfa34_T283, dfa34_T283_compressed, dfa34_T284, dfa34_T284_compressed, dfa34_T285, dfa34_T285_compressed, dfa34_T286, dfa34_T286_compressed, dfa34_T287, dfa34_T287_compressed, dfa34_T288, dfa34_T288_compressed, dfa34_T289, dfa34_T289_compressed, 
	dfa34_T290, dfa34_T290_compressed, dfa34_T291, dfa34_T291_compressed, dfa34_T292, dfa34_T292_compressed, dfa34_T293, dfa34_T293_compressed, dfa34_T294, dfa34_T294_compressed, dfa34_T295, dfa34_T295_compressed, dfa34_T296, dfa34_T296_compressed, dfa34_T297, dfa34_T297_compressed, dfa34_T298, dfa34_T298_compressed, dfa34_T299, dfa34_T299_compressed, 
	dfa34_T300, dfa34_T300_compressed, dfa34_T301, dfa34_T301_compressed, dfa34_T302, dfa34_T302_compressed, dfa34_T303, dfa34_T303_compressed, dfa34_T304, dfa34_T304_compressed, dfa34_T305, dfa34_T305_compressed, dfa34_T306, dfa34_T306_compressed, dfa34_T307, dfa34_T307_compressed, dfa34_T308, dfa34_T308_compressed, dfa34_T309, dfa34_T309_compressed, 
	dfa34_T310, dfa34_T310_compressed, dfa34_T311, dfa34_T311_compressed, dfa34_T312, dfa34_T312_compressed, dfa34_T313, dfa34_T313_compressed, dfa34_T314, dfa34_T314_compressed, dfa34_T315, dfa34_T315_compressed, dfa34_T316, dfa34_T316_compressed, dfa34_T317, dfa34_T317_compressed, dfa34_T318, dfa34_T318_compressed, dfa34_T319, dfa34_T319_compressed, 
	dfa34_T320, dfa34_T320_compressed, dfa34_T321, dfa34_T321_compressed, dfa34_T322, dfa34_T322_compressed, dfa34_T323, dfa34_T323_compressed, dfa34_T324, dfa34_T324_compressed, dfa34_T325, dfa34_T325_compressed, dfa34_T326, dfa34_T326_compressed, dfa34_T327, dfa34_T327_compressed, dfa34_T328, dfa34_T328_compressed, dfa34_T329, dfa34_T329_compressed, 
	dfa34_T330, dfa34_T330_compressed, dfa34_T331, dfa34_T331_compressed, dfa34_T332, dfa34_T332_compressed, dfa34_T333, dfa34_T333_compressed, dfa34_T334, dfa34_T334_compressed, dfa34_T335, dfa34_T335_compressed, dfa34_T336, dfa34_T336_compressed, dfa34_T337, dfa34_T337_compressed, dfa34_T338, dfa34_T338_compressed, dfa34_T339, dfa34_T339_compressed, 
	dfa34_T340, dfa34_T340_compressed, dfa34_T341, dfa34_T341_compressed, dfa34_T342, dfa34_T342_compressed, dfa34_T343, dfa34_T343_compressed, dfa34_T344, dfa34_T344_compressed, dfa34_T345, dfa34_T345_compressed, dfa34_T346, dfa34_T346_compressed, dfa34_T347, dfa34_T347_compressed, dfa34_T348, dfa34_T348_compressed, dfa34_T349, dfa34_T349_compressed
	};



void dfa34_Table_uncompress()
{
	static ANTLR3_INT32 dfa34_Table_compression_status = 0;

	if (dfa34_Table_compression_status != 0)	return;
	dfa34_Table_compression_status = 1;

	ANTLR3_INT32 i;
	for (i = 0; i < sizeof(dfa34_Tables) / sizeof(ANTLR3_INT32*); i += 2)
	{
		ANTLR3_INT32*	target = dfa34_Tables[i];
		ANTLR3_INT32*	source = dfa34_Tables[i + 1];
		
		ANTLR3_INT32 p = 0;
		ANTLR3_INT32 j;

		for (j = 1; j <= source[0]; j++)
		{
			ANTLR3_INT32	k = source[j * 2];
			while (k-- > 0)
			{
				target[p++] = source[j * 2 - 1];
			}
		}	
	}	
}

/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR3_INT32 * const dfa34_transitions[] =
{
    dfa34_T272, NULL, dfa34_T23, dfa34_T326, dfa34_T131, dfa34_T40, dfa34_T278, 
    dfa34_T235, dfa34_T168, dfa34_T266, dfa34_T98, dfa34_T48, dfa34_T95, 
    dfa34_T177, dfa34_T216, dfa34_T52, dfa34_T168, dfa34_T269, dfa34_T160, 
    dfa34_T78, dfa34_T271, dfa34_T123, dfa34_T281, dfa34_T7, dfa34_T195, 
    dfa34_T102, dfa34_T284, dfa34_T114, dfa34_T292, dfa34_T101, dfa34_T228, 
    dfa34_T302, dfa34_T65, dfa34_T60, dfa34_T315, dfa34_T324, dfa34_T83, 
    dfa34_T323, dfa34_T34, dfa34_T9, dfa34_T243, dfa34_T43, NULL, NULL, 
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, dfa34_T46, 
    dfa34_T7, dfa34_T132, dfa34_T327, dfa34_T277, dfa34_T7, dfa34_T334, 
    dfa34_T195, dfa34_T45, dfa34_T336, dfa34_T287, dfa34_T282, dfa34_T92, 
    dfa34_T223, dfa34_T21, dfa34_T0, dfa34_T125, dfa34_T256, dfa34_T217, 
    dfa34_T293, dfa34_T274, dfa34_T290, dfa34_T247, dfa34_T213, dfa34_T209, 
    dfa34_T299, dfa34_T176, dfa34_T219, dfa34_T244, dfa34_T297, dfa34_T126, 
    NULL, dfa34_T99, dfa34_T166, dfa34_T180, dfa34_T294, dfa34_T103, dfa34_T232, 
    dfa34_T110, dfa34_T252, dfa34_T112, dfa34_T73, dfa34_T81, dfa34_T64, 
    dfa34_T346, dfa34_T183, dfa34_T318, dfa34_T331, dfa34_T129, dfa34_T222, 
    dfa34_T275, dfa34_T320, dfa34_T342, dfa34_T53, dfa34_T279, dfa34_T7, 
    dfa34_T186, dfa34_T7, dfa34_T33, dfa34_T7, dfa34_T304, dfa34_T135, dfa34_T44, 
    dfa34_T122, dfa34_T264, dfa34_T11, dfa34_T312, dfa34_T154, dfa34_T330, 
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, dfa34_T101, dfa34_T72, 
    NULL, NULL, dfa34_T317, NULL, dfa34_T283, dfa34_T173, NULL, dfa34_T261, 
    dfa34_T185, dfa34_T291, NULL, dfa34_T307, NULL, dfa34_T148, NULL, NULL, 
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, dfa34_T47, NULL, dfa34_T136, 
    dfa34_T328, dfa34_T276, dfa34_T55, dfa34_T50, dfa34_T259, dfa34_T29, 
    dfa34_T147, dfa34_T251, dfa34_T280, dfa34_T169, dfa34_T7, dfa34_T225, 
    dfa34_T28, dfa34_T3, dfa34_T250, dfa34_T233, dfa34_T227, dfa34_T134, 
    dfa34_T7, dfa34_T218, dfa34_T12, dfa34_T178, dfa34_T273, dfa34_T289, 
    dfa34_T246, dfa34_T208, dfa34_T75, dfa34_T104, dfa34_T215, dfa34_T210, 
    dfa34_T298, dfa34_T7, dfa34_T7, NULL, dfa34_T7, dfa34_T7, dfa34_T7, 
    dfa34_T7, dfa34_T97, dfa34_T165, dfa34_T179, dfa34_T295, dfa34_T105, 
    dfa34_T7, dfa34_T7, dfa34_T111, dfa34_T241, dfa34_T113, dfa34_T76, dfa34_T82, 
    dfa34_T66, dfa34_T344, dfa34_T182, dfa34_T319, dfa34_T152, dfa34_T200, 
    dfa34_T145, dfa34_T267, dfa34_T220, dfa34_T7, dfa34_T321, dfa34_T189, 
    dfa34_T190, dfa34_T205, dfa34_T201, dfa34_T100, dfa34_T234, dfa34_T239, 
    NULL, dfa34_T7, NULL, dfa34_T187, NULL, dfa34_T38, NULL, dfa34_T206, 
    dfa34_T4, dfa34_T242, dfa34_T7, dfa34_T7, dfa34_T263, dfa34_T10, dfa34_T311, 
    dfa34_T156, dfa34_T329, NULL, dfa34_T72, NULL, dfa34_T146, NULL, dfa34_T348, 
    NULL, dfa34_T24, NULL, dfa34_T49, NULL, NULL, NULL, dfa34_T7, dfa34_T133, 
    dfa34_T96, dfa34_T270, dfa34_T56, dfa34_T6, dfa34_T260, dfa34_T30, dfa34_T149, 
    dfa34_T184, dfa34_T340, dfa34_T335, dfa34_T86, NULL, dfa34_T193, dfa34_T119, 
    dfa34_T170, NULL, dfa34_T226, dfa34_T7, dfa34_T240, dfa34_T58, dfa34_T63, 
    dfa34_T1, dfa34_T229, dfa34_T231, dfa34_T248, dfa34_T237, NULL, dfa34_T7, 
    dfa34_T19, dfa34_T167, dfa34_T7, dfa34_T288, dfa34_T31, dfa34_T286, 
    dfa34_T349, dfa34_T7, dfa34_T70, dfa34_T106, dfa34_T214, dfa34_T211, 
    dfa34_T7, NULL, NULL, NULL, NULL, NULL, NULL, dfa34_T7, dfa34_T164, 
    dfa34_T181, dfa34_T296, dfa34_T108, NULL, NULL, dfa34_T109, dfa34_T7, 
    dfa34_T59, dfa34_T77, dfa34_T84, dfa34_T68, dfa34_T15, dfa34_T7, dfa34_T316, 
    dfa34_T150, dfa34_T197, dfa34_T144, dfa34_T265, dfa34_T221, NULL, dfa34_T322, 
    dfa34_T188, dfa34_T202, dfa34_T204, dfa34_T199, dfa34_T91, dfa34_T238, 
    dfa34_T7, NULL, dfa34_T7, dfa34_T37, dfa34_T7, dfa34_T2, dfa34_T74, 
    NULL, NULL, NULL, dfa34_T262, dfa34_T8, dfa34_T314, dfa34_T158, dfa34_T7, 
    NULL, dfa34_T146, NULL, dfa34_T24, NULL, dfa34_T7, dfa34_T255, NULL, 
    dfa34_T7, dfa34_T54, dfa34_T5, dfa34_T257, dfa34_T26, dfa34_T151, dfa34_T325, 
    dfa34_T80, dfa34_T341, dfa34_T333, dfa34_T7, dfa34_T191, dfa34_T121, 
    dfa34_T171, dfa34_T224, NULL, dfa34_T51, dfa34_T61, dfa34_T57, dfa34_T62, 
    dfa34_T14, dfa34_T85, NULL, dfa34_T230, dfa34_T245, dfa34_T142, NULL, 
    NULL, dfa34_T20, dfa34_T7, NULL, dfa34_T7, dfa34_T32, dfa34_T285, dfa34_T345, 
    NULL, dfa34_T71, dfa34_T7, dfa34_T7, dfa34_T212, NULL, NULL, dfa34_T162, 
    dfa34_T7, dfa34_T7, dfa34_T7, dfa34_T7, NULL, dfa34_T7, dfa34_T79, dfa34_T155, 
    dfa34_T7, dfa34_T124, NULL, NULL, dfa34_T7, dfa34_T7, dfa34_T207, dfa34_T7, 
    dfa34_T7, dfa34_T7, dfa34_T7, dfa34_T7, dfa34_T7, dfa34_T203, dfa34_T198, 
    dfa34_T90, dfa34_T236, NULL, NULL, dfa34_T41, NULL, dfa34_T7, dfa34_T7, 
    dfa34_T17, dfa34_T268, dfa34_T7, dfa34_T313, dfa34_T143, NULL, NULL, 
    dfa34_T253, NULL, dfa34_T7, dfa34_T7, dfa34_T258, dfa34_T27, dfa34_T161, 
    dfa34_T7, dfa34_T87, dfa34_T338, dfa34_T332, NULL, dfa34_T192, dfa34_T7, 
    dfa34_T7, dfa34_T7, dfa34_T7, dfa34_T7, dfa34_T7, dfa34_T7, dfa34_T13, 
    dfa34_T89, dfa34_T7, dfa34_T249, dfa34_T138, dfa34_T22, NULL, NULL, 
    dfa34_T35, dfa34_T7, dfa34_T347, dfa34_T67, NULL, NULL, dfa34_T7, dfa34_T7, 
    NULL, NULL, NULL, NULL, NULL, dfa34_T7, dfa34_T157, NULL, dfa34_T116, 
    NULL, NULL, dfa34_T141, NULL, NULL, NULL, NULL, NULL, NULL, NULL, dfa34_T196, 
    dfa34_T172, dfa34_T94, dfa34_T7, dfa34_T39, NULL, NULL, dfa34_T18, dfa34_T7, 
    NULL, dfa34_T308, dfa34_T7, dfa34_T254, NULL, NULL, dfa34_T7, dfa34_T7, 
    dfa34_T159, NULL, dfa34_T7, dfa34_T339, dfa34_T7, dfa34_T194, NULL, 
    NULL, NULL, NULL, NULL, NULL, NULL, dfa34_T16, dfa34_T88, NULL, dfa34_T7, 
    dfa34_T137, dfa34_T7, dfa34_T36, NULL, dfa34_T343, dfa34_T69, NULL, 
    NULL, NULL, dfa34_T153, dfa34_T117, dfa34_T140, dfa34_T7, dfa34_T174, 
    dfa34_T93, NULL, dfa34_T42, dfa34_T7, NULL, dfa34_T306, NULL, dfa34_T7, 
    NULL, NULL, dfa34_T163, NULL, dfa34_T337, NULL, dfa34_T7, dfa34_T7, 
    dfa34_T7, NULL, dfa34_T7, NULL, dfa34_T25, dfa34_T7, dfa34_T7, dfa34_T7, 
    dfa34_T118, dfa34_T139, NULL, dfa34_T175, dfa34_T107, dfa34_T7, NULL, 
    dfa34_T310, NULL, dfa34_T7, dfa34_T7, NULL, NULL, NULL, NULL, dfa34_T7, 
    NULL, NULL, NULL, dfa34_T120, dfa34_T130, dfa34_T7, dfa34_T7, NULL, 
    dfa34_T309, NULL, NULL, NULL, dfa34_T115, dfa34_T128, NULL, NULL, dfa34_T301, 
    dfa34_T7, dfa34_T127, dfa34_T300, NULL, dfa34_T7, dfa34_T305, NULL, 
    dfa34_T303, dfa34_T7, NULL
};

static ANTLR3_INT32 dfa34_sst(pSparqlLexer ctx, pANTLR3_BASE_RECOGNIZER recognizer, pANTLR3_INT_STREAM is, pANTLR3_CYCLIC_DFA dfa, ANTLR3_INT32 s)
{
    ANTLR3_INT32    _s;

    _s	    = s;
    switch  (s)
    {
        case 0:

    	{
    	    ANTLR3_UINT32 LA34_33;

    	    ANTLR3_MARKER index34_33;


    		LA34_33 = LA(1);

    	    s = -1;
    	    if ( (LA34_33 == '\'') )
    	    {
    	        s = 143;
    	    }

    	    else if ( (((LA34_33 >= 0x0000) && (LA34_33 <= '\t')) || ((LA34_33 >= 0x000B) && (LA34_33 <= '\f')) || ((LA34_33 >= 0x000E) && (LA34_33 <= '&')) || ((LA34_33 >= '(') && (LA34_33 <= 0xFFFF))) )
    	    {
    	        s = 144;
    	    }

    	    else s = 53;

    	    if ( s>=0 )
    	    {
    		return s;
    	    }
    	}
    	break;

        case 1:

    	{
    	    ANTLR3_UINT32 LA34_36;

    	    ANTLR3_MARKER index34_36;


    		LA34_36 = LA(1);

    	    s = -1;
    	    if ( (((LA34_36 >= 0x0000) && (LA34_36 <= 0xFFFF))) )
    	    {
    	        s = 149;
    	    }

    	    else s = 53;

    	    if ( s>=0 )
    	    {
    		return s;
    	    }
    	}
    	break;

        case 2:

    	{
    	    ANTLR3_UINT32 LA34_0;

    	    ANTLR3_MARKER index34_0;


    		LA34_0 = LA(1);

    	    s = -1;
    	    if ( (((LA34_0 >= '\t') && (LA34_0 <= '\n')) || LA34_0 == '\r' || LA34_0 == ' ') )
    	    {
    	        s = 1;
    	    }

    	    else if ( (LA34_0 == 'B' || LA34_0 == 'b') )
    	    {
    	        s = 2;
    	    }

    	    else if ( (LA34_0 == 'P' || LA34_0 == 'p') )
    	    {
    	        s = 3;
    	    }

    	    else if ( (LA34_0 == 'S' || LA34_0 == 's') )
    	    {
    	        s = 4;
    	    }

    	    else if ( (LA34_0 == 'D' || LA34_0 == 'd') )
    	    {
    	        s = 5;
    	    }

    	    else if ( (LA34_0 == 'R' || LA34_0 == 'r') )
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA34_0 == 'C' || LA34_0 == 'c') )
    	    {
    	        s = 7;
    	    }

    	    else if ( (LA34_0 == 'a') )
    	    {
    	        s = 8;
    	    }

    	    else if ( (LA34_0 == 'F' || LA34_0 == 'f') )
    	    {
    	        s = 9;
    	    }

    	    else if ( (LA34_0 == 'N' || LA34_0 == 'n') )
    	    {
    	        s = 10;
    	    }

    	    else if ( (LA34_0 == 'W' || LA34_0 == 'w') )
    	    {
    	        s = 11;
    	    }

    	    else if ( (LA34_0 == 'O' || LA34_0 == 'o') )
    	    {
    	        s = 12;
    	    }

    	    else if ( (LA34_0 == 'L' || LA34_0 == 'l') )
    	    {
    	        s = 13;
    	    }

    	    else if ( (LA34_0 == 'G' || LA34_0 == 'g') )
    	    {
    	        s = 14;
    	    }

    	    else if ( (LA34_0 == 'U' || LA34_0 == 'u') )
    	    {
    	        s = 15;
    	    }

    	    else if ( (LA34_0 == 'A') )
    	    {
    	        s = 16;
    	    }

    	    else if ( (LA34_0 == 'I' || LA34_0 == 'i') )
    	    {
    	        s = 17;
    	    }

    	    else if ( (LA34_0 == 'T' || LA34_0 == 't') )
    	    {
    	        s = 18;
    	    }

    	    else if ( (LA34_0 == 'M' || LA34_0 == 'm') )
    	    {
    	        s = 19;
    	    }

    	    else if ( (LA34_0 == 'H' || LA34_0 == 'h') )
    	    {
    	        s = 20;
    	    }

    	    else if ( (LA34_0 == 'E' || LA34_0 == 'e') )
    	    {
    	        s = 21;
    	    }

    	    else if ( (LA34_0 == 'Y' || LA34_0 == 'y') )
    	    {
    	        s = 22;
    	    }

    	    else if ( (((LA34_0 >= 'J') && (LA34_0 <= 'K')) || LA34_0 == 'Q' || LA34_0 == 'V' || LA34_0 == 'X' || LA34_0 == 'Z' || ((LA34_0 >= 'j') && (LA34_0 <= 'k')) || LA34_0 == 'q' || LA34_0 == 'v' || LA34_0 == 'x' || LA34_0 == 'z' || ((LA34_0 >= 0x00C0) && (LA34_0 <= 0x00D6)) || ((LA34_0 >= 0x00D8) && (LA34_0 <= 0x00F6)) || ((LA34_0 >= 0x00F8) && (LA34_0 <= 0x02FF)) || ((LA34_0 >= 0x0370) && (LA34_0 <= 0x037D)) || ((LA34_0 >= 0x037F) && (LA34_0 <= 0x1FFF)) || ((LA34_0 >= 0x200C) && (LA34_0 <= 0x200D)) || ((LA34_0 >= 0x2070) && (LA34_0 <= 0x218F)) || ((LA34_0 >= 0x2C00) && (LA34_0 <= 0x2FEF)) || ((LA34_0 >= 0x3001) && (LA34_0 <= 0xD7FF)) || ((LA34_0 >= 0xF900) && (LA34_0 <= 0xFDCF)) || ((LA34_0 >= 0xFDF0) && (LA34_0 <= 0xFFFD))) )
    	    {
    	        s = 23;
    	    }

    	    else if ( (LA34_0 == ':') )
    	    {
    	        s = 24;
    	    }

    	    else if ( (LA34_0 == '_') )
    	    {
    	        s = 25;
    	    }

    	    else if ( (LA34_0 == '?') )
    	    {
    	        s = 26;
    	    }

    	    else if ( (LA34_0 == '$') )
    	    {
    	        s = 27;
    	    }

    	    else if ( (LA34_0 == '@') )
    	    {
    	        s = 28;
    	    }

    	    else if ( (((LA34_0 >= '0') && (LA34_0 <= '9'))) )
    	    {
    	        s = 29;
    	    }

    	    else if ( (LA34_0 == '.') )
    	    {
    	        s = 30;
    	    }

    	    else if ( (LA34_0 == '+') )
    	    {
    	        s = 31;
    	    }

    	    else if ( (LA34_0 == '-') )
    	    {
    	        s = 32;
    	    }

    	    else if ( (LA34_0 == '\'') )
    	    {
    	        s = 33;
    	    }

    	    else if ( (LA34_0 == '"') )
    	    {
    	        s = 34;
    	    }

    	    else if ( (LA34_0 == '<') )
    	    {
    	        s = 35;
    	    }

    	    else if ( (LA34_0 == '#') )
    	    {
    	        s = 36;
    	    }

    	    else if ( (LA34_0 == '^') )
    	    {
    	        s = 37;
    	    }

    	    else if ( (LA34_0 == '>') )
    	    {
    	        s = 38;
    	    }

    	    else if ( (LA34_0 == '!') )
    	    {
    	        s = 39;
    	    }

    	    else if ( (LA34_0 == '&') )
    	    {
    	        s = 40;
    	    }

    	    else if ( (LA34_0 == '|') )
    	    {
    	        s = 41;
    	    }

    	    else if ( (LA34_0 == '(') )
    	    {
    	        s = 42;
    	    }

    	    else if ( (LA34_0 == ')') )
    	    {
    	        s = 43;
    	    }

    	    else if ( (LA34_0 == '{') )
    	    {
    	        s = 44;
    	    }

    	    else if ( (LA34_0 == '}') )
    	    {
    	        s = 45;
    	    }

    	    else if ( (LA34_0 == '[') )
    	    {
    	        s = 46;
    	    }

    	    else if ( (LA34_0 == ']') )
    	    {
    	        s = 47;
    	    }

    	    else if ( (LA34_0 == ';') )
    	    {
    	        s = 48;
    	    }

    	    else if ( (LA34_0 == '*') )
    	    {
    	        s = 49;
    	    }

    	    else if ( (LA34_0 == ',') )
    	    {
    	        s = 50;
    	    }

    	    else if ( (LA34_0 == '/') )
    	    {
    	        s = 51;
    	    }

    	    else if ( (LA34_0 == '=') )
    	    {
    	        s = 52;
    	    }

    	    else if ( (((LA34_0 >= 0x0000) && (LA34_0 <= '\b')) || ((LA34_0 >= 0x000B) && (LA34_0 <= '\f')) || ((LA34_0 >= 0x000E) && (LA34_0 <= 0x001F)) || LA34_0 == '%' || LA34_0 == '\\' || LA34_0 == '`' || ((LA34_0 >= '~') && (LA34_0 <= 0x00BF)) || LA34_0 == 0x00D7 || LA34_0 == 0x00F7 || ((LA34_0 >= 0x0300) && (LA34_0 <= 0x036F)) || LA34_0 == 0x037E || ((LA34_0 >= 0x2000) && (LA34_0 <= 0x200B)) || ((LA34_0 >= 0x200E) && (LA34_0 <= 0x206F)) || ((LA34_0 >= 0x2190) && (LA34_0 <= 0x2BFF)) || ((LA34_0 >= 0x2FF0) && (LA34_0 <= 0x3000)) || ((LA34_0 >= 0xD800) && (LA34_0 <= 0xF8FF)) || ((LA34_0 >= 0xFDD0) && (LA34_0 <= 0xFDEF)) || ((LA34_0 >= 0xFFFE) && (LA34_0 <= 0xFFFF))) )
    	    {
    	        s = 53;
    	    }

    	    if ( s>=0 )
    	    {
    		return s;
    	    }
    	}
    	break;

        case 3:

    	{
    	    ANTLR3_UINT32 LA34_34;

    	    ANTLR3_MARKER index34_34;


    		LA34_34 = LA(1);

    	    s = -1;
    	    if ( (LA34_34 == '"') )
    	    {
    	        s = 145;
    	    }

    	    else if ( (((LA34_34 >= 0x0000) && (LA34_34 <= '\t')) || ((LA34_34 >= 0x000B) && (LA34_34 <= '\f')) || ((LA34_34 >= 0x000E) && (LA34_34 <= '!')) || ((LA34_34 >= '#') && (LA34_34 <= 0xFFFF))) )
    	    {
    	        s = 146;
    	    }

    	    else s = 53;

    	    if ( s>=0 )
    	    {
    		return s;
    	    }
    	}
    	break;
    }
    if (BACKTRACKING > 0)
    {
	FAILEDFLAG = ANTLR3_TRUE;
	return	-1;
    }

    CONSTRUCTEX();
    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
    EXCEPTION->message      = (void *)"1:1: Tokens : ( WS | BASE | PREFIX | SELECT | DISTINCT | REDUCED | CONSTRUCT | DESCRIBE | ASK | FROM | NAMED | WHERE | ORDER | BY | ASC | DESC | LIMIT | OFFSET | OPTIONAL | GRAPH_PP | UNION | FILTER | A | STR | LANG | LANGMATCHES | DATATYPE | BOUND | SAMETERM | ISIRI | ISURI | ISBLANK | ISLITERAL | REGEX | SUBSTR | TRUE | FALSE | LOAD | CLEAR | DROP | ADD | MOVE | COPY | CREATE | DELETE | INSERT | USING | SILENT | DEFAULT | ALL | DATA | WITH | INTO | TO | AS | GROUP | HAVING | UNDEF | BINDINGS | SERVICE | BIND | MINUS_KEYWORD | IRI | URI | BNODE | RAND | ABS | CEIL | FLOOR | ROUND | CONCAT | STRLEN | UCASE | LCASE | ENCODE_FOR_URI | CONTAINS | STRSTARTS | STRENDS | YEAR | MONTH | DAY | HOURS | MINUTES | SECONDS | TIMEZONE | TZ | NOW | MD5 | SHA1 | SHA224 | SHA256 | SHA384 | SHA512 | COALESCE | IF | STRLANG | STRDT | ISNUMERIC | COUNT | SUM_PP | MIN_PP | MAX_PP | AVG | SAMPLE | GROUP_CONCAT | NOT | IN | EXISTS | SEPARATOR | PNAME_NS | PNAME_LN | BLANK_NODE_LABEL | VAR1 | VAR2 | LANGTAG | INTEGER | DECIMAL | DOUBLE_PP | INTEGER_POSITIVE | DECIMAL_POSITIVE | DOUBLE_POSITIVE | INTEGER_NEGATIVE | DECIMAL_NEGATIVE | DOUBLE_NEGATIVE | STRING_LITERAL1 | STRING_LITERAL2 | STRING_LITERAL_LONG1 | STRING_LITERAL_LONG2 | IRI_REF | COMMENT | REFERENCE | LESS_EQUAL | GREATER_EQUAL | NOT_EQUAL | AND | OR | INVERSE | OPEN_BRACE | CLOSE_BRACE | OPEN_CURLY_BRACE | CLOSE_CURLY_BRACE | OPEN_SQUARE_BRACKET | CLOSE_SQUARE_BRACKET | SEMICOLON | DOT | PLUS | MINUS | ASTERISK | QUESTION_MARK | COMMA | NEGATION | DIVIDE | EQUAL | GREATER | PIPE | ANY );";
    EXCEPTION->decisionNum  = 34;
    EXCEPTION->state        = _s;
    return -1;
}


/* Declare tracking structure for Cyclic DFA 34
 */
static
ANTLR3_CYCLIC_DFA cdfa34
    =	{
	    34,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const pANTLR3_UCHAR)"1:1: Tokens : ( WS | BASE | PREFIX | SELECT | DISTINCT | REDUCED | CONSTRUCT | DESCRIBE | ASK | FROM | NAMED | WHERE | ORDER | BY | ASC | DESC | LIMIT | OFFSET | OPTIONAL | GRAPH_PP | UNION | FILTER | A | STR | LANG | LANGMATCHES | DATATYPE | BOUND | SAMETERM | ISIRI | ISURI | ISBLANK | ISLITERAL | REGEX | SUBSTR | TRUE | FALSE | LOAD | CLEAR | DROP | ADD | MOVE | COPY | CREATE | DELETE | INSERT | USING | SILENT | DEFAULT | ALL | DATA | WITH | INTO | TO | AS | GROUP | HAVING | UNDEF | BINDINGS | SERVICE | BIND | MINUS_KEYWORD | IRI | URI | BNODE | RAND | ABS | CEIL | FLOOR | ROUND | CONCAT | STRLEN | UCASE | LCASE | ENCODE_FOR_URI | CONTAINS | STRSTARTS | STRENDS | YEAR | MONTH | DAY | HOURS | MINUTES | SECONDS | TIMEZONE | TZ | NOW | MD5 | SHA1 | SHA224 | SHA256 | SHA384 | SHA512 | COALESCE | IF | STRLANG | STRDT | ISNUMERIC | COUNT | SUM_PP | MIN_PP | MAX_PP | AVG | SAMPLE | GROUP_CONCAT | NOT | IN | EXISTS | SEPARATOR | PNAME_NS | PNAME_LN | BLANK_NODE_LABEL | VAR1 | VAR2 | LANGTAG | INTEGER | DECIMAL | DOUBLE_PP | INTEGER_POSITIVE | DECIMAL_POSITIVE | DOUBLE_POSITIVE | INTEGER_NEGATIVE | DECIMAL_NEGATIVE | DOUBLE_NEGATIVE | STRING_LITERAL1 | STRING_LITERAL2 | STRING_LITERAL_LONG1 | STRING_LITERAL_LONG2 | IRI_REF | COMMENT | REFERENCE | LESS_EQUAL | GREATER_EQUAL | NOT_EQUAL | AND | OR | INVERSE | OPEN_BRACE | CLOSE_BRACE | OPEN_CURLY_BRACE | CLOSE_CURLY_BRACE | OPEN_SQUARE_BRACKET | CLOSE_SQUARE_BRACKET | SEMICOLON | DOT | PLUS | MINUS | ASTERISK | QUESTION_MARK | COMMA | NEGATION | DIVIDE | EQUAL | GREATER | PIPE | ANY );",
	    (CDFA_SPECIAL_FUNC) dfa34_sst,
	    antlr3dfaspecialTransition,		/* DFA specialTransition is currently just a default function in the runtime */
	    antlr3dfapredict,			/* DFA simulator function is in the runtime */
	    dfa34_eot,	    /* EOT table			    */
	    dfa34_eof,	    /* EOF table			    */
	    dfa34_min,	    /* Minimum tokens for each state    */
	    dfa34_max,	    /* Maximum tokens for each state    */
	    dfa34_accept,	/* Accept table			    */
	    dfa34_special,	/* Special transition states	    */
	    dfa34_transitions	/* Table of transition tables	    */

	};
/* End of Cyclic DFA 34
 * ---------------------
 */ 
/* =========================================================================
 * End of DFA tables for the lexer
 */

/* =========================================================================
 * Functions to match the lexer grammar defined tokens from the input stream
 */

//   Comes from: 683:4: ( ( ' ' | '\\t' | EOL )+ )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start WS
 *
 * Looks to match the characters the constitute the token WS
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mWS(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = WS;


    // Sparql.g:683:4: ( ( ' ' | '\\t' | EOL )+ )
    // Sparql.g:683:6: ( ' ' | '\\t' | EOL )+
    {
        // Sparql.g:683:6: ( ' ' | '\\t' | EOL )+
        {
            int cnt1=0;

            for (;;)
            {
                int alt1=2;
        	switch ( LA(1) )
        	{
        	case '\t':
        	case '\n':
        	case '\r':
        	case ' ':
        		{
        			alt1=1;
        		}
        	    break;

        	}

        	switch (alt1)
        	{
        	    case 1:
        	        // Sparql.g:
        	        {
        	            if ( ((LA(1) >= '\t') && (LA(1) <= '\n')) || LA(1) == '\r' || LA(1) == ' ' )
        	            {
        	                CONSUME();
        	                FAILEDFLAG=ANTLR3_FALSE;

        	            }
        	            else
        	            {
        	                if (BACKTRACKING>0)
        	                {
        	                    FAILEDFLAG = ANTLR3_TRUE;
        	                    return ;
        	                }

        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

        	                LRECOVER();
        	                goto ruleWSEx;
        	            }


        	        }
        	        break;

        	    default:

        		if ( cnt1 >= 1 )
        		{
        		    goto loop1;
        		}
        		if (BACKTRACKING>0)
        		{
        		    FAILEDFLAG = ANTLR3_TRUE;
        		    return ;
        		}

        		/* mismatchedSetEx()
        		 */
        		CONSTRUCTEX();
        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


        		goto ruleWSEx;
        	}
        	cnt1++;
            }
            loop1: ;	/* Jump to here if this rule does not match */
        }

        if ( BACKTRACKING==0 )
        {
             LEXSTATE->channel=HIDDEN; 
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleWSEx; /* Prevent compiler warnings */
    ruleWSEx: ;

}
// $ANTLR end WS

//   Comes from: 685:6: ( ( 'B' | 'b' ) ( 'A' | 'a' ) ( 'S' | 's' ) ( 'E' | 'e' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start BASE
 *
 * Looks to match the characters the constitute the token BASE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mBASE(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = BASE;


    // Sparql.g:685:6: ( ( 'B' | 'b' ) ( 'A' | 'a' ) ( 'S' | 's' ) ( 'E' | 'e' ) )
    // Sparql.g:685:8: ( 'B' | 'b' ) ( 'A' | 'a' ) ( 'S' | 's' ) ( 'E' | 'e' )
    {
        if ( LA(1) == 'B' || LA(1) == 'b' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleBASEEx;
        }


        if ( LA(1) == 'A' || LA(1) == 'a' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleBASEEx;
        }


        if ( LA(1) == 'S' || LA(1) == 's' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleBASEEx;
        }


        if ( LA(1) == 'E' || LA(1) == 'e' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleBASEEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleBASEEx; /* Prevent compiler warnings */
    ruleBASEEx: ;

}
// $ANTLR end BASE

//   Comes from: 687:8: ( ( 'P' | 'p' ) ( 'R' | 'r' ) ( 'E' | 'e' ) ( 'F' | 'f' ) ( 'I' | 'i' ) ( 'X' | 'x' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start PREFIX
 *
 * Looks to match the characters the constitute the token PREFIX
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mPREFIX(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = PREFIX;


    // Sparql.g:687:8: ( ( 'P' | 'p' ) ( 'R' | 'r' ) ( 'E' | 'e' ) ( 'F' | 'f' ) ( 'I' | 'i' ) ( 'X' | 'x' ) )
    // Sparql.g:687:10: ( 'P' | 'p' ) ( 'R' | 'r' ) ( 'E' | 'e' ) ( 'F' | 'f' ) ( 'I' | 'i' ) ( 'X' | 'x' )
    {
        if ( LA(1) == 'P' || LA(1) == 'p' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto rulePREFIXEx;
        }


        if ( LA(1) == 'R' || LA(1) == 'r' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto rulePREFIXEx;
        }


        if ( LA(1) == 'E' || LA(1) == 'e' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto rulePREFIXEx;
        }


        if ( LA(1) == 'F' || LA(1) == 'f' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto rulePREFIXEx;
        }


        if ( LA(1) == 'I' || LA(1) == 'i' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto rulePREFIXEx;
        }


        if ( LA(1) == 'X' || LA(1) == 'x' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto rulePREFIXEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto rulePREFIXEx; /* Prevent compiler warnings */
    rulePREFIXEx: ;

}
// $ANTLR end PREFIX

//   Comes from: 689:8: ( ( 'S' | 's' ) ( 'E' | 'e' ) ( 'L' | 'l' ) ( 'E' | 'e' ) ( 'C' | 'c' ) ( 'T' | 't' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SELECT
 *
 * Looks to match the characters the constitute the token SELECT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mSELECT(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = SELECT;


    // Sparql.g:689:8: ( ( 'S' | 's' ) ( 'E' | 'e' ) ( 'L' | 'l' ) ( 'E' | 'e' ) ( 'C' | 'c' ) ( 'T' | 't' ) )
    // Sparql.g:689:10: ( 'S' | 's' ) ( 'E' | 'e' ) ( 'L' | 'l' ) ( 'E' | 'e' ) ( 'C' | 'c' ) ( 'T' | 't' )
    {
        if ( LA(1) == 'S' || LA(1) == 's' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleSELECTEx;
        }


        if ( LA(1) == 'E' || LA(1) == 'e' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleSELECTEx;
        }


        if ( LA(1) == 'L' || LA(1) == 'l' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleSELECTEx;
        }


        if ( LA(1) == 'E' || LA(1) == 'e' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleSELECTEx;
        }


        if ( LA(1) == 'C' || LA(1) == 'c' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleSELECTEx;
        }


        if ( LA(1) == 'T' || LA(1) == 't' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleSELECTEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleSELECTEx; /* Prevent compiler warnings */
    ruleSELECTEx: ;

}
// $ANTLR end SELECT

//   Comes from: 691:10: ( ( 'D' | 'd' ) ( 'I' | 'i' ) ( 'S' | 's' ) ( 'T' | 't' ) ( 'I' | 'i' ) ( 'N' | 'n' ) ( 'C' | 'c' ) ( 'T' | 't' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start DISTINCT
 *
 * Looks to match the characters the constitute the token DISTINCT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mDISTINCT(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = DISTINCT;


    // Sparql.g:691:10: ( ( 'D' | 'd' ) ( 'I' | 'i' ) ( 'S' | 's' ) ( 'T' | 't' ) ( 'I' | 'i' ) ( 'N' | 'n' ) ( 'C' | 'c' ) ( 'T' | 't' ) )
    // Sparql.g:691:12: ( 'D' | 'd' ) ( 'I' | 'i' ) ( 'S' | 's' ) ( 'T' | 't' ) ( 'I' | 'i' ) ( 'N' | 'n' ) ( 'C' | 'c' ) ( 'T' | 't' )
    {
        if ( LA(1) == 'D' || LA(1) == 'd' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleDISTINCTEx;
        }


        if ( LA(1) == 'I' || LA(1) == 'i' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleDISTINCTEx;
        }


        if ( LA(1) == 'S' || LA(1) == 's' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleDISTINCTEx;
        }


        if ( LA(1) == 'T' || LA(1) == 't' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleDISTINCTEx;
        }


        if ( LA(1) == 'I' || LA(1) == 'i' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleDISTINCTEx;
        }


        if ( LA(1) == 'N' || LA(1) == 'n' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleDISTINCTEx;
        }


        if ( LA(1) == 'C' || LA(1) == 'c' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleDISTINCTEx;
        }


        if ( LA(1) == 'T' || LA(1) == 't' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleDISTINCTEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleDISTINCTEx; /* Prevent compiler warnings */
    ruleDISTINCTEx: ;

}
// $ANTLR end DISTINCT

//   Comes from: 693:9: ( ( 'R' | 'r' ) ( 'E' | 'e' ) ( 'D' | 'd' ) ( 'U' | 'u' ) ( 'C' | 'c' ) ( 'E' | 'e' ) ( 'D' | 'd' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start REDUCED
 *
 * Looks to match the characters the constitute the token REDUCED
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mREDUCED(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = REDUCED;


    // Sparql.g:693:9: ( ( 'R' | 'r' ) ( 'E' | 'e' ) ( 'D' | 'd' ) ( 'U' | 'u' ) ( 'C' | 'c' ) ( 'E' | 'e' ) ( 'D' | 'd' ) )
    // Sparql.g:693:11: ( 'R' | 'r' ) ( 'E' | 'e' ) ( 'D' | 'd' ) ( 'U' | 'u' ) ( 'C' | 'c' ) ( 'E' | 'e' ) ( 'D' | 'd' )
    {
        if ( LA(1) == 'R' || LA(1) == 'r' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleREDUCEDEx;
        }


        if ( LA(1) == 'E' || LA(1) == 'e' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleREDUCEDEx;
        }


        if ( LA(1) == 'D' || LA(1) == 'd' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleREDUCEDEx;
        }


        if ( LA(1) == 'U' || LA(1) == 'u' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleREDUCEDEx;
        }


        if ( LA(1) == 'C' || LA(1) == 'c' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleREDUCEDEx;
        }


        if ( LA(1) == 'E' || LA(1) == 'e' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleREDUCEDEx;
        }


        if ( LA(1) == 'D' || LA(1) == 'd' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleREDUCEDEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleREDUCEDEx; /* Prevent compiler warnings */
    ruleREDUCEDEx: ;

}
// $ANTLR end REDUCED

//   Comes from: 695:11: ( ( 'C' | 'c' ) ( 'O' | 'o' ) ( 'N' | 'n' ) ( 'S' | 's' ) ( 'T' | 't' ) ( 'R' | 'r' ) ( 'U' | 'u' ) ( 'C' | 'c' ) ( 'T' | 't' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start CONSTRUCT
 *
 * Looks to match the characters the constitute the token CONSTRUCT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mCONSTRUCT(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = CONSTRUCT;


    // Sparql.g:695:11: ( ( 'C' | 'c' ) ( 'O' | 'o' ) ( 'N' | 'n' ) ( 'S' | 's' ) ( 'T' | 't' ) ( 'R' | 'r' ) ( 'U' | 'u' ) ( 'C' | 'c' ) ( 'T' | 't' ) )
    // Sparql.g:695:13: ( 'C' | 'c' ) ( 'O' | 'o' ) ( 'N' | 'n' ) ( 'S' | 's' ) ( 'T' | 't' ) ( 'R' | 'r' ) ( 'U' | 'u' ) ( 'C' | 'c' ) ( 'T' | 't' )
    {
        if ( LA(1) == 'C' || LA(1) == 'c' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleCONSTRUCTEx;
        }


        if ( LA(1) == 'O' || LA(1) == 'o' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleCONSTRUCTEx;
        }


        if ( LA(1) == 'N' || LA(1) == 'n' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleCONSTRUCTEx;
        }


        if ( LA(1) == 'S' || LA(1) == 's' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleCONSTRUCTEx;
        }


        if ( LA(1) == 'T' || LA(1) == 't' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleCONSTRUCTEx;
        }


        if ( LA(1) == 'R' || LA(1) == 'r' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleCONSTRUCTEx;
        }


        if ( LA(1) == 'U' || LA(1) == 'u' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleCONSTRUCTEx;
        }


        if ( LA(1) == 'C' || LA(1) == 'c' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleCONSTRUCTEx;
        }


        if ( LA(1) == 'T' || LA(1) == 't' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleCONSTRUCTEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleCONSTRUCTEx; /* Prevent compiler warnings */
    ruleCONSTRUCTEx: ;

}
// $ANTLR end CONSTRUCT

//   Comes from: 697:10: ( ( 'D' | 'd' ) ( 'E' | 'e' ) ( 'S' | 's' ) ( 'C' | 'c' ) ( 'R' | 'r' ) ( 'I' | 'i' ) ( 'B' | 'b' ) ( 'E' | 'e' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start DESCRIBE
 *
 * Looks to match the characters the constitute the token DESCRIBE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mDESCRIBE(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = DESCRIBE;


    // Sparql.g:697:10: ( ( 'D' | 'd' ) ( 'E' | 'e' ) ( 'S' | 's' ) ( 'C' | 'c' ) ( 'R' | 'r' ) ( 'I' | 'i' ) ( 'B' | 'b' ) ( 'E' | 'e' ) )
    // Sparql.g:697:12: ( 'D' | 'd' ) ( 'E' | 'e' ) ( 'S' | 's' ) ( 'C' | 'c' ) ( 'R' | 'r' ) ( 'I' | 'i' ) ( 'B' | 'b' ) ( 'E' | 'e' )
    {
        if ( LA(1) == 'D' || LA(1) == 'd' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleDESCRIBEEx;
        }


        if ( LA(1) == 'E' || LA(1) == 'e' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleDESCRIBEEx;
        }


        if ( LA(1) == 'S' || LA(1) == 's' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleDESCRIBEEx;
        }


        if ( LA(1) == 'C' || LA(1) == 'c' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleDESCRIBEEx;
        }


        if ( LA(1) == 'R' || LA(1) == 'r' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleDESCRIBEEx;
        }


        if ( LA(1) == 'I' || LA(1) == 'i' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleDESCRIBEEx;
        }


        if ( LA(1) == 'B' || LA(1) == 'b' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleDESCRIBEEx;
        }


        if ( LA(1) == 'E' || LA(1) == 'e' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleDESCRIBEEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleDESCRIBEEx; /* Prevent compiler warnings */
    ruleDESCRIBEEx: ;

}
// $ANTLR end DESCRIBE

//   Comes from: 699:5: ( ( 'A' | 'a' ) ( 'S' | 's' ) ( 'K' | 'k' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start ASK
 *
 * Looks to match the characters the constitute the token ASK
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mASK(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = ASK;


    // Sparql.g:699:5: ( ( 'A' | 'a' ) ( 'S' | 's' ) ( 'K' | 'k' ) )
    // Sparql.g:699:7: ( 'A' | 'a' ) ( 'S' | 's' ) ( 'K' | 'k' )
    {
        if ( LA(1) == 'A' || LA(1) == 'a' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleASKEx;
        }


        if ( LA(1) == 'S' || LA(1) == 's' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleASKEx;
        }


        if ( LA(1) == 'K' || LA(1) == 'k' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleASKEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleASKEx; /* Prevent compiler warnings */
    ruleASKEx: ;

}
// $ANTLR end ASK

//   Comes from: 701:6: ( ( 'F' | 'f' ) ( 'R' | 'r' ) ( 'O' | 'o' ) ( 'M' | 'm' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start FROM
 *
 * Looks to match the characters the constitute the token FROM
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mFROM(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = FROM;


    // Sparql.g:701:6: ( ( 'F' | 'f' ) ( 'R' | 'r' ) ( 'O' | 'o' ) ( 'M' | 'm' ) )
    // Sparql.g:701:8: ( 'F' | 'f' ) ( 'R' | 'r' ) ( 'O' | 'o' ) ( 'M' | 'm' )
    {
        if ( LA(1) == 'F' || LA(1) == 'f' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleFROMEx;
        }


        if ( LA(1) == 'R' || LA(1) == 'r' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleFROMEx;
        }


        if ( LA(1) == 'O' || LA(1) == 'o' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleFROMEx;
        }


        if ( LA(1) == 'M' || LA(1) == 'm' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleFROMEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleFROMEx; /* Prevent compiler warnings */
    ruleFROMEx: ;

}
// $ANTLR end FROM

//   Comes from: 703:7: ( ( 'N' | 'n' ) ( 'A' | 'a' ) ( 'M' | 'm' ) ( 'E' | 'e' ) ( 'D' | 'd' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start NAMED
 *
 * Looks to match the characters the constitute the token NAMED
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mNAMED(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = NAMED;


    // Sparql.g:703:7: ( ( 'N' | 'n' ) ( 'A' | 'a' ) ( 'M' | 'm' ) ( 'E' | 'e' ) ( 'D' | 'd' ) )
    // Sparql.g:703:9: ( 'N' | 'n' ) ( 'A' | 'a' ) ( 'M' | 'm' ) ( 'E' | 'e' ) ( 'D' | 'd' )
    {
        if ( LA(1) == 'N' || LA(1) == 'n' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleNAMEDEx;
        }


        if ( LA(1) == 'A' || LA(1) == 'a' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleNAMEDEx;
        }


        if ( LA(1) == 'M' || LA(1) == 'm' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleNAMEDEx;
        }


        if ( LA(1) == 'E' || LA(1) == 'e' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleNAMEDEx;
        }


        if ( LA(1) == 'D' || LA(1) == 'd' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleNAMEDEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleNAMEDEx; /* Prevent compiler warnings */
    ruleNAMEDEx: ;

}
// $ANTLR end NAMED

//   Comes from: 705:7: ( ( 'W' | 'w' ) ( 'H' | 'h' ) ( 'E' | 'e' ) ( 'R' | 'r' ) ( 'E' | 'e' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start WHERE
 *
 * Looks to match the characters the constitute the token WHERE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mWHERE(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = WHERE;


    // Sparql.g:705:7: ( ( 'W' | 'w' ) ( 'H' | 'h' ) ( 'E' | 'e' ) ( 'R' | 'r' ) ( 'E' | 'e' ) )
    // Sparql.g:705:9: ( 'W' | 'w' ) ( 'H' | 'h' ) ( 'E' | 'e' ) ( 'R' | 'r' ) ( 'E' | 'e' )
    {
        if ( LA(1) == 'W' || LA(1) == 'w' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleWHEREEx;
        }


        if ( LA(1) == 'H' || LA(1) == 'h' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleWHEREEx;
        }


        if ( LA(1) == 'E' || LA(1) == 'e' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleWHEREEx;
        }


        if ( LA(1) == 'R' || LA(1) == 'r' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleWHEREEx;
        }


        if ( LA(1) == 'E' || LA(1) == 'e' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleWHEREEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleWHEREEx; /* Prevent compiler warnings */
    ruleWHEREEx: ;

}
// $ANTLR end WHERE

//   Comes from: 707:7: ( ( 'O' | 'o' ) ( 'R' | 'r' ) ( 'D' | 'd' ) ( 'E' | 'e' ) ( 'R' | 'r' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start ORDER
 *
 * Looks to match the characters the constitute the token ORDER
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mORDER(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = ORDER;


    // Sparql.g:707:7: ( ( 'O' | 'o' ) ( 'R' | 'r' ) ( 'D' | 'd' ) ( 'E' | 'e' ) ( 'R' | 'r' ) )
    // Sparql.g:707:9: ( 'O' | 'o' ) ( 'R' | 'r' ) ( 'D' | 'd' ) ( 'E' | 'e' ) ( 'R' | 'r' )
    {
        if ( LA(1) == 'O' || LA(1) == 'o' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleORDEREx;
        }


        if ( LA(1) == 'R' || LA(1) == 'r' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleORDEREx;
        }


        if ( LA(1) == 'D' || LA(1) == 'd' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleORDEREx;
        }


        if ( LA(1) == 'E' || LA(1) == 'e' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleORDEREx;
        }


        if ( LA(1) == 'R' || LA(1) == 'r' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleORDEREx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleORDEREx; /* Prevent compiler warnings */
    ruleORDEREx: ;

}
// $ANTLR end ORDER

//   Comes from: 709:4: ( ( 'B' | 'b' ) ( 'Y' | 'y' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start BY
 *
 * Looks to match the characters the constitute the token BY
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mBY(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = BY;


    // Sparql.g:709:4: ( ( 'B' | 'b' ) ( 'Y' | 'y' ) )
    // Sparql.g:709:6: ( 'B' | 'b' ) ( 'Y' | 'y' )
    {
        if ( LA(1) == 'B' || LA(1) == 'b' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleBYEx;
        }


        if ( LA(1) == 'Y' || LA(1) == 'y' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleBYEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleBYEx; /* Prevent compiler warnings */
    ruleBYEx: ;

}
// $ANTLR end BY

//   Comes from: 711:5: ( ( 'A' | 'a' ) ( 'S' | 's' ) ( 'C' | 'c' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start ASC
 *
 * Looks to match the characters the constitute the token ASC
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mASC(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = ASC;


    // Sparql.g:711:5: ( ( 'A' | 'a' ) ( 'S' | 's' ) ( 'C' | 'c' ) )
    // Sparql.g:711:7: ( 'A' | 'a' ) ( 'S' | 's' ) ( 'C' | 'c' )
    {
        if ( LA(1) == 'A' || LA(1) == 'a' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleASCEx;
        }


        if ( LA(1) == 'S' || LA(1) == 's' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleASCEx;
        }


        if ( LA(1) == 'C' || LA(1) == 'c' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleASCEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleASCEx; /* Prevent compiler warnings */
    ruleASCEx: ;

}
// $ANTLR end ASC

//   Comes from: 713:6: ( ( 'D' | 'd' ) ( 'E' | 'e' ) ( 'S' | 's' ) ( 'C' | 'c' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start DESC
 *
 * Looks to match the characters the constitute the token DESC
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mDESC(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = DESC;


    // Sparql.g:713:6: ( ( 'D' | 'd' ) ( 'E' | 'e' ) ( 'S' | 's' ) ( 'C' | 'c' ) )
    // Sparql.g:713:8: ( 'D' | 'd' ) ( 'E' | 'e' ) ( 'S' | 's' ) ( 'C' | 'c' )
    {
        if ( LA(1) == 'D' || LA(1) == 'd' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleDESCEx;
        }


        if ( LA(1) == 'E' || LA(1) == 'e' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleDESCEx;
        }


        if ( LA(1) == 'S' || LA(1) == 's' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleDESCEx;
        }


        if ( LA(1) == 'C' || LA(1) == 'c' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleDESCEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleDESCEx; /* Prevent compiler warnings */
    ruleDESCEx: ;

}
// $ANTLR end DESC

//   Comes from: 715:7: ( ( 'L' | 'l' ) ( 'I' | 'i' ) ( 'M' | 'm' ) ( 'I' | 'i' ) ( 'T' | 't' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start LIMIT
 *
 * Looks to match the characters the constitute the token LIMIT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mLIMIT(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = LIMIT;


    // Sparql.g:715:7: ( ( 'L' | 'l' ) ( 'I' | 'i' ) ( 'M' | 'm' ) ( 'I' | 'i' ) ( 'T' | 't' ) )
    // Sparql.g:715:9: ( 'L' | 'l' ) ( 'I' | 'i' ) ( 'M' | 'm' ) ( 'I' | 'i' ) ( 'T' | 't' )
    {
        if ( LA(1) == 'L' || LA(1) == 'l' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleLIMITEx;
        }


        if ( LA(1) == 'I' || LA(1) == 'i' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleLIMITEx;
        }


        if ( LA(1) == 'M' || LA(1) == 'm' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleLIMITEx;
        }


        if ( LA(1) == 'I' || LA(1) == 'i' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleLIMITEx;
        }


        if ( LA(1) == 'T' || LA(1) == 't' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleLIMITEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleLIMITEx; /* Prevent compiler warnings */
    ruleLIMITEx: ;

}
// $ANTLR end LIMIT

//   Comes from: 717:8: ( ( 'O' | 'o' ) ( 'F' | 'f' ) ( 'F' | 'f' ) ( 'S' | 's' ) ( 'E' | 'e' ) ( 'T' | 't' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start OFFSET
 *
 * Looks to match the characters the constitute the token OFFSET
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mOFFSET(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = OFFSET;


    // Sparql.g:717:8: ( ( 'O' | 'o' ) ( 'F' | 'f' ) ( 'F' | 'f' ) ( 'S' | 's' ) ( 'E' | 'e' ) ( 'T' | 't' ) )
    // Sparql.g:717:10: ( 'O' | 'o' ) ( 'F' | 'f' ) ( 'F' | 'f' ) ( 'S' | 's' ) ( 'E' | 'e' ) ( 'T' | 't' )
    {
        if ( LA(1) == 'O' || LA(1) == 'o' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleOFFSETEx;
        }


        if ( LA(1) == 'F' || LA(1) == 'f' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleOFFSETEx;
        }


        if ( LA(1) == 'F' || LA(1) == 'f' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleOFFSETEx;
        }


        if ( LA(1) == 'S' || LA(1) == 's' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleOFFSETEx;
        }


        if ( LA(1) == 'E' || LA(1) == 'e' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleOFFSETEx;
        }


        if ( LA(1) == 'T' || LA(1) == 't' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleOFFSETEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleOFFSETEx; /* Prevent compiler warnings */
    ruleOFFSETEx: ;

}
// $ANTLR end OFFSET

//   Comes from: 719:10: ( ( 'O' | 'o' ) ( 'P' | 'p' ) ( 'T' | 't' ) ( 'I' | 'i' ) ( 'O' | 'o' ) ( 'N' | 'n' ) ( 'A' | 'a' ) ( 'L' | 'l' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start OPTIONAL
 *
 * Looks to match the characters the constitute the token OPTIONAL
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mOPTIONAL(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = OPTIONAL;


    // Sparql.g:719:10: ( ( 'O' | 'o' ) ( 'P' | 'p' ) ( 'T' | 't' ) ( 'I' | 'i' ) ( 'O' | 'o' ) ( 'N' | 'n' ) ( 'A' | 'a' ) ( 'L' | 'l' ) )
    // Sparql.g:719:12: ( 'O' | 'o' ) ( 'P' | 'p' ) ( 'T' | 't' ) ( 'I' | 'i' ) ( 'O' | 'o' ) ( 'N' | 'n' ) ( 'A' | 'a' ) ( 'L' | 'l' )
    {
        if ( LA(1) == 'O' || LA(1) == 'o' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleOPTIONALEx;
        }


        if ( LA(1) == 'P' || LA(1) == 'p' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleOPTIONALEx;
        }


        if ( LA(1) == 'T' || LA(1) == 't' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleOPTIONALEx;
        }


        if ( LA(1) == 'I' || LA(1) == 'i' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleOPTIONALEx;
        }


        if ( LA(1) == 'O' || LA(1) == 'o' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleOPTIONALEx;
        }


        if ( LA(1) == 'N' || LA(1) == 'n' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleOPTIONALEx;
        }


        if ( LA(1) == 'A' || LA(1) == 'a' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleOPTIONALEx;
        }


        if ( LA(1) == 'L' || LA(1) == 'l' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleOPTIONALEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleOPTIONALEx; /* Prevent compiler warnings */
    ruleOPTIONALEx: ;

}
// $ANTLR end OPTIONAL

//   Comes from: 721:7: ( ( 'G' | 'g' ) ( 'R' | 'r' ) ( 'A' | 'a' ) ( 'P' | 'p' ) ( 'H' | 'h' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start GRAPH
 *
 * Looks to match the characters the constitute the token GRAPH
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mGRAPH(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = GRAPH_PP;


    // Sparql.g:721:7: ( ( 'G' | 'g' ) ( 'R' | 'r' ) ( 'A' | 'a' ) ( 'P' | 'p' ) ( 'H' | 'h' ) )
    // Sparql.g:721:9: ( 'G' | 'g' ) ( 'R' | 'r' ) ( 'A' | 'a' ) ( 'P' | 'p' ) ( 'H' | 'h' )
    {
        if ( LA(1) == 'G' || LA(1) == 'g' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleGRAPHEx;
        }


        if ( LA(1) == 'R' || LA(1) == 'r' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleGRAPHEx;
        }


        if ( LA(1) == 'A' || LA(1) == 'a' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleGRAPHEx;
        }


        if ( LA(1) == 'P' || LA(1) == 'p' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleGRAPHEx;
        }


        if ( LA(1) == 'H' || LA(1) == 'h' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleGRAPHEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleGRAPHEx; /* Prevent compiler warnings */
    ruleGRAPHEx: ;

}
// $ANTLR end GRAPH

//   Comes from: 723:7: ( ( 'U' | 'u' ) ( 'N' | 'n' ) ( 'I' | 'i' ) ( 'O' | 'o' ) ( 'N' | 'n' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start UNION
 *
 * Looks to match the characters the constitute the token UNION
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mUNION(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = UNION;


    // Sparql.g:723:7: ( ( 'U' | 'u' ) ( 'N' | 'n' ) ( 'I' | 'i' ) ( 'O' | 'o' ) ( 'N' | 'n' ) )
    // Sparql.g:723:9: ( 'U' | 'u' ) ( 'N' | 'n' ) ( 'I' | 'i' ) ( 'O' | 'o' ) ( 'N' | 'n' )
    {
        if ( LA(1) == 'U' || LA(1) == 'u' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleUNIONEx;
        }


        if ( LA(1) == 'N' || LA(1) == 'n' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleUNIONEx;
        }


        if ( LA(1) == 'I' || LA(1) == 'i' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleUNIONEx;
        }


        if ( LA(1) == 'O' || LA(1) == 'o' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleUNIONEx;
        }


        if ( LA(1) == 'N' || LA(1) == 'n' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleUNIONEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleUNIONEx; /* Prevent compiler warnings */
    ruleUNIONEx: ;

}
// $ANTLR end UNION

//   Comes from: 725:8: ( ( 'F' | 'f' ) ( 'I' | 'i' ) ( 'L' | 'l' ) ( 'T' | 't' ) ( 'E' | 'e' ) ( 'R' | 'r' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start FILTER
 *
 * Looks to match the characters the constitute the token FILTER
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mFILTER(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = FILTER;


    // Sparql.g:725:8: ( ( 'F' | 'f' ) ( 'I' | 'i' ) ( 'L' | 'l' ) ( 'T' | 't' ) ( 'E' | 'e' ) ( 'R' | 'r' ) )
    // Sparql.g:725:10: ( 'F' | 'f' ) ( 'I' | 'i' ) ( 'L' | 'l' ) ( 'T' | 't' ) ( 'E' | 'e' ) ( 'R' | 'r' )
    {
        if ( LA(1) == 'F' || LA(1) == 'f' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleFILTEREx;
        }


        if ( LA(1) == 'I' || LA(1) == 'i' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleFILTEREx;
        }


        if ( LA(1) == 'L' || LA(1) == 'l' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleFILTEREx;
        }


        if ( LA(1) == 'T' || LA(1) == 't' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleFILTEREx;
        }


        if ( LA(1) == 'E' || LA(1) == 'e' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleFILTEREx;
        }


        if ( LA(1) == 'R' || LA(1) == 'r' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleFILTEREx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleFILTEREx; /* Prevent compiler warnings */
    ruleFILTEREx: ;

}
// $ANTLR end FILTER

//   Comes from: 727:3: ( 'a' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start A
 *
 * Looks to match the characters the constitute the token A
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mA(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = A;


    // Sparql.g:727:3: ( 'a' )
    // Sparql.g:727:5: 'a'
    {
        MATCHC('a');
        if  (HASEXCEPTION())
        {
            goto ruleAEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleAEx; /* Prevent compiler warnings */
    ruleAEx: ;

}
// $ANTLR end A

//   Comes from: 729:5: ( ( 'S' | 's' ) ( 'T' | 't' ) ( 'R' | 'r' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start STR
 *
 * Looks to match the characters the constitute the token STR
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mSTR(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = STR;


    // Sparql.g:729:5: ( ( 'S' | 's' ) ( 'T' | 't' ) ( 'R' | 'r' ) )
    // Sparql.g:729:7: ( 'S' | 's' ) ( 'T' | 't' ) ( 'R' | 'r' )
    {
        if ( LA(1) == 'S' || LA(1) == 's' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleSTREx;
        }


        if ( LA(1) == 'T' || LA(1) == 't' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleSTREx;
        }


        if ( LA(1) == 'R' || LA(1) == 'r' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleSTREx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleSTREx; /* Prevent compiler warnings */
    ruleSTREx: ;

}
// $ANTLR end STR

//   Comes from: 731:6: ( ( 'L' | 'l' ) ( 'A' | 'a' ) ( 'N' | 'n' ) ( 'G' | 'g' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start LANG
 *
 * Looks to match the characters the constitute the token LANG
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mLANG(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = LANG;


    // Sparql.g:731:6: ( ( 'L' | 'l' ) ( 'A' | 'a' ) ( 'N' | 'n' ) ( 'G' | 'g' ) )
    // Sparql.g:731:8: ( 'L' | 'l' ) ( 'A' | 'a' ) ( 'N' | 'n' ) ( 'G' | 'g' )
    {
        if ( LA(1) == 'L' || LA(1) == 'l' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleLANGEx;
        }


        if ( LA(1) == 'A' || LA(1) == 'a' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleLANGEx;
        }


        if ( LA(1) == 'N' || LA(1) == 'n' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleLANGEx;
        }


        if ( LA(1) == 'G' || LA(1) == 'g' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleLANGEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleLANGEx; /* Prevent compiler warnings */
    ruleLANGEx: ;

}
// $ANTLR end LANG

//   Comes from: 733:13: ( ( 'L' | 'l' ) ( 'A' | 'a' ) ( 'N' | 'n' ) ( 'G' | 'g' ) ( 'M' | 'm' ) ( 'A' | 'a' ) ( 'T' | 't' ) ( 'C' | 'c' ) ( 'H' | 'h' ) ( 'E' | 'e' ) ( 'S' | 's' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start LANGMATCHES
 *
 * Looks to match the characters the constitute the token LANGMATCHES
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mLANGMATCHES(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = LANGMATCHES;


    // Sparql.g:733:13: ( ( 'L' | 'l' ) ( 'A' | 'a' ) ( 'N' | 'n' ) ( 'G' | 'g' ) ( 'M' | 'm' ) ( 'A' | 'a' ) ( 'T' | 't' ) ( 'C' | 'c' ) ( 'H' | 'h' ) ( 'E' | 'e' ) ( 'S' | 's' ) )
    // Sparql.g:733:15: ( 'L' | 'l' ) ( 'A' | 'a' ) ( 'N' | 'n' ) ( 'G' | 'g' ) ( 'M' | 'm' ) ( 'A' | 'a' ) ( 'T' | 't' ) ( 'C' | 'c' ) ( 'H' | 'h' ) ( 'E' | 'e' ) ( 'S' | 's' )
    {
        if ( LA(1) == 'L' || LA(1) == 'l' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleLANGMATCHESEx;
        }


        if ( LA(1) == 'A' || LA(1) == 'a' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleLANGMATCHESEx;
        }


        if ( LA(1) == 'N' || LA(1) == 'n' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleLANGMATCHESEx;
        }


        if ( LA(1) == 'G' || LA(1) == 'g' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleLANGMATCHESEx;
        }


        if ( LA(1) == 'M' || LA(1) == 'm' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleLANGMATCHESEx;
        }


        if ( LA(1) == 'A' || LA(1) == 'a' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleLANGMATCHESEx;
        }


        if ( LA(1) == 'T' || LA(1) == 't' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleLANGMATCHESEx;
        }


        if ( LA(1) == 'C' || LA(1) == 'c' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleLANGMATCHESEx;
        }


        if ( LA(1) == 'H' || LA(1) == 'h' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleLANGMATCHESEx;
        }


        if ( LA(1) == 'E' || LA(1) == 'e' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleLANGMATCHESEx;
        }


        if ( LA(1) == 'S' || LA(1) == 's' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleLANGMATCHESEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleLANGMATCHESEx; /* Prevent compiler warnings */
    ruleLANGMATCHESEx: ;

}
// $ANTLR end LANGMATCHES

//   Comes from: 735:10: ( ( 'D' | 'd' ) ( 'A' | 'a' ) ( 'T' | 't' ) ( 'A' | 'a' ) ( 'T' | 't' ) ( 'Y' | 'y' ) ( 'P' | 'p' ) ( 'E' | 'e' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start DATATYPE
 *
 * Looks to match the characters the constitute the token DATATYPE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mDATATYPE(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = DATATYPE;


    // Sparql.g:735:10: ( ( 'D' | 'd' ) ( 'A' | 'a' ) ( 'T' | 't' ) ( 'A' | 'a' ) ( 'T' | 't' ) ( 'Y' | 'y' ) ( 'P' | 'p' ) ( 'E' | 'e' ) )
    // Sparql.g:735:12: ( 'D' | 'd' ) ( 'A' | 'a' ) ( 'T' | 't' ) ( 'A' | 'a' ) ( 'T' | 't' ) ( 'Y' | 'y' ) ( 'P' | 'p' ) ( 'E' | 'e' )
    {
        if ( LA(1) == 'D' || LA(1) == 'd' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleDATATYPEEx;
        }


        if ( LA(1) == 'A' || LA(1) == 'a' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleDATATYPEEx;
        }


        if ( LA(1) == 'T' || LA(1) == 't' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleDATATYPEEx;
        }


        if ( LA(1) == 'A' || LA(1) == 'a' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleDATATYPEEx;
        }


        if ( LA(1) == 'T' || LA(1) == 't' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleDATATYPEEx;
        }


        if ( LA(1) == 'Y' || LA(1) == 'y' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleDATATYPEEx;
        }


        if ( LA(1) == 'P' || LA(1) == 'p' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleDATATYPEEx;
        }


        if ( LA(1) == 'E' || LA(1) == 'e' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleDATATYPEEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleDATATYPEEx; /* Prevent compiler warnings */
    ruleDATATYPEEx: ;

}
// $ANTLR end DATATYPE

//   Comes from: 737:7: ( ( 'B' | 'b' ) ( 'O' | 'o' ) ( 'U' | 'u' ) ( 'N' | 'n' ) ( 'D' | 'd' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start BOUND
 *
 * Looks to match the characters the constitute the token BOUND
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mBOUND(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = BOUND;


    // Sparql.g:737:7: ( ( 'B' | 'b' ) ( 'O' | 'o' ) ( 'U' | 'u' ) ( 'N' | 'n' ) ( 'D' | 'd' ) )
    // Sparql.g:737:9: ( 'B' | 'b' ) ( 'O' | 'o' ) ( 'U' | 'u' ) ( 'N' | 'n' ) ( 'D' | 'd' )
    {
        if ( LA(1) == 'B' || LA(1) == 'b' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleBOUNDEx;
        }


        if ( LA(1) == 'O' || LA(1) == 'o' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleBOUNDEx;
        }


        if ( LA(1) == 'U' || LA(1) == 'u' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleBOUNDEx;
        }


        if ( LA(1) == 'N' || LA(1) == 'n' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleBOUNDEx;
        }


        if ( LA(1) == 'D' || LA(1) == 'd' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleBOUNDEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleBOUNDEx; /* Prevent compiler warnings */
    ruleBOUNDEx: ;

}
// $ANTLR end BOUND

//   Comes from: 739:10: ( ( 'S' | 's' ) ( 'A' | 'a' ) ( 'M' | 'm' ) ( 'E' | 'e' ) ( 'T' | 't' ) ( 'E' | 'e' ) ( 'R' | 'r' ) ( 'M' | 'm' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SAMETERM
 *
 * Looks to match the characters the constitute the token SAMETERM
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mSAMETERM(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = SAMETERM;


    // Sparql.g:739:10: ( ( 'S' | 's' ) ( 'A' | 'a' ) ( 'M' | 'm' ) ( 'E' | 'e' ) ( 'T' | 't' ) ( 'E' | 'e' ) ( 'R' | 'r' ) ( 'M' | 'm' ) )
    // Sparql.g:739:12: ( 'S' | 's' ) ( 'A' | 'a' ) ( 'M' | 'm' ) ( 'E' | 'e' ) ( 'T' | 't' ) ( 'E' | 'e' ) ( 'R' | 'r' ) ( 'M' | 'm' )
    {
        if ( LA(1) == 'S' || LA(1) == 's' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleSAMETERMEx;
        }


        if ( LA(1) == 'A' || LA(1) == 'a' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleSAMETERMEx;
        }


        if ( LA(1) == 'M' || LA(1) == 'm' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleSAMETERMEx;
        }


        if ( LA(1) == 'E' || LA(1) == 'e' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleSAMETERMEx;
        }


        if ( LA(1) == 'T' || LA(1) == 't' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleSAMETERMEx;
        }


        if ( LA(1) == 'E' || LA(1) == 'e' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleSAMETERMEx;
        }


        if ( LA(1) == 'R' || LA(1) == 'r' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleSAMETERMEx;
        }


        if ( LA(1) == 'M' || LA(1) == 'm' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleSAMETERMEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleSAMETERMEx; /* Prevent compiler warnings */
    ruleSAMETERMEx: ;

}
// $ANTLR end SAMETERM

//   Comes from: 741:7: ( ( 'I' | 'i' ) ( 'S' | 's' ) ( 'I' | 'i' ) ( 'R' | 'r' ) ( 'I' | 'i' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start ISIRI
 *
 * Looks to match the characters the constitute the token ISIRI
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mISIRI(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = ISIRI;


    // Sparql.g:741:7: ( ( 'I' | 'i' ) ( 'S' | 's' ) ( 'I' | 'i' ) ( 'R' | 'r' ) ( 'I' | 'i' ) )
    // Sparql.g:741:9: ( 'I' | 'i' ) ( 'S' | 's' ) ( 'I' | 'i' ) ( 'R' | 'r' ) ( 'I' | 'i' )
    {
        if ( LA(1) == 'I' || LA(1) == 'i' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleISIRIEx;
        }


        if ( LA(1) == 'S' || LA(1) == 's' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleISIRIEx;
        }


        if ( LA(1) == 'I' || LA(1) == 'i' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleISIRIEx;
        }


        if ( LA(1) == 'R' || LA(1) == 'r' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleISIRIEx;
        }


        if ( LA(1) == 'I' || LA(1) == 'i' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleISIRIEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleISIRIEx; /* Prevent compiler warnings */
    ruleISIRIEx: ;

}
// $ANTLR end ISIRI

//   Comes from: 743:7: ( ( 'I' | 'i' ) ( 'S' | 's' ) ( 'U' | 'u' ) ( 'R' | 'r' ) ( 'I' | 'i' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start ISURI
 *
 * Looks to match the characters the constitute the token ISURI
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mISURI(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = ISURI;


    // Sparql.g:743:7: ( ( 'I' | 'i' ) ( 'S' | 's' ) ( 'U' | 'u' ) ( 'R' | 'r' ) ( 'I' | 'i' ) )
    // Sparql.g:743:9: ( 'I' | 'i' ) ( 'S' | 's' ) ( 'U' | 'u' ) ( 'R' | 'r' ) ( 'I' | 'i' )
    {
        if ( LA(1) == 'I' || LA(1) == 'i' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleISURIEx;
        }


        if ( LA(1) == 'S' || LA(1) == 's' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleISURIEx;
        }


        if ( LA(1) == 'U' || LA(1) == 'u' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleISURIEx;
        }


        if ( LA(1) == 'R' || LA(1) == 'r' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleISURIEx;
        }


        if ( LA(1) == 'I' || LA(1) == 'i' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleISURIEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleISURIEx; /* Prevent compiler warnings */
    ruleISURIEx: ;

}
// $ANTLR end ISURI

//   Comes from: 745:9: ( ( 'I' | 'i' ) ( 'S' | 's' ) ( 'B' | 'b' ) ( 'L' | 'l' ) ( 'A' | 'a' ) ( 'N' | 'n' ) ( 'K' | 'k' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start ISBLANK
 *
 * Looks to match the characters the constitute the token ISBLANK
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mISBLANK(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = ISBLANK;


    // Sparql.g:745:9: ( ( 'I' | 'i' ) ( 'S' | 's' ) ( 'B' | 'b' ) ( 'L' | 'l' ) ( 'A' | 'a' ) ( 'N' | 'n' ) ( 'K' | 'k' ) )
    // Sparql.g:745:11: ( 'I' | 'i' ) ( 'S' | 's' ) ( 'B' | 'b' ) ( 'L' | 'l' ) ( 'A' | 'a' ) ( 'N' | 'n' ) ( 'K' | 'k' )
    {
        if ( LA(1) == 'I' || LA(1) == 'i' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleISBLANKEx;
        }


        if ( LA(1) == 'S' || LA(1) == 's' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleISBLANKEx;
        }


        if ( LA(1) == 'B' || LA(1) == 'b' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleISBLANKEx;
        }


        if ( LA(1) == 'L' || LA(1) == 'l' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleISBLANKEx;
        }


        if ( LA(1) == 'A' || LA(1) == 'a' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleISBLANKEx;
        }


        if ( LA(1) == 'N' || LA(1) == 'n' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleISBLANKEx;
        }


        if ( LA(1) == 'K' || LA(1) == 'k' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleISBLANKEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleISBLANKEx; /* Prevent compiler warnings */
    ruleISBLANKEx: ;

}
// $ANTLR end ISBLANK

//   Comes from: 747:11: ( ( 'I' | 'i' ) ( 'S' | 's' ) ( 'L' | 'l' ) ( 'I' | 'i' ) ( 'T' | 't' ) ( 'E' | 'e' ) ( 'R' | 'r' ) ( 'A' | 'a' ) ( 'L' | 'l' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start ISLITERAL
 *
 * Looks to match the characters the constitute the token ISLITERAL
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mISLITERAL(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = ISLITERAL;


    // Sparql.g:747:11: ( ( 'I' | 'i' ) ( 'S' | 's' ) ( 'L' | 'l' ) ( 'I' | 'i' ) ( 'T' | 't' ) ( 'E' | 'e' ) ( 'R' | 'r' ) ( 'A' | 'a' ) ( 'L' | 'l' ) )
    // Sparql.g:747:13: ( 'I' | 'i' ) ( 'S' | 's' ) ( 'L' | 'l' ) ( 'I' | 'i' ) ( 'T' | 't' ) ( 'E' | 'e' ) ( 'R' | 'r' ) ( 'A' | 'a' ) ( 'L' | 'l' )
    {
        if ( LA(1) == 'I' || LA(1) == 'i' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleISLITERALEx;
        }


        if ( LA(1) == 'S' || LA(1) == 's' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleISLITERALEx;
        }


        if ( LA(1) == 'L' || LA(1) == 'l' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleISLITERALEx;
        }


        if ( LA(1) == 'I' || LA(1) == 'i' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleISLITERALEx;
        }


        if ( LA(1) == 'T' || LA(1) == 't' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleISLITERALEx;
        }


        if ( LA(1) == 'E' || LA(1) == 'e' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleISLITERALEx;
        }


        if ( LA(1) == 'R' || LA(1) == 'r' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleISLITERALEx;
        }


        if ( LA(1) == 'A' || LA(1) == 'a' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleISLITERALEx;
        }


        if ( LA(1) == 'L' || LA(1) == 'l' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleISLITERALEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleISLITERALEx; /* Prevent compiler warnings */
    ruleISLITERALEx: ;

}
// $ANTLR end ISLITERAL

//   Comes from: 749:7: ( ( 'R' | 'r' ) ( 'E' | 'e' ) ( 'G' | 'g' ) ( 'E' | 'e' ) ( 'X' | 'x' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start REGEX
 *
 * Looks to match the characters the constitute the token REGEX
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mREGEX(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = REGEX;


    // Sparql.g:749:7: ( ( 'R' | 'r' ) ( 'E' | 'e' ) ( 'G' | 'g' ) ( 'E' | 'e' ) ( 'X' | 'x' ) )
    // Sparql.g:749:9: ( 'R' | 'r' ) ( 'E' | 'e' ) ( 'G' | 'g' ) ( 'E' | 'e' ) ( 'X' | 'x' )
    {
        if ( LA(1) == 'R' || LA(1) == 'r' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleREGEXEx;
        }


        if ( LA(1) == 'E' || LA(1) == 'e' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleREGEXEx;
        }


        if ( LA(1) == 'G' || LA(1) == 'g' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleREGEXEx;
        }


        if ( LA(1) == 'E' || LA(1) == 'e' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleREGEXEx;
        }


        if ( LA(1) == 'X' || LA(1) == 'x' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleREGEXEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleREGEXEx; /* Prevent compiler warnings */
    ruleREGEXEx: ;

}
// $ANTLR end REGEX

//   Comes from: 751:8: ( ( 'S' | 's' ) ( 'U' | 'u' ) ( 'B' | 'b' ) ( 'S' | 's' ) ( 'T' | 't' ) ( 'R' | 'r' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SUBSTR
 *
 * Looks to match the characters the constitute the token SUBSTR
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mSUBSTR(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = SUBSTR;


    // Sparql.g:751:8: ( ( 'S' | 's' ) ( 'U' | 'u' ) ( 'B' | 'b' ) ( 'S' | 's' ) ( 'T' | 't' ) ( 'R' | 'r' ) )
    // Sparql.g:751:10: ( 'S' | 's' ) ( 'U' | 'u' ) ( 'B' | 'b' ) ( 'S' | 's' ) ( 'T' | 't' ) ( 'R' | 'r' )
    {
        if ( LA(1) == 'S' || LA(1) == 's' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleSUBSTREx;
        }


        if ( LA(1) == 'U' || LA(1) == 'u' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleSUBSTREx;
        }


        if ( LA(1) == 'B' || LA(1) == 'b' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleSUBSTREx;
        }


        if ( LA(1) == 'S' || LA(1) == 's' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleSUBSTREx;
        }


        if ( LA(1) == 'T' || LA(1) == 't' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleSUBSTREx;
        }


        if ( LA(1) == 'R' || LA(1) == 'r' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleSUBSTREx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleSUBSTREx; /* Prevent compiler warnings */
    ruleSUBSTREx: ;

}
// $ANTLR end SUBSTR

//   Comes from: 753:6: ( ( 'T' | 't' ) ( 'R' | 'r' ) ( 'U' | 'u' ) ( 'E' | 'e' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TRUE
 *
 * Looks to match the characters the constitute the token TRUE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTRUE(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TRUE;


    // Sparql.g:753:6: ( ( 'T' | 't' ) ( 'R' | 'r' ) ( 'U' | 'u' ) ( 'E' | 'e' ) )
    // Sparql.g:753:8: ( 'T' | 't' ) ( 'R' | 'r' ) ( 'U' | 'u' ) ( 'E' | 'e' )
    {
        if ( LA(1) == 'T' || LA(1) == 't' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleTRUEEx;
        }


        if ( LA(1) == 'R' || LA(1) == 'r' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleTRUEEx;
        }


        if ( LA(1) == 'U' || LA(1) == 'u' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleTRUEEx;
        }


        if ( LA(1) == 'E' || LA(1) == 'e' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleTRUEEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleTRUEEx; /* Prevent compiler warnings */
    ruleTRUEEx: ;

}
// $ANTLR end TRUE

//   Comes from: 755:7: ( ( 'F' | 'f' ) ( 'A' | 'a' ) ( 'L' | 'l' ) ( 'S' | 's' ) ( 'E' | 'e' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start FALSE
 *
 * Looks to match the characters the constitute the token FALSE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mFALSE(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = FALSE;


    // Sparql.g:755:7: ( ( 'F' | 'f' ) ( 'A' | 'a' ) ( 'L' | 'l' ) ( 'S' | 's' ) ( 'E' | 'e' ) )
    // Sparql.g:755:9: ( 'F' | 'f' ) ( 'A' | 'a' ) ( 'L' | 'l' ) ( 'S' | 's' ) ( 'E' | 'e' )
    {
        if ( LA(1) == 'F' || LA(1) == 'f' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleFALSEEx;
        }


        if ( LA(1) == 'A' || LA(1) == 'a' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleFALSEEx;
        }


        if ( LA(1) == 'L' || LA(1) == 'l' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleFALSEEx;
        }


        if ( LA(1) == 'S' || LA(1) == 's' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleFALSEEx;
        }


        if ( LA(1) == 'E' || LA(1) == 'e' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleFALSEEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleFALSEEx; /* Prevent compiler warnings */
    ruleFALSEEx: ;

}
// $ANTLR end FALSE

//   Comes from: 757:6: ( ( 'L' | 'l' ) ( 'O' | 'o' ) ( 'A' | 'a' ) ( 'D' | 'd' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start LOAD
 *
 * Looks to match the characters the constitute the token LOAD
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mLOAD(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = LOAD;


    // Sparql.g:757:6: ( ( 'L' | 'l' ) ( 'O' | 'o' ) ( 'A' | 'a' ) ( 'D' | 'd' ) )
    // Sparql.g:757:8: ( 'L' | 'l' ) ( 'O' | 'o' ) ( 'A' | 'a' ) ( 'D' | 'd' )
    {
        if ( LA(1) == 'L' || LA(1) == 'l' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleLOADEx;
        }


        if ( LA(1) == 'O' || LA(1) == 'o' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleLOADEx;
        }


        if ( LA(1) == 'A' || LA(1) == 'a' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleLOADEx;
        }


        if ( LA(1) == 'D' || LA(1) == 'd' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleLOADEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleLOADEx; /* Prevent compiler warnings */
    ruleLOADEx: ;

}
// $ANTLR end LOAD

//   Comes from: 759:7: ( ( 'C' | 'c' ) ( 'L' | 'l' ) ( 'E' | 'e' ) ( 'A' | 'a' ) ( 'R' | 'r' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start CLEAR
 *
 * Looks to match the characters the constitute the token CLEAR
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mCLEAR(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = CLEAR;


    // Sparql.g:759:7: ( ( 'C' | 'c' ) ( 'L' | 'l' ) ( 'E' | 'e' ) ( 'A' | 'a' ) ( 'R' | 'r' ) )
    // Sparql.g:759:9: ( 'C' | 'c' ) ( 'L' | 'l' ) ( 'E' | 'e' ) ( 'A' | 'a' ) ( 'R' | 'r' )
    {
        if ( LA(1) == 'C' || LA(1) == 'c' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleCLEAREx;
        }


        if ( LA(1) == 'L' || LA(1) == 'l' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleCLEAREx;
        }


        if ( LA(1) == 'E' || LA(1) == 'e' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleCLEAREx;
        }


        if ( LA(1) == 'A' || LA(1) == 'a' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleCLEAREx;
        }


        if ( LA(1) == 'R' || LA(1) == 'r' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleCLEAREx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleCLEAREx; /* Prevent compiler warnings */
    ruleCLEAREx: ;

}
// $ANTLR end CLEAR

//   Comes from: 761:6: ( ( 'D' | 'd' ) ( 'R' | 'r' ) ( 'O' | 'o' ) ( 'P' | 'p' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start DROP
 *
 * Looks to match the characters the constitute the token DROP
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mDROP(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = DROP;


    // Sparql.g:761:6: ( ( 'D' | 'd' ) ( 'R' | 'r' ) ( 'O' | 'o' ) ( 'P' | 'p' ) )
    // Sparql.g:761:8: ( 'D' | 'd' ) ( 'R' | 'r' ) ( 'O' | 'o' ) ( 'P' | 'p' )
    {
        if ( LA(1) == 'D' || LA(1) == 'd' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleDROPEx;
        }


        if ( LA(1) == 'R' || LA(1) == 'r' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleDROPEx;
        }


        if ( LA(1) == 'O' || LA(1) == 'o' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleDROPEx;
        }


        if ( LA(1) == 'P' || LA(1) == 'p' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleDROPEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleDROPEx; /* Prevent compiler warnings */
    ruleDROPEx: ;

}
// $ANTLR end DROP

//   Comes from: 763:5: ( ( 'A' | 'a' ) ( 'D' | 'd' ) ( 'D' | 'd' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start ADD
 *
 * Looks to match the characters the constitute the token ADD
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mADD(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = ADD;


    // Sparql.g:763:5: ( ( 'A' | 'a' ) ( 'D' | 'd' ) ( 'D' | 'd' ) )
    // Sparql.g:763:7: ( 'A' | 'a' ) ( 'D' | 'd' ) ( 'D' | 'd' )
    {
        if ( LA(1) == 'A' || LA(1) == 'a' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleADDEx;
        }


        if ( LA(1) == 'D' || LA(1) == 'd' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleADDEx;
        }


        if ( LA(1) == 'D' || LA(1) == 'd' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleADDEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleADDEx; /* Prevent compiler warnings */
    ruleADDEx: ;

}
// $ANTLR end ADD

//   Comes from: 765:6: ( ( 'M' | 'm' ) ( 'O' | 'o' ) ( 'V' | 'v' ) ( 'E' | 'e' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start MOVE
 *
 * Looks to match the characters the constitute the token MOVE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mMOVE(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = MOVE;


    // Sparql.g:765:6: ( ( 'M' | 'm' ) ( 'O' | 'o' ) ( 'V' | 'v' ) ( 'E' | 'e' ) )
    // Sparql.g:765:8: ( 'M' | 'm' ) ( 'O' | 'o' ) ( 'V' | 'v' ) ( 'E' | 'e' )
    {
        if ( LA(1) == 'M' || LA(1) == 'm' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleMOVEEx;
        }


        if ( LA(1) == 'O' || LA(1) == 'o' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleMOVEEx;
        }


        if ( LA(1) == 'V' || LA(1) == 'v' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleMOVEEx;
        }


        if ( LA(1) == 'E' || LA(1) == 'e' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleMOVEEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleMOVEEx; /* Prevent compiler warnings */
    ruleMOVEEx: ;

}
// $ANTLR end MOVE

//   Comes from: 767:6: ( ( 'C' | 'c' ) ( 'O' | 'o' ) ( 'P' | 'p' ) ( 'Y' | 'y' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start COPY
 *
 * Looks to match the characters the constitute the token COPY
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mCOPY(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = COPY;


    // Sparql.g:767:6: ( ( 'C' | 'c' ) ( 'O' | 'o' ) ( 'P' | 'p' ) ( 'Y' | 'y' ) )
    // Sparql.g:767:8: ( 'C' | 'c' ) ( 'O' | 'o' ) ( 'P' | 'p' ) ( 'Y' | 'y' )
    {
        if ( LA(1) == 'C' || LA(1) == 'c' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleCOPYEx;
        }


        if ( LA(1) == 'O' || LA(1) == 'o' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleCOPYEx;
        }


        if ( LA(1) == 'P' || LA(1) == 'p' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleCOPYEx;
        }


        if ( LA(1) == 'Y' || LA(1) == 'y' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleCOPYEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleCOPYEx; /* Prevent compiler warnings */
    ruleCOPYEx: ;

}
// $ANTLR end COPY

//   Comes from: 769:9: ( ( 'C' | 'c' ) ( 'R' | 'r' ) ( 'E' | 'e' ) ( 'A' | 'a' ) ( 'T' | 't' ) ( 'E' | 'e' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start CREATE
 *
 * Looks to match the characters the constitute the token CREATE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mCREATE(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = CREATE;


    // Sparql.g:769:9: ( ( 'C' | 'c' ) ( 'R' | 'r' ) ( 'E' | 'e' ) ( 'A' | 'a' ) ( 'T' | 't' ) ( 'E' | 'e' ) )
    // Sparql.g:769:11: ( 'C' | 'c' ) ( 'R' | 'r' ) ( 'E' | 'e' ) ( 'A' | 'a' ) ( 'T' | 't' ) ( 'E' | 'e' )
    {
        if ( LA(1) == 'C' || LA(1) == 'c' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleCREATEEx;
        }


        if ( LA(1) == 'R' || LA(1) == 'r' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleCREATEEx;
        }


        if ( LA(1) == 'E' || LA(1) == 'e' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleCREATEEx;
        }


        if ( LA(1) == 'A' || LA(1) == 'a' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleCREATEEx;
        }


        if ( LA(1) == 'T' || LA(1) == 't' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleCREATEEx;
        }


        if ( LA(1) == 'E' || LA(1) == 'e' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleCREATEEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleCREATEEx; /* Prevent compiler warnings */
    ruleCREATEEx: ;

}
// $ANTLR end CREATE

//   Comes from: 771:8: ( ( 'D' | 'd' ) ( 'E' | 'e' ) ( 'L' | 'l' ) ( 'E' | 'e' ) ( 'T' | 't' ) ( 'E' | 'e' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start DELETE
 *
 * Looks to match the characters the constitute the token DELETE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mDELETE(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = DELETE;


    // Sparql.g:771:8: ( ( 'D' | 'd' ) ( 'E' | 'e' ) ( 'L' | 'l' ) ( 'E' | 'e' ) ( 'T' | 't' ) ( 'E' | 'e' ) )
    // Sparql.g:771:10: ( 'D' | 'd' ) ( 'E' | 'e' ) ( 'L' | 'l' ) ( 'E' | 'e' ) ( 'T' | 't' ) ( 'E' | 'e' )
    {
        if ( LA(1) == 'D' || LA(1) == 'd' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleDELETEEx;
        }


        if ( LA(1) == 'E' || LA(1) == 'e' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleDELETEEx;
        }


        if ( LA(1) == 'L' || LA(1) == 'l' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleDELETEEx;
        }


        if ( LA(1) == 'E' || LA(1) == 'e' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleDELETEEx;
        }


        if ( LA(1) == 'T' || LA(1) == 't' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleDELETEEx;
        }


        if ( LA(1) == 'E' || LA(1) == 'e' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleDELETEEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleDELETEEx; /* Prevent compiler warnings */
    ruleDELETEEx: ;

}
// $ANTLR end DELETE

//   Comes from: 773:8: ( ( 'I' | 'i' ) ( 'N' | 'n' ) ( 'S' | 's' ) ( 'E' | 'e' ) ( 'R' | 'r' ) ( 'T' | 't' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start INSERT
 *
 * Looks to match the characters the constitute the token INSERT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mINSERT(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = INSERT;


    // Sparql.g:773:8: ( ( 'I' | 'i' ) ( 'N' | 'n' ) ( 'S' | 's' ) ( 'E' | 'e' ) ( 'R' | 'r' ) ( 'T' | 't' ) )
    // Sparql.g:773:10: ( 'I' | 'i' ) ( 'N' | 'n' ) ( 'S' | 's' ) ( 'E' | 'e' ) ( 'R' | 'r' ) ( 'T' | 't' )
    {
        if ( LA(1) == 'I' || LA(1) == 'i' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleINSERTEx;
        }


        if ( LA(1) == 'N' || LA(1) == 'n' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleINSERTEx;
        }


        if ( LA(1) == 'S' || LA(1) == 's' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleINSERTEx;
        }


        if ( LA(1) == 'E' || LA(1) == 'e' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleINSERTEx;
        }


        if ( LA(1) == 'R' || LA(1) == 'r' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleINSERTEx;
        }


        if ( LA(1) == 'T' || LA(1) == 't' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleINSERTEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleINSERTEx; /* Prevent compiler warnings */
    ruleINSERTEx: ;

}
// $ANTLR end INSERT

//   Comes from: 775:7: ( ( 'U' | 'u' ) ( 'S' | 's' ) ( 'I' | 'i' ) ( 'N' | 'n' ) ( 'G' | 'g' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start USING
 *
 * Looks to match the characters the constitute the token USING
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mUSING(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = USING;


    // Sparql.g:775:7: ( ( 'U' | 'u' ) ( 'S' | 's' ) ( 'I' | 'i' ) ( 'N' | 'n' ) ( 'G' | 'g' ) )
    // Sparql.g:775:9: ( 'U' | 'u' ) ( 'S' | 's' ) ( 'I' | 'i' ) ( 'N' | 'n' ) ( 'G' | 'g' )
    {
        if ( LA(1) == 'U' || LA(1) == 'u' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleUSINGEx;
        }


        if ( LA(1) == 'S' || LA(1) == 's' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleUSINGEx;
        }


        if ( LA(1) == 'I' || LA(1) == 'i' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleUSINGEx;
        }


        if ( LA(1) == 'N' || LA(1) == 'n' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleUSINGEx;
        }


        if ( LA(1) == 'G' || LA(1) == 'g' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleUSINGEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleUSINGEx; /* Prevent compiler warnings */
    ruleUSINGEx: ;

}
// $ANTLR end USING

//   Comes from: 777:8: ( ( 'S' | 's' ) ( 'I' | 'i' ) ( 'L' | 'l' ) ( 'E' | 'e' ) ( 'N' | 'n' ) ( 'T' | 't' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SILENT
 *
 * Looks to match the characters the constitute the token SILENT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mSILENT(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = SILENT;


    // Sparql.g:777:8: ( ( 'S' | 's' ) ( 'I' | 'i' ) ( 'L' | 'l' ) ( 'E' | 'e' ) ( 'N' | 'n' ) ( 'T' | 't' ) )
    // Sparql.g:777:10: ( 'S' | 's' ) ( 'I' | 'i' ) ( 'L' | 'l' ) ( 'E' | 'e' ) ( 'N' | 'n' ) ( 'T' | 't' )
    {
        if ( LA(1) == 'S' || LA(1) == 's' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleSILENTEx;
        }


        if ( LA(1) == 'I' || LA(1) == 'i' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleSILENTEx;
        }


        if ( LA(1) == 'L' || LA(1) == 'l' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleSILENTEx;
        }


        if ( LA(1) == 'E' || LA(1) == 'e' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleSILENTEx;
        }


        if ( LA(1) == 'N' || LA(1) == 'n' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleSILENTEx;
        }


        if ( LA(1) == 'T' || LA(1) == 't' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleSILENTEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleSILENTEx; /* Prevent compiler warnings */
    ruleSILENTEx: ;

}
// $ANTLR end SILENT

//   Comes from: 779:9: ( ( 'D' | 'd' ) ( 'E' | 'e' ) ( 'F' | 'f' ) ( 'A' | 'a' ) ( 'U' | 'u' ) ( 'L' | 'l' ) ( 'T' | 't' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start DEFAULT
 *
 * Looks to match the characters the constitute the token DEFAULT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mDEFAULT(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = DEFAULT;


    // Sparql.g:779:9: ( ( 'D' | 'd' ) ( 'E' | 'e' ) ( 'F' | 'f' ) ( 'A' | 'a' ) ( 'U' | 'u' ) ( 'L' | 'l' ) ( 'T' | 't' ) )
    // Sparql.g:779:11: ( 'D' | 'd' ) ( 'E' | 'e' ) ( 'F' | 'f' ) ( 'A' | 'a' ) ( 'U' | 'u' ) ( 'L' | 'l' ) ( 'T' | 't' )
    {
        if ( LA(1) == 'D' || LA(1) == 'd' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleDEFAULTEx;
        }


        if ( LA(1) == 'E' || LA(1) == 'e' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleDEFAULTEx;
        }


        if ( LA(1) == 'F' || LA(1) == 'f' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleDEFAULTEx;
        }


        if ( LA(1) == 'A' || LA(1) == 'a' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleDEFAULTEx;
        }


        if ( LA(1) == 'U' || LA(1) == 'u' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleDEFAULTEx;
        }


        if ( LA(1) == 'L' || LA(1) == 'l' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleDEFAULTEx;
        }


        if ( LA(1) == 'T' || LA(1) == 't' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleDEFAULTEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleDEFAULTEx; /* Prevent compiler warnings */
    ruleDEFAULTEx: ;

}
// $ANTLR end DEFAULT

//   Comes from: 781:5: ( ( 'A' | 'a' ) ( 'L' | 'l' ) ( 'L' | 'l' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start ALL
 *
 * Looks to match the characters the constitute the token ALL
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mALL(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = ALL;


    // Sparql.g:781:5: ( ( 'A' | 'a' ) ( 'L' | 'l' ) ( 'L' | 'l' ) )
    // Sparql.g:781:7: ( 'A' | 'a' ) ( 'L' | 'l' ) ( 'L' | 'l' )
    {
        if ( LA(1) == 'A' || LA(1) == 'a' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleALLEx;
        }


        if ( LA(1) == 'L' || LA(1) == 'l' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleALLEx;
        }


        if ( LA(1) == 'L' || LA(1) == 'l' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleALLEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleALLEx; /* Prevent compiler warnings */
    ruleALLEx: ;

}
// $ANTLR end ALL

//   Comes from: 783:6: ( ( 'D' | 'd' ) ( 'A' | 'a' ) ( 'T' | 't' ) ( 'A' | 'a' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start DATA
 *
 * Looks to match the characters the constitute the token DATA
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mDATA(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = DATA;


    // Sparql.g:783:6: ( ( 'D' | 'd' ) ( 'A' | 'a' ) ( 'T' | 't' ) ( 'A' | 'a' ) )
    // Sparql.g:783:8: ( 'D' | 'd' ) ( 'A' | 'a' ) ( 'T' | 't' ) ( 'A' | 'a' )
    {
        if ( LA(1) == 'D' || LA(1) == 'd' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleDATAEx;
        }


        if ( LA(1) == 'A' || LA(1) == 'a' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleDATAEx;
        }


        if ( LA(1) == 'T' || LA(1) == 't' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleDATAEx;
        }


        if ( LA(1) == 'A' || LA(1) == 'a' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleDATAEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleDATAEx; /* Prevent compiler warnings */
    ruleDATAEx: ;

}
// $ANTLR end DATA

//   Comes from: 785:6: ( ( 'W' | 'w' ) ( 'I' | 'i' ) ( 'T' | 't' ) ( 'H' | 'h' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start WITH
 *
 * Looks to match the characters the constitute the token WITH
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mWITH(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = WITH;


    // Sparql.g:785:6: ( ( 'W' | 'w' ) ( 'I' | 'i' ) ( 'T' | 't' ) ( 'H' | 'h' ) )
    // Sparql.g:785:8: ( 'W' | 'w' ) ( 'I' | 'i' ) ( 'T' | 't' ) ( 'H' | 'h' )
    {
        if ( LA(1) == 'W' || LA(1) == 'w' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleWITHEx;
        }


        if ( LA(1) == 'I' || LA(1) == 'i' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleWITHEx;
        }


        if ( LA(1) == 'T' || LA(1) == 't' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleWITHEx;
        }


        if ( LA(1) == 'H' || LA(1) == 'h' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleWITHEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleWITHEx; /* Prevent compiler warnings */
    ruleWITHEx: ;

}
// $ANTLR end WITH

//   Comes from: 787:6: ( ( 'I' | 'i' ) ( 'N' | 'n' ) ( 'T' | 't' ) ( 'O' | 'o' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start INTO
 *
 * Looks to match the characters the constitute the token INTO
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mINTO(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = INTO;


    // Sparql.g:787:6: ( ( 'I' | 'i' ) ( 'N' | 'n' ) ( 'T' | 't' ) ( 'O' | 'o' ) )
    // Sparql.g:787:8: ( 'I' | 'i' ) ( 'N' | 'n' ) ( 'T' | 't' ) ( 'O' | 'o' )
    {
        if ( LA(1) == 'I' || LA(1) == 'i' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleINTOEx;
        }


        if ( LA(1) == 'N' || LA(1) == 'n' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleINTOEx;
        }


        if ( LA(1) == 'T' || LA(1) == 't' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleINTOEx;
        }


        if ( LA(1) == 'O' || LA(1) == 'o' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleINTOEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleINTOEx; /* Prevent compiler warnings */
    ruleINTOEx: ;

}
// $ANTLR end INTO

//   Comes from: 789:4: ( ( 'T' | 't' ) ( 'O' | 'o' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TO
 *
 * Looks to match the characters the constitute the token TO
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTO(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TO;


    // Sparql.g:789:4: ( ( 'T' | 't' ) ( 'O' | 'o' ) )
    // Sparql.g:789:6: ( 'T' | 't' ) ( 'O' | 'o' )
    {
        if ( LA(1) == 'T' || LA(1) == 't' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleTOEx;
        }


        if ( LA(1) == 'O' || LA(1) == 'o' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleTOEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleTOEx; /* Prevent compiler warnings */
    ruleTOEx: ;

}
// $ANTLR end TO

//   Comes from: 791:4: ( ( 'A' | 'a' ) ( 'S' | 's' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start AS
 *
 * Looks to match the characters the constitute the token AS
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mAS(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = AS;


    // Sparql.g:791:4: ( ( 'A' | 'a' ) ( 'S' | 's' ) )
    // Sparql.g:791:6: ( 'A' | 'a' ) ( 'S' | 's' )
    {
        if ( LA(1) == 'A' || LA(1) == 'a' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleASEx;
        }


        if ( LA(1) == 'S' || LA(1) == 's' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleASEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleASEx; /* Prevent compiler warnings */
    ruleASEx: ;

}
// $ANTLR end AS

//   Comes from: 793:7: ( ( 'G' | 'g' ) ( 'R' | 'r' ) ( 'O' | 'o' ) ( 'U' | 'u' ) ( 'P' | 'p' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start GROUP
 *
 * Looks to match the characters the constitute the token GROUP
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mGROUP(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = GROUP;


    // Sparql.g:793:7: ( ( 'G' | 'g' ) ( 'R' | 'r' ) ( 'O' | 'o' ) ( 'U' | 'u' ) ( 'P' | 'p' ) )
    // Sparql.g:793:9: ( 'G' | 'g' ) ( 'R' | 'r' ) ( 'O' | 'o' ) ( 'U' | 'u' ) ( 'P' | 'p' )
    {
        if ( LA(1) == 'G' || LA(1) == 'g' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleGROUPEx;
        }


        if ( LA(1) == 'R' || LA(1) == 'r' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleGROUPEx;
        }


        if ( LA(1) == 'O' || LA(1) == 'o' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleGROUPEx;
        }


        if ( LA(1) == 'U' || LA(1) == 'u' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleGROUPEx;
        }


        if ( LA(1) == 'P' || LA(1) == 'p' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleGROUPEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleGROUPEx; /* Prevent compiler warnings */
    ruleGROUPEx: ;

}
// $ANTLR end GROUP

//   Comes from: 795:8: ( ( 'H' | 'h' ) ( 'A' | 'a' ) ( 'V' | 'v' ) ( 'I' | 'i' ) ( 'N' | 'n' ) ( 'G' | 'g' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start HAVING
 *
 * Looks to match the characters the constitute the token HAVING
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mHAVING(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = HAVING;


    // Sparql.g:795:8: ( ( 'H' | 'h' ) ( 'A' | 'a' ) ( 'V' | 'v' ) ( 'I' | 'i' ) ( 'N' | 'n' ) ( 'G' | 'g' ) )
    // Sparql.g:795:10: ( 'H' | 'h' ) ( 'A' | 'a' ) ( 'V' | 'v' ) ( 'I' | 'i' ) ( 'N' | 'n' ) ( 'G' | 'g' )
    {
        if ( LA(1) == 'H' || LA(1) == 'h' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleHAVINGEx;
        }


        if ( LA(1) == 'A' || LA(1) == 'a' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleHAVINGEx;
        }


        if ( LA(1) == 'V' || LA(1) == 'v' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleHAVINGEx;
        }


        if ( LA(1) == 'I' || LA(1) == 'i' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleHAVINGEx;
        }


        if ( LA(1) == 'N' || LA(1) == 'n' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleHAVINGEx;
        }


        if ( LA(1) == 'G' || LA(1) == 'g' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleHAVINGEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleHAVINGEx; /* Prevent compiler warnings */
    ruleHAVINGEx: ;

}
// $ANTLR end HAVING

//   Comes from: 797:7: ( ( 'U' | 'u' ) ( 'N' | 'n' ) ( 'D' | 'd' ) ( 'E' | 'e' ) ( 'F' | 'f' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start UNDEF
 *
 * Looks to match the characters the constitute the token UNDEF
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mUNDEF(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = UNDEF;


    // Sparql.g:797:7: ( ( 'U' | 'u' ) ( 'N' | 'n' ) ( 'D' | 'd' ) ( 'E' | 'e' ) ( 'F' | 'f' ) )
    // Sparql.g:797:9: ( 'U' | 'u' ) ( 'N' | 'n' ) ( 'D' | 'd' ) ( 'E' | 'e' ) ( 'F' | 'f' )
    {
        if ( LA(1) == 'U' || LA(1) == 'u' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleUNDEFEx;
        }


        if ( LA(1) == 'N' || LA(1) == 'n' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleUNDEFEx;
        }


        if ( LA(1) == 'D' || LA(1) == 'd' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleUNDEFEx;
        }


        if ( LA(1) == 'E' || LA(1) == 'e' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleUNDEFEx;
        }


        if ( LA(1) == 'F' || LA(1) == 'f' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleUNDEFEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleUNDEFEx; /* Prevent compiler warnings */
    ruleUNDEFEx: ;

}
// $ANTLR end UNDEF

//   Comes from: 799:10: ( ( 'B' | 'b' ) ( 'I' | 'i' ) ( 'N' | 'n' ) ( 'D' | 'd' ) ( 'I' | 'i' ) ( 'N' | 'n' ) ( 'G' | 'g' ) ( 'S' | 's' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start BINDINGS
 *
 * Looks to match the characters the constitute the token BINDINGS
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mBINDINGS(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = BINDINGS;


    // Sparql.g:799:10: ( ( 'B' | 'b' ) ( 'I' | 'i' ) ( 'N' | 'n' ) ( 'D' | 'd' ) ( 'I' | 'i' ) ( 'N' | 'n' ) ( 'G' | 'g' ) ( 'S' | 's' ) )
    // Sparql.g:799:12: ( 'B' | 'b' ) ( 'I' | 'i' ) ( 'N' | 'n' ) ( 'D' | 'd' ) ( 'I' | 'i' ) ( 'N' | 'n' ) ( 'G' | 'g' ) ( 'S' | 's' )
    {
        if ( LA(1) == 'B' || LA(1) == 'b' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleBINDINGSEx;
        }


        if ( LA(1) == 'I' || LA(1) == 'i' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleBINDINGSEx;
        }


        if ( LA(1) == 'N' || LA(1) == 'n' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleBINDINGSEx;
        }


        if ( LA(1) == 'D' || LA(1) == 'd' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleBINDINGSEx;
        }


        if ( LA(1) == 'I' || LA(1) == 'i' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleBINDINGSEx;
        }


        if ( LA(1) == 'N' || LA(1) == 'n' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleBINDINGSEx;
        }


        if ( LA(1) == 'G' || LA(1) == 'g' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleBINDINGSEx;
        }


        if ( LA(1) == 'S' || LA(1) == 's' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleBINDINGSEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleBINDINGSEx; /* Prevent compiler warnings */
    ruleBINDINGSEx: ;

}
// $ANTLR end BINDINGS

//   Comes from: 801:9: ( ( 'S' | 's' ) ( 'E' | 'e' ) ( 'R' | 'r' ) ( 'V' | 'v' ) ( 'I' | 'i' ) ( 'C' | 'c' ) ( 'E' | 'e' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SERVICE
 *
 * Looks to match the characters the constitute the token SERVICE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mSERVICE(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = SERVICE;


    // Sparql.g:801:9: ( ( 'S' | 's' ) ( 'E' | 'e' ) ( 'R' | 'r' ) ( 'V' | 'v' ) ( 'I' | 'i' ) ( 'C' | 'c' ) ( 'E' | 'e' ) )
    // Sparql.g:801:11: ( 'S' | 's' ) ( 'E' | 'e' ) ( 'R' | 'r' ) ( 'V' | 'v' ) ( 'I' | 'i' ) ( 'C' | 'c' ) ( 'E' | 'e' )
    {
        if ( LA(1) == 'S' || LA(1) == 's' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleSERVICEEx;
        }


        if ( LA(1) == 'E' || LA(1) == 'e' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleSERVICEEx;
        }


        if ( LA(1) == 'R' || LA(1) == 'r' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleSERVICEEx;
        }


        if ( LA(1) == 'V' || LA(1) == 'v' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleSERVICEEx;
        }


        if ( LA(1) == 'I' || LA(1) == 'i' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleSERVICEEx;
        }


        if ( LA(1) == 'C' || LA(1) == 'c' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleSERVICEEx;
        }


        if ( LA(1) == 'E' || LA(1) == 'e' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleSERVICEEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleSERVICEEx; /* Prevent compiler warnings */
    ruleSERVICEEx: ;

}
// $ANTLR end SERVICE

//   Comes from: 803:6: ( ( 'B' | 'b' ) ( 'I' | 'i' ) ( 'N' | 'n' ) ( 'D' | 'd' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start BIND
 *
 * Looks to match the characters the constitute the token BIND
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mBIND(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = BIND;


    // Sparql.g:803:6: ( ( 'B' | 'b' ) ( 'I' | 'i' ) ( 'N' | 'n' ) ( 'D' | 'd' ) )
    // Sparql.g:803:8: ( 'B' | 'b' ) ( 'I' | 'i' ) ( 'N' | 'n' ) ( 'D' | 'd' )
    {
        if ( LA(1) == 'B' || LA(1) == 'b' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleBINDEx;
        }


        if ( LA(1) == 'I' || LA(1) == 'i' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleBINDEx;
        }


        if ( LA(1) == 'N' || LA(1) == 'n' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleBINDEx;
        }


        if ( LA(1) == 'D' || LA(1) == 'd' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleBINDEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleBINDEx; /* Prevent compiler warnings */
    ruleBINDEx: ;

}
// $ANTLR end BIND

//   Comes from: 805:15: ( ( 'M' | 'm' ) ( 'I' | 'i' ) ( 'N' | 'n' ) ( 'U' | 'u' ) ( 'S' | 's' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start MINUS_KEYWORD
 *
 * Looks to match the characters the constitute the token MINUS_KEYWORD
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mMINUS_KEYWORD(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = MINUS_KEYWORD;


    // Sparql.g:805:15: ( ( 'M' | 'm' ) ( 'I' | 'i' ) ( 'N' | 'n' ) ( 'U' | 'u' ) ( 'S' | 's' ) )
    // Sparql.g:805:17: ( 'M' | 'm' ) ( 'I' | 'i' ) ( 'N' | 'n' ) ( 'U' | 'u' ) ( 'S' | 's' )
    {
        if ( LA(1) == 'M' || LA(1) == 'm' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleMINUS_KEYWORDEx;
        }


        if ( LA(1) == 'I' || LA(1) == 'i' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleMINUS_KEYWORDEx;
        }


        if ( LA(1) == 'N' || LA(1) == 'n' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleMINUS_KEYWORDEx;
        }


        if ( LA(1) == 'U' || LA(1) == 'u' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleMINUS_KEYWORDEx;
        }


        if ( LA(1) == 'S' || LA(1) == 's' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleMINUS_KEYWORDEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleMINUS_KEYWORDEx; /* Prevent compiler warnings */
    ruleMINUS_KEYWORDEx: ;

}
// $ANTLR end MINUS_KEYWORD

//   Comes from: 807:5: ( ( 'I' | 'i' ) ( 'R' | 'r' ) ( 'I' | 'i' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start IRI
 *
 * Looks to match the characters the constitute the token IRI
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mIRI(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = IRI;


    // Sparql.g:807:5: ( ( 'I' | 'i' ) ( 'R' | 'r' ) ( 'I' | 'i' ) )
    // Sparql.g:807:7: ( 'I' | 'i' ) ( 'R' | 'r' ) ( 'I' | 'i' )
    {
        if ( LA(1) == 'I' || LA(1) == 'i' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleIRIEx;
        }


        if ( LA(1) == 'R' || LA(1) == 'r' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleIRIEx;
        }


        if ( LA(1) == 'I' || LA(1) == 'i' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleIRIEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleIRIEx; /* Prevent compiler warnings */
    ruleIRIEx: ;

}
// $ANTLR end IRI

//   Comes from: 809:5: ( ( 'U' | 'u' ) ( 'R' | 'r' ) ( 'I' | 'i' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start URI
 *
 * Looks to match the characters the constitute the token URI
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mURI(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = URI;


    // Sparql.g:809:5: ( ( 'U' | 'u' ) ( 'R' | 'r' ) ( 'I' | 'i' ) )
    // Sparql.g:809:7: ( 'U' | 'u' ) ( 'R' | 'r' ) ( 'I' | 'i' )
    {
        if ( LA(1) == 'U' || LA(1) == 'u' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleURIEx;
        }


        if ( LA(1) == 'R' || LA(1) == 'r' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleURIEx;
        }


        if ( LA(1) == 'I' || LA(1) == 'i' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleURIEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleURIEx; /* Prevent compiler warnings */
    ruleURIEx: ;

}
// $ANTLR end URI

//   Comes from: 811:7: ( ( 'B' | 'b' ) ( 'N' | 'n' ) ( 'O' | 'o' ) ( 'D' | 'd' ) ( 'E' | 'e' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start BNODE
 *
 * Looks to match the characters the constitute the token BNODE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mBNODE(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = BNODE;


    // Sparql.g:811:7: ( ( 'B' | 'b' ) ( 'N' | 'n' ) ( 'O' | 'o' ) ( 'D' | 'd' ) ( 'E' | 'e' ) )
    // Sparql.g:811:9: ( 'B' | 'b' ) ( 'N' | 'n' ) ( 'O' | 'o' ) ( 'D' | 'd' ) ( 'E' | 'e' )
    {
        if ( LA(1) == 'B' || LA(1) == 'b' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleBNODEEx;
        }


        if ( LA(1) == 'N' || LA(1) == 'n' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleBNODEEx;
        }


        if ( LA(1) == 'O' || LA(1) == 'o' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleBNODEEx;
        }


        if ( LA(1) == 'D' || LA(1) == 'd' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleBNODEEx;
        }


        if ( LA(1) == 'E' || LA(1) == 'e' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleBNODEEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleBNODEEx; /* Prevent compiler warnings */
    ruleBNODEEx: ;

}
// $ANTLR end BNODE

//   Comes from: 813:6: ( ( 'R' | 'r' ) ( 'A' | 'a' ) ( 'N' | 'n' ) ( 'D' | 'd' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start RAND
 *
 * Looks to match the characters the constitute the token RAND
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mRAND(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = RAND;


    // Sparql.g:813:6: ( ( 'R' | 'r' ) ( 'A' | 'a' ) ( 'N' | 'n' ) ( 'D' | 'd' ) )
    // Sparql.g:813:8: ( 'R' | 'r' ) ( 'A' | 'a' ) ( 'N' | 'n' ) ( 'D' | 'd' )
    {
        if ( LA(1) == 'R' || LA(1) == 'r' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleRANDEx;
        }


        if ( LA(1) == 'A' || LA(1) == 'a' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleRANDEx;
        }


        if ( LA(1) == 'N' || LA(1) == 'n' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleRANDEx;
        }


        if ( LA(1) == 'D' || LA(1) == 'd' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleRANDEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleRANDEx; /* Prevent compiler warnings */
    ruleRANDEx: ;

}
// $ANTLR end RAND

//   Comes from: 815:4: ( ( 'A' | 'a' ) ( 'B' | 'b' ) ( 'S' | 's' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start ABS
 *
 * Looks to match the characters the constitute the token ABS
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mABS(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = ABS;


    // Sparql.g:815:4: ( ( 'A' | 'a' ) ( 'B' | 'b' ) ( 'S' | 's' ) )
    // Sparql.g:815:6: ( 'A' | 'a' ) ( 'B' | 'b' ) ( 'S' | 's' )
    {
        if ( LA(1) == 'A' || LA(1) == 'a' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleABSEx;
        }


        if ( LA(1) == 'B' || LA(1) == 'b' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleABSEx;
        }


        if ( LA(1) == 'S' || LA(1) == 's' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleABSEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleABSEx; /* Prevent compiler warnings */
    ruleABSEx: ;

}
// $ANTLR end ABS

//   Comes from: 817:6: ( ( 'C' | 'c' ) ( 'E' | 'e' ) ( 'I' | 'i' ) ( 'L' | 'l' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start CEIL
 *
 * Looks to match the characters the constitute the token CEIL
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mCEIL(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = CEIL;


    // Sparql.g:817:6: ( ( 'C' | 'c' ) ( 'E' | 'e' ) ( 'I' | 'i' ) ( 'L' | 'l' ) )
    // Sparql.g:817:8: ( 'C' | 'c' ) ( 'E' | 'e' ) ( 'I' | 'i' ) ( 'L' | 'l' )
    {
        if ( LA(1) == 'C' || LA(1) == 'c' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleCEILEx;
        }


        if ( LA(1) == 'E' || LA(1) == 'e' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleCEILEx;
        }


        if ( LA(1) == 'I' || LA(1) == 'i' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleCEILEx;
        }


        if ( LA(1) == 'L' || LA(1) == 'l' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleCEILEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleCEILEx; /* Prevent compiler warnings */
    ruleCEILEx: ;

}
// $ANTLR end CEIL

//   Comes from: 819:7: ( ( 'F' | 'f' ) ( 'L' | 'l' ) ( 'O' | 'o' ) ( 'O' | 'o' ) ( 'R' | 'r' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start FLOOR
 *
 * Looks to match the characters the constitute the token FLOOR
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mFLOOR(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = FLOOR;


    // Sparql.g:819:7: ( ( 'F' | 'f' ) ( 'L' | 'l' ) ( 'O' | 'o' ) ( 'O' | 'o' ) ( 'R' | 'r' ) )
    // Sparql.g:819:9: ( 'F' | 'f' ) ( 'L' | 'l' ) ( 'O' | 'o' ) ( 'O' | 'o' ) ( 'R' | 'r' )
    {
        if ( LA(1) == 'F' || LA(1) == 'f' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleFLOOREx;
        }


        if ( LA(1) == 'L' || LA(1) == 'l' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleFLOOREx;
        }


        if ( LA(1) == 'O' || LA(1) == 'o' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleFLOOREx;
        }


        if ( LA(1) == 'O' || LA(1) == 'o' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleFLOOREx;
        }


        if ( LA(1) == 'R' || LA(1) == 'r' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleFLOOREx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleFLOOREx; /* Prevent compiler warnings */
    ruleFLOOREx: ;

}
// $ANTLR end FLOOR

//   Comes from: 821:7: ( ( 'R' | 'r' ) ( 'O' | 'o' ) ( 'U' | 'u' ) ( 'N' | 'n' ) ( 'D' | 'd' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start ROUND
 *
 * Looks to match the characters the constitute the token ROUND
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mROUND(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = ROUND;


    // Sparql.g:821:7: ( ( 'R' | 'r' ) ( 'O' | 'o' ) ( 'U' | 'u' ) ( 'N' | 'n' ) ( 'D' | 'd' ) )
    // Sparql.g:821:9: ( 'R' | 'r' ) ( 'O' | 'o' ) ( 'U' | 'u' ) ( 'N' | 'n' ) ( 'D' | 'd' )
    {
        if ( LA(1) == 'R' || LA(1) == 'r' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleROUNDEx;
        }


        if ( LA(1) == 'O' || LA(1) == 'o' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleROUNDEx;
        }


        if ( LA(1) == 'U' || LA(1) == 'u' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleROUNDEx;
        }


        if ( LA(1) == 'N' || LA(1) == 'n' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleROUNDEx;
        }


        if ( LA(1) == 'D' || LA(1) == 'd' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleROUNDEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleROUNDEx; /* Prevent compiler warnings */
    ruleROUNDEx: ;

}
// $ANTLR end ROUND

//   Comes from: 823:9: ( ( 'C' | 'c' ) ( 'O' | 'o' ) ( 'N' | 'n' ) ( 'C' | 'c' ) ( 'A' | 'a' ) ( 'T' | 't' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start CONCAT
 *
 * Looks to match the characters the constitute the token CONCAT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mCONCAT(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = CONCAT;


    // Sparql.g:823:9: ( ( 'C' | 'c' ) ( 'O' | 'o' ) ( 'N' | 'n' ) ( 'C' | 'c' ) ( 'A' | 'a' ) ( 'T' | 't' ) )
    // Sparql.g:823:11: ( 'C' | 'c' ) ( 'O' | 'o' ) ( 'N' | 'n' ) ( 'C' | 'c' ) ( 'A' | 'a' ) ( 'T' | 't' )
    {
        if ( LA(1) == 'C' || LA(1) == 'c' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleCONCATEx;
        }


        if ( LA(1) == 'O' || LA(1) == 'o' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleCONCATEx;
        }


        if ( LA(1) == 'N' || LA(1) == 'n' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleCONCATEx;
        }


        if ( LA(1) == 'C' || LA(1) == 'c' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleCONCATEx;
        }


        if ( LA(1) == 'A' || LA(1) == 'a' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleCONCATEx;
        }


        if ( LA(1) == 'T' || LA(1) == 't' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleCONCATEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleCONCATEx; /* Prevent compiler warnings */
    ruleCONCATEx: ;

}
// $ANTLR end CONCAT

//   Comes from: 825:8: ( ( 'S' | 's' ) ( 'T' | 't' ) ( 'R' | 'r' ) ( 'L' | 'l' ) ( 'E' | 'e' ) ( 'N' | 'n' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start STRLEN
 *
 * Looks to match the characters the constitute the token STRLEN
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mSTRLEN(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = STRLEN;


    // Sparql.g:825:8: ( ( 'S' | 's' ) ( 'T' | 't' ) ( 'R' | 'r' ) ( 'L' | 'l' ) ( 'E' | 'e' ) ( 'N' | 'n' ) )
    // Sparql.g:825:10: ( 'S' | 's' ) ( 'T' | 't' ) ( 'R' | 'r' ) ( 'L' | 'l' ) ( 'E' | 'e' ) ( 'N' | 'n' )
    {
        if ( LA(1) == 'S' || LA(1) == 's' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleSTRLENEx;
        }


        if ( LA(1) == 'T' || LA(1) == 't' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleSTRLENEx;
        }


        if ( LA(1) == 'R' || LA(1) == 'r' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleSTRLENEx;
        }


        if ( LA(1) == 'L' || LA(1) == 'l' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleSTRLENEx;
        }


        if ( LA(1) == 'E' || LA(1) == 'e' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleSTRLENEx;
        }


        if ( LA(1) == 'N' || LA(1) == 'n' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleSTRLENEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleSTRLENEx; /* Prevent compiler warnings */
    ruleSTRLENEx: ;

}
// $ANTLR end STRLEN

//   Comes from: 827:7: ( ( 'U' | 'u' ) ( 'C' | 'c' ) ( 'A' | 'a' ) ( 'S' | 's' ) ( 'E' | 'e' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start UCASE
 *
 * Looks to match the characters the constitute the token UCASE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mUCASE(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = UCASE;


    // Sparql.g:827:7: ( ( 'U' | 'u' ) ( 'C' | 'c' ) ( 'A' | 'a' ) ( 'S' | 's' ) ( 'E' | 'e' ) )
    // Sparql.g:827:9: ( 'U' | 'u' ) ( 'C' | 'c' ) ( 'A' | 'a' ) ( 'S' | 's' ) ( 'E' | 'e' )
    {
        if ( LA(1) == 'U' || LA(1) == 'u' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleUCASEEx;
        }


        if ( LA(1) == 'C' || LA(1) == 'c' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleUCASEEx;
        }


        if ( LA(1) == 'A' || LA(1) == 'a' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleUCASEEx;
        }


        if ( LA(1) == 'S' || LA(1) == 's' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleUCASEEx;
        }


        if ( LA(1) == 'E' || LA(1) == 'e' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleUCASEEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleUCASEEx; /* Prevent compiler warnings */
    ruleUCASEEx: ;

}
// $ANTLR end UCASE

//   Comes from: 829:7: ( ( 'L' | 'l' ) ( 'C' | 'c' ) ( 'A' | 'a' ) ( 'S' | 's' ) ( 'E' | 'e' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start LCASE
 *
 * Looks to match the characters the constitute the token LCASE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mLCASE(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = LCASE;


    // Sparql.g:829:7: ( ( 'L' | 'l' ) ( 'C' | 'c' ) ( 'A' | 'a' ) ( 'S' | 's' ) ( 'E' | 'e' ) )
    // Sparql.g:829:9: ( 'L' | 'l' ) ( 'C' | 'c' ) ( 'A' | 'a' ) ( 'S' | 's' ) ( 'E' | 'e' )
    {
        if ( LA(1) == 'L' || LA(1) == 'l' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleLCASEEx;
        }


        if ( LA(1) == 'C' || LA(1) == 'c' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleLCASEEx;
        }


        if ( LA(1) == 'A' || LA(1) == 'a' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleLCASEEx;
        }


        if ( LA(1) == 'S' || LA(1) == 's' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleLCASEEx;
        }


        if ( LA(1) == 'E' || LA(1) == 'e' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleLCASEEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleLCASEEx; /* Prevent compiler warnings */
    ruleLCASEEx: ;

}
// $ANTLR end LCASE

//   Comes from: 831:16: ( ( 'E' | 'e' ) ( 'N' | 'n' ) ( 'C' | 'c' ) ( 'O' | 'o' ) ( 'D' | 'd' ) ( 'E' | 'e' ) '_' ( 'F' | 'f' ) ( 'O' | 'o' ) ( 'R' | 'r' ) '_' ( 'U' | 'u' ) ( 'R' | 'r' ) ( 'I' | 'i' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start ENCODE_FOR_URI
 *
 * Looks to match the characters the constitute the token ENCODE_FOR_URI
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mENCODE_FOR_URI(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = ENCODE_FOR_URI;


    // Sparql.g:831:16: ( ( 'E' | 'e' ) ( 'N' | 'n' ) ( 'C' | 'c' ) ( 'O' | 'o' ) ( 'D' | 'd' ) ( 'E' | 'e' ) '_' ( 'F' | 'f' ) ( 'O' | 'o' ) ( 'R' | 'r' ) '_' ( 'U' | 'u' ) ( 'R' | 'r' ) ( 'I' | 'i' ) )
    // Sparql.g:831:18: ( 'E' | 'e' ) ( 'N' | 'n' ) ( 'C' | 'c' ) ( 'O' | 'o' ) ( 'D' | 'd' ) ( 'E' | 'e' ) '_' ( 'F' | 'f' ) ( 'O' | 'o' ) ( 'R' | 'r' ) '_' ( 'U' | 'u' ) ( 'R' | 'r' ) ( 'I' | 'i' )
    {
        if ( LA(1) == 'E' || LA(1) == 'e' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleENCODE_FOR_URIEx;
        }


        if ( LA(1) == 'N' || LA(1) == 'n' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleENCODE_FOR_URIEx;
        }


        if ( LA(1) == 'C' || LA(1) == 'c' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleENCODE_FOR_URIEx;
        }


        if ( LA(1) == 'O' || LA(1) == 'o' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleENCODE_FOR_URIEx;
        }


        if ( LA(1) == 'D' || LA(1) == 'd' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleENCODE_FOR_URIEx;
        }


        if ( LA(1) == 'E' || LA(1) == 'e' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleENCODE_FOR_URIEx;
        }


        MATCHC('_');
        if  (HASEXCEPTION())
        {
            goto ruleENCODE_FOR_URIEx;
        }
        if (HASFAILED())
        {
            return ;
        }


        if ( LA(1) == 'F' || LA(1) == 'f' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleENCODE_FOR_URIEx;
        }


        if ( LA(1) == 'O' || LA(1) == 'o' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleENCODE_FOR_URIEx;
        }


        if ( LA(1) == 'R' || LA(1) == 'r' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleENCODE_FOR_URIEx;
        }


        MATCHC('_');
        if  (HASEXCEPTION())
        {
            goto ruleENCODE_FOR_URIEx;
        }
        if (HASFAILED())
        {
            return ;
        }


        if ( LA(1) == 'U' || LA(1) == 'u' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleENCODE_FOR_URIEx;
        }


        if ( LA(1) == 'R' || LA(1) == 'r' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleENCODE_FOR_URIEx;
        }


        if ( LA(1) == 'I' || LA(1) == 'i' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleENCODE_FOR_URIEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleENCODE_FOR_URIEx; /* Prevent compiler warnings */
    ruleENCODE_FOR_URIEx: ;

}
// $ANTLR end ENCODE_FOR_URI

//   Comes from: 833:10: ( ( 'C' | 'c' ) ( 'O' | 'o' ) ( 'N' | 'n' ) ( 'T' | 't' ) ( 'A' | 'a' ) ( 'I' | 'i' ) ( 'N' | 'n' ) ( 'S' | 's' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start CONTAINS
 *
 * Looks to match the characters the constitute the token CONTAINS
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mCONTAINS(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = CONTAINS;


    // Sparql.g:833:10: ( ( 'C' | 'c' ) ( 'O' | 'o' ) ( 'N' | 'n' ) ( 'T' | 't' ) ( 'A' | 'a' ) ( 'I' | 'i' ) ( 'N' | 'n' ) ( 'S' | 's' ) )
    // Sparql.g:833:12: ( 'C' | 'c' ) ( 'O' | 'o' ) ( 'N' | 'n' ) ( 'T' | 't' ) ( 'A' | 'a' ) ( 'I' | 'i' ) ( 'N' | 'n' ) ( 'S' | 's' )
    {
        if ( LA(1) == 'C' || LA(1) == 'c' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleCONTAINSEx;
        }


        if ( LA(1) == 'O' || LA(1) == 'o' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleCONTAINSEx;
        }


        if ( LA(1) == 'N' || LA(1) == 'n' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleCONTAINSEx;
        }


        if ( LA(1) == 'T' || LA(1) == 't' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleCONTAINSEx;
        }


        if ( LA(1) == 'A' || LA(1) == 'a' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleCONTAINSEx;
        }


        if ( LA(1) == 'I' || LA(1) == 'i' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleCONTAINSEx;
        }


        if ( LA(1) == 'N' || LA(1) == 'n' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleCONTAINSEx;
        }


        if ( LA(1) == 'S' || LA(1) == 's' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleCONTAINSEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleCONTAINSEx; /* Prevent compiler warnings */
    ruleCONTAINSEx: ;

}
// $ANTLR end CONTAINS

//   Comes from: 835:11: ( ( 'S' | 's' ) ( 'T' | 't' ) ( 'R' | 'r' ) ( 'S' | 's' ) ( 'T' | 't' ) ( 'A' | 'a' ) ( 'R' | 'r' ) ( 'T' | 't' ) ( 'S' | 's' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start STRSTARTS
 *
 * Looks to match the characters the constitute the token STRSTARTS
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mSTRSTARTS(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = STRSTARTS;


    // Sparql.g:835:11: ( ( 'S' | 's' ) ( 'T' | 't' ) ( 'R' | 'r' ) ( 'S' | 's' ) ( 'T' | 't' ) ( 'A' | 'a' ) ( 'R' | 'r' ) ( 'T' | 't' ) ( 'S' | 's' ) )
    // Sparql.g:835:13: ( 'S' | 's' ) ( 'T' | 't' ) ( 'R' | 'r' ) ( 'S' | 's' ) ( 'T' | 't' ) ( 'A' | 'a' ) ( 'R' | 'r' ) ( 'T' | 't' ) ( 'S' | 's' )
    {
        if ( LA(1) == 'S' || LA(1) == 's' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleSTRSTARTSEx;
        }


        if ( LA(1) == 'T' || LA(1) == 't' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleSTRSTARTSEx;
        }


        if ( LA(1) == 'R' || LA(1) == 'r' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleSTRSTARTSEx;
        }


        if ( LA(1) == 'S' || LA(1) == 's' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleSTRSTARTSEx;
        }


        if ( LA(1) == 'T' || LA(1) == 't' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleSTRSTARTSEx;
        }


        if ( LA(1) == 'A' || LA(1) == 'a' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleSTRSTARTSEx;
        }


        if ( LA(1) == 'R' || LA(1) == 'r' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleSTRSTARTSEx;
        }


        if ( LA(1) == 'T' || LA(1) == 't' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleSTRSTARTSEx;
        }


        if ( LA(1) == 'S' || LA(1) == 's' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleSTRSTARTSEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleSTRSTARTSEx; /* Prevent compiler warnings */
    ruleSTRSTARTSEx: ;

}
// $ANTLR end STRSTARTS

//   Comes from: 837:9: ( ( 'S' | 's' ) ( 'T' | 't' ) ( 'R' | 'r' ) ( 'E' | 'e' ) ( 'N' | 'n' ) ( 'D' | 'd' ) ( 'S' | 's' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start STRENDS
 *
 * Looks to match the characters the constitute the token STRENDS
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mSTRENDS(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = STRENDS;


    // Sparql.g:837:9: ( ( 'S' | 's' ) ( 'T' | 't' ) ( 'R' | 'r' ) ( 'E' | 'e' ) ( 'N' | 'n' ) ( 'D' | 'd' ) ( 'S' | 's' ) )
    // Sparql.g:837:11: ( 'S' | 's' ) ( 'T' | 't' ) ( 'R' | 'r' ) ( 'E' | 'e' ) ( 'N' | 'n' ) ( 'D' | 'd' ) ( 'S' | 's' )
    {
        if ( LA(1) == 'S' || LA(1) == 's' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleSTRENDSEx;
        }


        if ( LA(1) == 'T' || LA(1) == 't' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleSTRENDSEx;
        }


        if ( LA(1) == 'R' || LA(1) == 'r' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleSTRENDSEx;
        }


        if ( LA(1) == 'E' || LA(1) == 'e' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleSTRENDSEx;
        }


        if ( LA(1) == 'N' || LA(1) == 'n' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleSTRENDSEx;
        }


        if ( LA(1) == 'D' || LA(1) == 'd' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleSTRENDSEx;
        }


        if ( LA(1) == 'S' || LA(1) == 's' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleSTRENDSEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleSTRENDSEx; /* Prevent compiler warnings */
    ruleSTRENDSEx: ;

}
// $ANTLR end STRENDS

//   Comes from: 839:6: ( ( 'Y' | 'y' ) ( 'E' | 'e' ) ( 'A' | 'a' ) ( 'R' | 'r' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start YEAR
 *
 * Looks to match the characters the constitute the token YEAR
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mYEAR(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = YEAR;


    // Sparql.g:839:6: ( ( 'Y' | 'y' ) ( 'E' | 'e' ) ( 'A' | 'a' ) ( 'R' | 'r' ) )
    // Sparql.g:839:8: ( 'Y' | 'y' ) ( 'E' | 'e' ) ( 'A' | 'a' ) ( 'R' | 'r' )
    {
        if ( LA(1) == 'Y' || LA(1) == 'y' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleYEAREx;
        }


        if ( LA(1) == 'E' || LA(1) == 'e' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleYEAREx;
        }


        if ( LA(1) == 'A' || LA(1) == 'a' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleYEAREx;
        }


        if ( LA(1) == 'R' || LA(1) == 'r' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleYEAREx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleYEAREx; /* Prevent compiler warnings */
    ruleYEAREx: ;

}
// $ANTLR end YEAR

//   Comes from: 841:7: ( ( 'M' | 'm' ) ( 'O' | 'o' ) ( 'N' | 'n' ) ( 'T' | 't' ) ( 'H' | 'h' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start MONTH
 *
 * Looks to match the characters the constitute the token MONTH
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mMONTH(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = MONTH;


    // Sparql.g:841:7: ( ( 'M' | 'm' ) ( 'O' | 'o' ) ( 'N' | 'n' ) ( 'T' | 't' ) ( 'H' | 'h' ) )
    // Sparql.g:841:9: ( 'M' | 'm' ) ( 'O' | 'o' ) ( 'N' | 'n' ) ( 'T' | 't' ) ( 'H' | 'h' )
    {
        if ( LA(1) == 'M' || LA(1) == 'm' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleMONTHEx;
        }


        if ( LA(1) == 'O' || LA(1) == 'o' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleMONTHEx;
        }


        if ( LA(1) == 'N' || LA(1) == 'n' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleMONTHEx;
        }


        if ( LA(1) == 'T' || LA(1) == 't' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleMONTHEx;
        }


        if ( LA(1) == 'H' || LA(1) == 'h' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleMONTHEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleMONTHEx; /* Prevent compiler warnings */
    ruleMONTHEx: ;

}
// $ANTLR end MONTH

//   Comes from: 843:5: ( ( 'D' | 'd' ) ( 'A' | 'a' ) ( 'Y' | 'y' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start DAY
 *
 * Looks to match the characters the constitute the token DAY
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mDAY(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = DAY;


    // Sparql.g:843:5: ( ( 'D' | 'd' ) ( 'A' | 'a' ) ( 'Y' | 'y' ) )
    // Sparql.g:843:7: ( 'D' | 'd' ) ( 'A' | 'a' ) ( 'Y' | 'y' )
    {
        if ( LA(1) == 'D' || LA(1) == 'd' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleDAYEx;
        }


        if ( LA(1) == 'A' || LA(1) == 'a' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleDAYEx;
        }


        if ( LA(1) == 'Y' || LA(1) == 'y' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleDAYEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleDAYEx; /* Prevent compiler warnings */
    ruleDAYEx: ;

}
// $ANTLR end DAY

//   Comes from: 845:7: ( ( 'H' | 'h' ) ( 'O' | 'o' ) ( 'U' | 'u' ) ( 'R' | 'r' ) ( 'S' | 's' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start HOURS
 *
 * Looks to match the characters the constitute the token HOURS
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mHOURS(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = HOURS;


    // Sparql.g:845:7: ( ( 'H' | 'h' ) ( 'O' | 'o' ) ( 'U' | 'u' ) ( 'R' | 'r' ) ( 'S' | 's' ) )
    // Sparql.g:845:9: ( 'H' | 'h' ) ( 'O' | 'o' ) ( 'U' | 'u' ) ( 'R' | 'r' ) ( 'S' | 's' )
    {
        if ( LA(1) == 'H' || LA(1) == 'h' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleHOURSEx;
        }


        if ( LA(1) == 'O' || LA(1) == 'o' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleHOURSEx;
        }


        if ( LA(1) == 'U' || LA(1) == 'u' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleHOURSEx;
        }


        if ( LA(1) == 'R' || LA(1) == 'r' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleHOURSEx;
        }


        if ( LA(1) == 'S' || LA(1) == 's' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleHOURSEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleHOURSEx; /* Prevent compiler warnings */
    ruleHOURSEx: ;

}
// $ANTLR end HOURS

//   Comes from: 847:9: ( ( 'M' | 'm' ) ( 'I' | 'i' ) ( 'N' | 'n' ) ( 'U' | 'u' ) ( 'T' | 't' ) ( 'E' | 'e' ) ( 'S' | 's' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start MINUTES
 *
 * Looks to match the characters the constitute the token MINUTES
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mMINUTES(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = MINUTES;


    // Sparql.g:847:9: ( ( 'M' | 'm' ) ( 'I' | 'i' ) ( 'N' | 'n' ) ( 'U' | 'u' ) ( 'T' | 't' ) ( 'E' | 'e' ) ( 'S' | 's' ) )
    // Sparql.g:847:11: ( 'M' | 'm' ) ( 'I' | 'i' ) ( 'N' | 'n' ) ( 'U' | 'u' ) ( 'T' | 't' ) ( 'E' | 'e' ) ( 'S' | 's' )
    {
        if ( LA(1) == 'M' || LA(1) == 'm' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleMINUTESEx;
        }


        if ( LA(1) == 'I' || LA(1) == 'i' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleMINUTESEx;
        }


        if ( LA(1) == 'N' || LA(1) == 'n' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleMINUTESEx;
        }


        if ( LA(1) == 'U' || LA(1) == 'u' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleMINUTESEx;
        }


        if ( LA(1) == 'T' || LA(1) == 't' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleMINUTESEx;
        }


        if ( LA(1) == 'E' || LA(1) == 'e' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleMINUTESEx;
        }


        if ( LA(1) == 'S' || LA(1) == 's' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleMINUTESEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleMINUTESEx; /* Prevent compiler warnings */
    ruleMINUTESEx: ;

}
// $ANTLR end MINUTES

//   Comes from: 849:9: ( ( 'S' | 's' ) ( 'E' | 'e' ) ( 'C' | 'c' ) ( 'O' | 'o' ) ( 'N' | 'n' ) ( 'M' | 'm' ) ( 'S' | 's' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SECONDS
 *
 * Looks to match the characters the constitute the token SECONDS
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mSECONDS(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = SECONDS;


    // Sparql.g:849:9: ( ( 'S' | 's' ) ( 'E' | 'e' ) ( 'C' | 'c' ) ( 'O' | 'o' ) ( 'N' | 'n' ) ( 'M' | 'm' ) ( 'S' | 's' ) )
    // Sparql.g:849:11: ( 'S' | 's' ) ( 'E' | 'e' ) ( 'C' | 'c' ) ( 'O' | 'o' ) ( 'N' | 'n' ) ( 'M' | 'm' ) ( 'S' | 's' )
    {
        if ( LA(1) == 'S' || LA(1) == 's' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleSECONDSEx;
        }


        if ( LA(1) == 'E' || LA(1) == 'e' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleSECONDSEx;
        }


        if ( LA(1) == 'C' || LA(1) == 'c' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleSECONDSEx;
        }


        if ( LA(1) == 'O' || LA(1) == 'o' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleSECONDSEx;
        }


        if ( LA(1) == 'N' || LA(1) == 'n' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleSECONDSEx;
        }


        if ( LA(1) == 'M' || LA(1) == 'm' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleSECONDSEx;
        }


        if ( LA(1) == 'S' || LA(1) == 's' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleSECONDSEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleSECONDSEx; /* Prevent compiler warnings */
    ruleSECONDSEx: ;

}
// $ANTLR end SECONDS

//   Comes from: 851:10: ( ( 'T' | 't' ) ( 'I' | 'i' ) ( 'M' | 'm' ) ( 'E' | 'e' ) ( 'Z' | 'z' ) ( 'O' | 'o' ) ( 'N' | 'n' ) ( 'E' | 'e' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TIMEZONE
 *
 * Looks to match the characters the constitute the token TIMEZONE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTIMEZONE(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TIMEZONE;


    // Sparql.g:851:10: ( ( 'T' | 't' ) ( 'I' | 'i' ) ( 'M' | 'm' ) ( 'E' | 'e' ) ( 'Z' | 'z' ) ( 'O' | 'o' ) ( 'N' | 'n' ) ( 'E' | 'e' ) )
    // Sparql.g:851:13: ( 'T' | 't' ) ( 'I' | 'i' ) ( 'M' | 'm' ) ( 'E' | 'e' ) ( 'Z' | 'z' ) ( 'O' | 'o' ) ( 'N' | 'n' ) ( 'E' | 'e' )
    {
        if ( LA(1) == 'T' || LA(1) == 't' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleTIMEZONEEx;
        }


        if ( LA(1) == 'I' || LA(1) == 'i' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleTIMEZONEEx;
        }


        if ( LA(1) == 'M' || LA(1) == 'm' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleTIMEZONEEx;
        }


        if ( LA(1) == 'E' || LA(1) == 'e' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleTIMEZONEEx;
        }


        if ( LA(1) == 'Z' || LA(1) == 'z' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleTIMEZONEEx;
        }


        if ( LA(1) == 'O' || LA(1) == 'o' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleTIMEZONEEx;
        }


        if ( LA(1) == 'N' || LA(1) == 'n' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleTIMEZONEEx;
        }


        if ( LA(1) == 'E' || LA(1) == 'e' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleTIMEZONEEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleTIMEZONEEx; /* Prevent compiler warnings */
    ruleTIMEZONEEx: ;

}
// $ANTLR end TIMEZONE

//   Comes from: 853:4: ( ( 'T' | 't' ) ( 'Z' | 'z' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TZ
 *
 * Looks to match the characters the constitute the token TZ
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTZ(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TZ;


    // Sparql.g:853:4: ( ( 'T' | 't' ) ( 'Z' | 'z' ) )
    // Sparql.g:853:6: ( 'T' | 't' ) ( 'Z' | 'z' )
    {
        if ( LA(1) == 'T' || LA(1) == 't' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleTZEx;
        }


        if ( LA(1) == 'Z' || LA(1) == 'z' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleTZEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleTZEx; /* Prevent compiler warnings */
    ruleTZEx: ;

}
// $ANTLR end TZ

//   Comes from: 855:5: ( ( 'N' | 'n' ) ( 'O' | 'o' ) ( 'W' | 'w' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start NOW
 *
 * Looks to match the characters the constitute the token NOW
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mNOW(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = NOW;


    // Sparql.g:855:5: ( ( 'N' | 'n' ) ( 'O' | 'o' ) ( 'W' | 'w' ) )
    // Sparql.g:855:7: ( 'N' | 'n' ) ( 'O' | 'o' ) ( 'W' | 'w' )
    {
        if ( LA(1) == 'N' || LA(1) == 'n' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleNOWEx;
        }


        if ( LA(1) == 'O' || LA(1) == 'o' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleNOWEx;
        }


        if ( LA(1) == 'W' || LA(1) == 'w' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleNOWEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleNOWEx; /* Prevent compiler warnings */
    ruleNOWEx: ;

}
// $ANTLR end NOW

//   Comes from: 857:5: ( ( 'M' | 'm' ) ( 'M' | 'm' ) '5' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start MD5
 *
 * Looks to match the characters the constitute the token MD5
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mMD5(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = MD5;


    // Sparql.g:857:5: ( ( 'M' | 'm' ) ( 'M' | 'm' ) '5' )
    // Sparql.g:857:7: ( 'M' | 'm' ) ( 'M' | 'm' ) '5'
    {
        if ( LA(1) == 'M' || LA(1) == 'm' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleMD5Ex;
        }


        if ( LA(1) == 'M' || LA(1) == 'm' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleMD5Ex;
        }


        MATCHC('5');
        if  (HASEXCEPTION())
        {
            goto ruleMD5Ex;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleMD5Ex; /* Prevent compiler warnings */
    ruleMD5Ex: ;

}
// $ANTLR end MD5

//   Comes from: 859:6: ( ( 'S' | 's' ) ( 'H' | 'h' ) ( 'A' | 'a' ) '1' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SHA1
 *
 * Looks to match the characters the constitute the token SHA1
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mSHA1(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = SHA1;


    // Sparql.g:859:6: ( ( 'S' | 's' ) ( 'H' | 'h' ) ( 'A' | 'a' ) '1' )
    // Sparql.g:859:8: ( 'S' | 's' ) ( 'H' | 'h' ) ( 'A' | 'a' ) '1'
    {
        if ( LA(1) == 'S' || LA(1) == 's' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleSHA1Ex;
        }


        if ( LA(1) == 'H' || LA(1) == 'h' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleSHA1Ex;
        }


        if ( LA(1) == 'A' || LA(1) == 'a' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleSHA1Ex;
        }


        MATCHC('1');
        if  (HASEXCEPTION())
        {
            goto ruleSHA1Ex;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleSHA1Ex; /* Prevent compiler warnings */
    ruleSHA1Ex: ;

}
// $ANTLR end SHA1

//   Comes from: 861:8: ( ( 'S' | 's' ) ( 'H' | 'h' ) ( 'A' | 'a' ) '224' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SHA224
 *
 * Looks to match the characters the constitute the token SHA224
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mSHA224(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = SHA224;


    // Sparql.g:861:8: ( ( 'S' | 's' ) ( 'H' | 'h' ) ( 'A' | 'a' ) '224' )
    // Sparql.g:861:10: ( 'S' | 's' ) ( 'H' | 'h' ) ( 'A' | 'a' ) '224'
    {
        if ( LA(1) == 'S' || LA(1) == 's' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleSHA224Ex;
        }


        if ( LA(1) == 'H' || LA(1) == 'h' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleSHA224Ex;
        }


        if ( LA(1) == 'A' || LA(1) == 'a' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleSHA224Ex;
        }


        MATCHS(lit_1);
        if  (HASEXCEPTION())
        {
            goto ruleSHA224Ex;
        }
        if (HASFAILED())
        {
            return ;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleSHA224Ex; /* Prevent compiler warnings */
    ruleSHA224Ex: ;

}
// $ANTLR end SHA224

//   Comes from: 863:8: ( ( 'S' | 's' ) ( 'H' | 'h' ) ( 'A' | 'a' ) '256' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SHA256
 *
 * Looks to match the characters the constitute the token SHA256
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mSHA256(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = SHA256;


    // Sparql.g:863:8: ( ( 'S' | 's' ) ( 'H' | 'h' ) ( 'A' | 'a' ) '256' )
    // Sparql.g:863:10: ( 'S' | 's' ) ( 'H' | 'h' ) ( 'A' | 'a' ) '256'
    {
        if ( LA(1) == 'S' || LA(1) == 's' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleSHA256Ex;
        }


        if ( LA(1) == 'H' || LA(1) == 'h' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleSHA256Ex;
        }


        if ( LA(1) == 'A' || LA(1) == 'a' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleSHA256Ex;
        }


        MATCHS(lit_2);
        if  (HASEXCEPTION())
        {
            goto ruleSHA256Ex;
        }
        if (HASFAILED())
        {
            return ;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleSHA256Ex; /* Prevent compiler warnings */
    ruleSHA256Ex: ;

}
// $ANTLR end SHA256

//   Comes from: 865:8: ( ( 'S' | 's' ) ( 'H' | 'h' ) ( 'A' | 'a' ) '384' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SHA384
 *
 * Looks to match the characters the constitute the token SHA384
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mSHA384(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = SHA384;


    // Sparql.g:865:8: ( ( 'S' | 's' ) ( 'H' | 'h' ) ( 'A' | 'a' ) '384' )
    // Sparql.g:865:10: ( 'S' | 's' ) ( 'H' | 'h' ) ( 'A' | 'a' ) '384'
    {
        if ( LA(1) == 'S' || LA(1) == 's' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleSHA384Ex;
        }


        if ( LA(1) == 'H' || LA(1) == 'h' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleSHA384Ex;
        }


        if ( LA(1) == 'A' || LA(1) == 'a' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleSHA384Ex;
        }


        MATCHS(lit_3);
        if  (HASEXCEPTION())
        {
            goto ruleSHA384Ex;
        }
        if (HASFAILED())
        {
            return ;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleSHA384Ex; /* Prevent compiler warnings */
    ruleSHA384Ex: ;

}
// $ANTLR end SHA384

//   Comes from: 867:8: ( ( 'S' | 's' ) ( 'H' | 'h' ) ( 'A' | 'a' ) '512' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SHA512
 *
 * Looks to match the characters the constitute the token SHA512
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mSHA512(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = SHA512;


    // Sparql.g:867:8: ( ( 'S' | 's' ) ( 'H' | 'h' ) ( 'A' | 'a' ) '512' )
    // Sparql.g:867:10: ( 'S' | 's' ) ( 'H' | 'h' ) ( 'A' | 'a' ) '512'
    {
        if ( LA(1) == 'S' || LA(1) == 's' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleSHA512Ex;
        }


        if ( LA(1) == 'H' || LA(1) == 'h' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleSHA512Ex;
        }


        if ( LA(1) == 'A' || LA(1) == 'a' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleSHA512Ex;
        }


        MATCHS(lit_4);
        if  (HASEXCEPTION())
        {
            goto ruleSHA512Ex;
        }
        if (HASFAILED())
        {
            return ;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleSHA512Ex; /* Prevent compiler warnings */
    ruleSHA512Ex: ;

}
// $ANTLR end SHA512

//   Comes from: 869:10: ( ( 'C' | 'c' ) ( 'O' | 'o' ) ( 'A' | 'a' ) ( 'L' | 'l' ) ( 'E' | 'e' ) ( 'S' | 's' ) ( 'C' | 'c' ) ( 'E' | 'e' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start COALESCE
 *
 * Looks to match the characters the constitute the token COALESCE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mCOALESCE(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = COALESCE;


    // Sparql.g:869:10: ( ( 'C' | 'c' ) ( 'O' | 'o' ) ( 'A' | 'a' ) ( 'L' | 'l' ) ( 'E' | 'e' ) ( 'S' | 's' ) ( 'C' | 'c' ) ( 'E' | 'e' ) )
    // Sparql.g:869:12: ( 'C' | 'c' ) ( 'O' | 'o' ) ( 'A' | 'a' ) ( 'L' | 'l' ) ( 'E' | 'e' ) ( 'S' | 's' ) ( 'C' | 'c' ) ( 'E' | 'e' )
    {
        if ( LA(1) == 'C' || LA(1) == 'c' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleCOALESCEEx;
        }


        if ( LA(1) == 'O' || LA(1) == 'o' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleCOALESCEEx;
        }


        if ( LA(1) == 'A' || LA(1) == 'a' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleCOALESCEEx;
        }


        if ( LA(1) == 'L' || LA(1) == 'l' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleCOALESCEEx;
        }


        if ( LA(1) == 'E' || LA(1) == 'e' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleCOALESCEEx;
        }


        if ( LA(1) == 'S' || LA(1) == 's' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleCOALESCEEx;
        }


        if ( LA(1) == 'C' || LA(1) == 'c' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleCOALESCEEx;
        }


        if ( LA(1) == 'E' || LA(1) == 'e' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleCOALESCEEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleCOALESCEEx; /* Prevent compiler warnings */
    ruleCOALESCEEx: ;

}
// $ANTLR end COALESCE

//   Comes from: 871:4: ( ( 'I' | 'i' ) ( 'F' | 'f' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start IF
 *
 * Looks to match the characters the constitute the token IF
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mIF(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = IF;


    // Sparql.g:871:4: ( ( 'I' | 'i' ) ( 'F' | 'f' ) )
    // Sparql.g:871:6: ( 'I' | 'i' ) ( 'F' | 'f' )
    {
        if ( LA(1) == 'I' || LA(1) == 'i' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleIFEx;
        }


        if ( LA(1) == 'F' || LA(1) == 'f' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleIFEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleIFEx; /* Prevent compiler warnings */
    ruleIFEx: ;

}
// $ANTLR end IF

//   Comes from: 873:9: ( ( 'S' | 's' ) ( 'T' | 't' ) ( 'R' | 'r' ) ( 'L' | 'l' ) ( 'A' | 'a' ) ( 'N' | 'n' ) ( 'G' | 'g' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start STRLANG
 *
 * Looks to match the characters the constitute the token STRLANG
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mSTRLANG(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = STRLANG;


    // Sparql.g:873:9: ( ( 'S' | 's' ) ( 'T' | 't' ) ( 'R' | 'r' ) ( 'L' | 'l' ) ( 'A' | 'a' ) ( 'N' | 'n' ) ( 'G' | 'g' ) )
    // Sparql.g:873:11: ( 'S' | 's' ) ( 'T' | 't' ) ( 'R' | 'r' ) ( 'L' | 'l' ) ( 'A' | 'a' ) ( 'N' | 'n' ) ( 'G' | 'g' )
    {
        if ( LA(1) == 'S' || LA(1) == 's' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleSTRLANGEx;
        }


        if ( LA(1) == 'T' || LA(1) == 't' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleSTRLANGEx;
        }


        if ( LA(1) == 'R' || LA(1) == 'r' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleSTRLANGEx;
        }


        if ( LA(1) == 'L' || LA(1) == 'l' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleSTRLANGEx;
        }


        if ( LA(1) == 'A' || LA(1) == 'a' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleSTRLANGEx;
        }


        if ( LA(1) == 'N' || LA(1) == 'n' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleSTRLANGEx;
        }


        if ( LA(1) == 'G' || LA(1) == 'g' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleSTRLANGEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleSTRLANGEx; /* Prevent compiler warnings */
    ruleSTRLANGEx: ;

}
// $ANTLR end STRLANG

//   Comes from: 875:7: ( ( 'S' | 's' ) ( 'T' | 't' ) ( 'R' | 'r' ) ( 'D' | 'd' ) ( 'T' | 't' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start STRDT
 *
 * Looks to match the characters the constitute the token STRDT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mSTRDT(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = STRDT;


    // Sparql.g:875:7: ( ( 'S' | 's' ) ( 'T' | 't' ) ( 'R' | 'r' ) ( 'D' | 'd' ) ( 'T' | 't' ) )
    // Sparql.g:875:9: ( 'S' | 's' ) ( 'T' | 't' ) ( 'R' | 'r' ) ( 'D' | 'd' ) ( 'T' | 't' )
    {
        if ( LA(1) == 'S' || LA(1) == 's' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleSTRDTEx;
        }


        if ( LA(1) == 'T' || LA(1) == 't' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleSTRDTEx;
        }


        if ( LA(1) == 'R' || LA(1) == 'r' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleSTRDTEx;
        }


        if ( LA(1) == 'D' || LA(1) == 'd' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleSTRDTEx;
        }


        if ( LA(1) == 'T' || LA(1) == 't' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleSTRDTEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleSTRDTEx; /* Prevent compiler warnings */
    ruleSTRDTEx: ;

}
// $ANTLR end STRDT

//   Comes from: 877:11: ( ( 'I' | 'i' ) ( 'S' | 's' ) ( 'N' | 'n' ) ( 'U' | 'u' ) ( 'M' | 'm' ) ( 'E' | 'e' ) ( 'R' | 'r' ) ( 'I' | 'i' ) ( 'C' | 'c' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start ISNUMERIC
 *
 * Looks to match the characters the constitute the token ISNUMERIC
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mISNUMERIC(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = ISNUMERIC;


    // Sparql.g:877:11: ( ( 'I' | 'i' ) ( 'S' | 's' ) ( 'N' | 'n' ) ( 'U' | 'u' ) ( 'M' | 'm' ) ( 'E' | 'e' ) ( 'R' | 'r' ) ( 'I' | 'i' ) ( 'C' | 'c' ) )
    // Sparql.g:877:13: ( 'I' | 'i' ) ( 'S' | 's' ) ( 'N' | 'n' ) ( 'U' | 'u' ) ( 'M' | 'm' ) ( 'E' | 'e' ) ( 'R' | 'r' ) ( 'I' | 'i' ) ( 'C' | 'c' )
    {
        if ( LA(1) == 'I' || LA(1) == 'i' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleISNUMERICEx;
        }


        if ( LA(1) == 'S' || LA(1) == 's' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleISNUMERICEx;
        }


        if ( LA(1) == 'N' || LA(1) == 'n' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleISNUMERICEx;
        }


        if ( LA(1) == 'U' || LA(1) == 'u' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleISNUMERICEx;
        }


        if ( LA(1) == 'M' || LA(1) == 'm' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleISNUMERICEx;
        }


        if ( LA(1) == 'E' || LA(1) == 'e' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleISNUMERICEx;
        }


        if ( LA(1) == 'R' || LA(1) == 'r' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleISNUMERICEx;
        }


        if ( LA(1) == 'I' || LA(1) == 'i' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleISNUMERICEx;
        }


        if ( LA(1) == 'C' || LA(1) == 'c' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleISNUMERICEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleISNUMERICEx; /* Prevent compiler warnings */
    ruleISNUMERICEx: ;

}
// $ANTLR end ISNUMERIC

//   Comes from: 879:7: ( ( 'C' | 'c' ) ( 'O' | 'o' ) ( 'U' | 'u' ) ( 'N' | 'n' ) ( 'T' | 't' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start COUNT
 *
 * Looks to match the characters the constitute the token COUNT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mCOUNT(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = COUNT;


    // Sparql.g:879:7: ( ( 'C' | 'c' ) ( 'O' | 'o' ) ( 'U' | 'u' ) ( 'N' | 'n' ) ( 'T' | 't' ) )
    // Sparql.g:879:9: ( 'C' | 'c' ) ( 'O' | 'o' ) ( 'U' | 'u' ) ( 'N' | 'n' ) ( 'T' | 't' )
    {
        if ( LA(1) == 'C' || LA(1) == 'c' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleCOUNTEx;
        }


        if ( LA(1) == 'O' || LA(1) == 'o' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleCOUNTEx;
        }


        if ( LA(1) == 'U' || LA(1) == 'u' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleCOUNTEx;
        }


        if ( LA(1) == 'N' || LA(1) == 'n' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleCOUNTEx;
        }


        if ( LA(1) == 'T' || LA(1) == 't' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleCOUNTEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleCOUNTEx; /* Prevent compiler warnings */
    ruleCOUNTEx: ;

}
// $ANTLR end COUNT

//   Comes from: 881:5: ( ( 'S' | 's' ) ( 'U' | 'u' ) ( 'M' | 'm' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SUM
 *
 * Looks to match the characters the constitute the token SUM
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mSUM(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = SUM_PP;


    // Sparql.g:881:5: ( ( 'S' | 's' ) ( 'U' | 'u' ) ( 'M' | 'm' ) )
    // Sparql.g:881:7: ( 'S' | 's' ) ( 'U' | 'u' ) ( 'M' | 'm' )
    {
        if ( LA(1) == 'S' || LA(1) == 's' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleSUMEx;
        }


        if ( LA(1) == 'U' || LA(1) == 'u' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleSUMEx;
        }


        if ( LA(1) == 'M' || LA(1) == 'm' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleSUMEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleSUMEx; /* Prevent compiler warnings */
    ruleSUMEx: ;

}
// $ANTLR end SUM

//   Comes from: 883:5: ( ( 'M' | 'm' ) ( 'I' | 'i' ) ( 'N' | 'n' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start MIN
 *
 * Looks to match the characters the constitute the token MIN
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mMIN(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = MIN_PP;


    // Sparql.g:883:5: ( ( 'M' | 'm' ) ( 'I' | 'i' ) ( 'N' | 'n' ) )
    // Sparql.g:883:7: ( 'M' | 'm' ) ( 'I' | 'i' ) ( 'N' | 'n' )
    {
        if ( LA(1) == 'M' || LA(1) == 'm' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleMINEx;
        }


        if ( LA(1) == 'I' || LA(1) == 'i' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleMINEx;
        }


        if ( LA(1) == 'N' || LA(1) == 'n' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleMINEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleMINEx; /* Prevent compiler warnings */
    ruleMINEx: ;

}
// $ANTLR end MIN

//   Comes from: 885:5: ( ( 'M' | 'm' ) ( 'A' | 'a' ) ( 'X' | 'x' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start MAX
 *
 * Looks to match the characters the constitute the token MAX
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mMAX(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = MAX_PP;


    // Sparql.g:885:5: ( ( 'M' | 'm' ) ( 'A' | 'a' ) ( 'X' | 'x' ) )
    // Sparql.g:885:7: ( 'M' | 'm' ) ( 'A' | 'a' ) ( 'X' | 'x' )
    {
        if ( LA(1) == 'M' || LA(1) == 'm' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleMAXEx;
        }


        if ( LA(1) == 'A' || LA(1) == 'a' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleMAXEx;
        }


        if ( LA(1) == 'X' || LA(1) == 'x' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleMAXEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleMAXEx; /* Prevent compiler warnings */
    ruleMAXEx: ;

}
// $ANTLR end MAX

//   Comes from: 887:5: ( ( 'A' | 'a' ) ( 'V' | 'v' ) ( 'G' | 'g' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start AVG
 *
 * Looks to match the characters the constitute the token AVG
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mAVG(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = AVG;


    // Sparql.g:887:5: ( ( 'A' | 'a' ) ( 'V' | 'v' ) ( 'G' | 'g' ) )
    // Sparql.g:887:7: ( 'A' | 'a' ) ( 'V' | 'v' ) ( 'G' | 'g' )
    {
        if ( LA(1) == 'A' || LA(1) == 'a' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleAVGEx;
        }


        if ( LA(1) == 'V' || LA(1) == 'v' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleAVGEx;
        }


        if ( LA(1) == 'G' || LA(1) == 'g' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleAVGEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleAVGEx; /* Prevent compiler warnings */
    ruleAVGEx: ;

}
// $ANTLR end AVG

//   Comes from: 889:8: ( ( 'S' | 's' ) ( 'A' | 'a' ) ( 'M' | 'm' ) ( 'P' | 'p' ) ( 'L' | 'l' ) ( 'E' | 'e' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SAMPLE
 *
 * Looks to match the characters the constitute the token SAMPLE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mSAMPLE(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = SAMPLE;


    // Sparql.g:889:8: ( ( 'S' | 's' ) ( 'A' | 'a' ) ( 'M' | 'm' ) ( 'P' | 'p' ) ( 'L' | 'l' ) ( 'E' | 'e' ) )
    // Sparql.g:889:10: ( 'S' | 's' ) ( 'A' | 'a' ) ( 'M' | 'm' ) ( 'P' | 'p' ) ( 'L' | 'l' ) ( 'E' | 'e' )
    {
        if ( LA(1) == 'S' || LA(1) == 's' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleSAMPLEEx;
        }


        if ( LA(1) == 'A' || LA(1) == 'a' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleSAMPLEEx;
        }


        if ( LA(1) == 'M' || LA(1) == 'm' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleSAMPLEEx;
        }


        if ( LA(1) == 'P' || LA(1) == 'p' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleSAMPLEEx;
        }


        if ( LA(1) == 'L' || LA(1) == 'l' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleSAMPLEEx;
        }


        if ( LA(1) == 'E' || LA(1) == 'e' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleSAMPLEEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleSAMPLEEx; /* Prevent compiler warnings */
    ruleSAMPLEEx: ;

}
// $ANTLR end SAMPLE

//   Comes from: 891:15: ( ( 'G' | 'g' ) ( 'R' | 'r' ) ( 'O' | 'o' ) ( 'U' | 'u' ) ( 'P' | 'p' ) '_' ( 'C' | 'c' ) ( 'O' | 'o' ) ( 'N' | 'n' ) ( 'C' | 'c' ) ( 'A' | 'a' ) ( 'T' | 't' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start GROUP_CONCAT
 *
 * Looks to match the characters the constitute the token GROUP_CONCAT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mGROUP_CONCAT(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = GROUP_CONCAT;


    // Sparql.g:891:15: ( ( 'G' | 'g' ) ( 'R' | 'r' ) ( 'O' | 'o' ) ( 'U' | 'u' ) ( 'P' | 'p' ) '_' ( 'C' | 'c' ) ( 'O' | 'o' ) ( 'N' | 'n' ) ( 'C' | 'c' ) ( 'A' | 'a' ) ( 'T' | 't' ) )
    // Sparql.g:891:18: ( 'G' | 'g' ) ( 'R' | 'r' ) ( 'O' | 'o' ) ( 'U' | 'u' ) ( 'P' | 'p' ) '_' ( 'C' | 'c' ) ( 'O' | 'o' ) ( 'N' | 'n' ) ( 'C' | 'c' ) ( 'A' | 'a' ) ( 'T' | 't' )
    {
        if ( LA(1) == 'G' || LA(1) == 'g' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleGROUP_CONCATEx;
        }


        if ( LA(1) == 'R' || LA(1) == 'r' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleGROUP_CONCATEx;
        }


        if ( LA(1) == 'O' || LA(1) == 'o' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleGROUP_CONCATEx;
        }


        if ( LA(1) == 'U' || LA(1) == 'u' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleGROUP_CONCATEx;
        }


        if ( LA(1) == 'P' || LA(1) == 'p' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleGROUP_CONCATEx;
        }


        MATCHC('_');
        if  (HASEXCEPTION())
        {
            goto ruleGROUP_CONCATEx;
        }
        if (HASFAILED())
        {
            return ;
        }


        if ( LA(1) == 'C' || LA(1) == 'c' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleGROUP_CONCATEx;
        }


        if ( LA(1) == 'O' || LA(1) == 'o' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleGROUP_CONCATEx;
        }


        if ( LA(1) == 'N' || LA(1) == 'n' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleGROUP_CONCATEx;
        }


        if ( LA(1) == 'C' || LA(1) == 'c' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleGROUP_CONCATEx;
        }


        if ( LA(1) == 'A' || LA(1) == 'a' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleGROUP_CONCATEx;
        }


        if ( LA(1) == 'T' || LA(1) == 't' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleGROUP_CONCATEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleGROUP_CONCATEx; /* Prevent compiler warnings */
    ruleGROUP_CONCATEx: ;

}
// $ANTLR end GROUP_CONCAT

//   Comes from: 893:5: ( ( 'N' | 'n' ) ( 'O' | 'o' ) ( 'T' | 't' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start NOT
 *
 * Looks to match the characters the constitute the token NOT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mNOT(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = NOT;


    // Sparql.g:893:5: ( ( 'N' | 'n' ) ( 'O' | 'o' ) ( 'T' | 't' ) )
    // Sparql.g:893:7: ( 'N' | 'n' ) ( 'O' | 'o' ) ( 'T' | 't' )
    {
        if ( LA(1) == 'N' || LA(1) == 'n' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleNOTEx;
        }


        if ( LA(1) == 'O' || LA(1) == 'o' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleNOTEx;
        }


        if ( LA(1) == 'T' || LA(1) == 't' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleNOTEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleNOTEx; /* Prevent compiler warnings */
    ruleNOTEx: ;

}
// $ANTLR end NOT

//   Comes from: 895:4: ( ( 'I' | 'i' ) ( 'N' | 'n' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start IN
 *
 * Looks to match the characters the constitute the token IN
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mIN(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = IN;


    // Sparql.g:895:4: ( ( 'I' | 'i' ) ( 'N' | 'n' ) )
    // Sparql.g:895:6: ( 'I' | 'i' ) ( 'N' | 'n' )
    {
        if ( LA(1) == 'I' || LA(1) == 'i' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleINEx;
        }


        if ( LA(1) == 'N' || LA(1) == 'n' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleINEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleINEx; /* Prevent compiler warnings */
    ruleINEx: ;

}
// $ANTLR end IN

//   Comes from: 897:8: ( ( 'E' | 'e' ) ( 'X' | 'x' ) ( 'I' | 'i' ) ( 'S' | 's' ) ( 'T' | 't' ) ( 'S' | 's' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start EXISTS
 *
 * Looks to match the characters the constitute the token EXISTS
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mEXISTS(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = EXISTS;


    // Sparql.g:897:8: ( ( 'E' | 'e' ) ( 'X' | 'x' ) ( 'I' | 'i' ) ( 'S' | 's' ) ( 'T' | 't' ) ( 'S' | 's' ) )
    // Sparql.g:897:10: ( 'E' | 'e' ) ( 'X' | 'x' ) ( 'I' | 'i' ) ( 'S' | 's' ) ( 'T' | 't' ) ( 'S' | 's' )
    {
        if ( LA(1) == 'E' || LA(1) == 'e' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleEXISTSEx;
        }


        if ( LA(1) == 'X' || LA(1) == 'x' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleEXISTSEx;
        }


        if ( LA(1) == 'I' || LA(1) == 'i' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleEXISTSEx;
        }


        if ( LA(1) == 'S' || LA(1) == 's' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleEXISTSEx;
        }


        if ( LA(1) == 'T' || LA(1) == 't' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleEXISTSEx;
        }


        if ( LA(1) == 'S' || LA(1) == 's' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleEXISTSEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleEXISTSEx; /* Prevent compiler warnings */
    ruleEXISTSEx: ;

}
// $ANTLR end EXISTS

//   Comes from: 899:11: ( ( 'S' | 's' ) ( 'E' | 'e' ) ( 'P' | 'p' ) ( 'A' | 'a' ) ( 'R' | 'r' ) ( 'A' | 'a' ) ( 'T' | 't' ) ( 'O' | 'o' ) ( 'R' | 'r' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SEPARATOR
 *
 * Looks to match the characters the constitute the token SEPARATOR
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mSEPARATOR(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = SEPARATOR;


    // Sparql.g:899:11: ( ( 'S' | 's' ) ( 'E' | 'e' ) ( 'P' | 'p' ) ( 'A' | 'a' ) ( 'R' | 'r' ) ( 'A' | 'a' ) ( 'T' | 't' ) ( 'O' | 'o' ) ( 'R' | 'r' ) )
    // Sparql.g:899:13: ( 'S' | 's' ) ( 'E' | 'e' ) ( 'P' | 'p' ) ( 'A' | 'a' ) ( 'R' | 'r' ) ( 'A' | 'a' ) ( 'T' | 't' ) ( 'O' | 'o' ) ( 'R' | 'r' )
    {
        if ( LA(1) == 'S' || LA(1) == 's' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleSEPARATOREx;
        }


        if ( LA(1) == 'E' || LA(1) == 'e' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleSEPARATOREx;
        }


        if ( LA(1) == 'P' || LA(1) == 'p' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleSEPARATOREx;
        }


        if ( LA(1) == 'A' || LA(1) == 'a' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleSEPARATOREx;
        }


        if ( LA(1) == 'R' || LA(1) == 'r' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleSEPARATOREx;
        }


        if ( LA(1) == 'A' || LA(1) == 'a' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleSEPARATOREx;
        }


        if ( LA(1) == 'T' || LA(1) == 't' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleSEPARATOREx;
        }


        if ( LA(1) == 'O' || LA(1) == 'o' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleSEPARATOREx;
        }


        if ( LA(1) == 'R' || LA(1) == 'r' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleSEPARATOREx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleSEPARATOREx; /* Prevent compiler warnings */
    ruleSEPARATOREx: ;

}
// $ANTLR end SEPARATOR

//   Comes from: 901:10: ( (p= PN_PREFIX )? ':' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start PNAME_NS
 *
 * Looks to match the characters the constitute the token PNAME_NS
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mPNAME_NS(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;
    pANTLR3_COMMON_TOKEN p;


    p = NULL;

    _type	    = PNAME_NS;


    // Sparql.g:901:10: ( (p= PN_PREFIX )? ':' )
    // Sparql.g:901:12: (p= PN_PREFIX )? ':'
    {
        // Sparql.g:901:13: (p= PN_PREFIX )?
        {
            int alt2=2;
            {
                int LA2_0 = LA(1);
                if ( (((LA2_0 >= 'A') && (LA2_0 <= 'Z')) || ((LA2_0 >= 'a') && (LA2_0 <= 'z')) || ((LA2_0 >= 0x00C0) && (LA2_0 <= 0x00D6)) || ((LA2_0 >= 0x00D8) && (LA2_0 <= 0x00F6)) || ((LA2_0 >= 0x00F8) && (LA2_0 <= 0x02FF)) || ((LA2_0 >= 0x0370) && (LA2_0 <= 0x037D)) || ((LA2_0 >= 0x037F) && (LA2_0 <= 0x1FFF)) || ((LA2_0 >= 0x200C) && (LA2_0 <= 0x200D)) || ((LA2_0 >= 0x2070) && (LA2_0 <= 0x218F)) || ((LA2_0 >= 0x2C00) && (LA2_0 <= 0x2FEF)) || ((LA2_0 >= 0x3001) && (LA2_0 <= 0xD7FF)) || ((LA2_0 >= 0xF900) && (LA2_0 <= 0xFDCF)) || ((LA2_0 >= 0xFDF0) && (LA2_0 <= 0xFFFD))))
                {
                    alt2=1;
                }
            }
            switch (alt2)
            {
        	case 1:
        	    // Sparql.g:901:13: p= PN_PREFIX
        	    {
        	        /* 901:13: p= PN_PREFIX */
        	        {
        	            ANTLR3_MARKER pStart3479 = GETCHARINDEX();
        	        mPN_PREFIX(ctx );
        	            if  (HASEXCEPTION())
        	            {
        	                goto rulePNAME_NSEx;
        	            }
        	            if (HASFAILED())
        	            {
        	                return ;
        	            }

        	            p = LEXSTATE->tokFactory->newToken(LEXSTATE->tokFactory);
        	            p->setType(p, ANTLR3_TOKEN_INVALID);
        	            p->setStartIndex(p, pStart3479);
        	            p->setStopIndex(p, GETCHARINDEX()-1);
        	            p->input = INPUT;
        	        }


        	    }
        	    break;

            }
        }

        MATCHC(':');
        if  (HASEXCEPTION())
        {
            goto rulePNAME_NSEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto rulePNAME_NSEx; /* Prevent compiler warnings */
    rulePNAME_NSEx: ;

    p = NULL;

}
// $ANTLR end PNAME_NS

//   Comes from: 903:10: ( PNAME_NS PN_LOCAL )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start PNAME_LN
 *
 * Looks to match the characters the constitute the token PNAME_LN
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mPNAME_LN(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = PNAME_LN;


    // Sparql.g:903:10: ( PNAME_NS PN_LOCAL )
    // Sparql.g:903:12: PNAME_NS PN_LOCAL
    {
        /* 903:12: PNAME_NS PN_LOCAL */
        mPNAME_NS(ctx );
        if  (HASEXCEPTION())
        {
            goto rulePNAME_LNEx;
        }
        if (HASFAILED())
        {
            return ;
        }



        /* 903:12: PNAME_NS PN_LOCAL */
        mPN_LOCAL(ctx );
        if  (HASEXCEPTION())
        {
            goto rulePNAME_LNEx;
        }
        if (HASFAILED())
        {
            return ;
        }



    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto rulePNAME_LNEx; /* Prevent compiler warnings */
    rulePNAME_LNEx: ;

}
// $ANTLR end PNAME_LN

//   Comes from: 905:18: ( '_:' t= PN_LOCAL )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start BLANK_NODE_LABEL
 *
 * Looks to match the characters the constitute the token BLANK_NODE_LABEL
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mBLANK_NODE_LABEL(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;
    pANTLR3_COMMON_TOKEN t;


    t = NULL;

    _type	    = BLANK_NODE_LABEL;


    // Sparql.g:905:18: ( '_:' t= PN_LOCAL )
    // Sparql.g:905:20: '_:' t= PN_LOCAL
    {
        MATCHS(lit_5);
        if  (HASEXCEPTION())
        {
            goto ruleBLANK_NODE_LABELEx;
        }
        if (HASFAILED())
        {
            return ;
        }




        /* 905:20: '_:' t= PN_LOCAL */
        {
            ANTLR3_MARKER tStart3502 = GETCHARINDEX();
        mPN_LOCAL(ctx );
            if  (HASEXCEPTION())
            {
                goto ruleBLANK_NODE_LABELEx;
            }
            if (HASFAILED())
            {
                return ;
            }

            t = LEXSTATE->tokFactory->newToken(LEXSTATE->tokFactory);
            t->setType(t, ANTLR3_TOKEN_INVALID);
            t->setStartIndex(t, tStart3502);
            t->setStopIndex(t, GETCHARINDEX()-1);
            t->input = INPUT;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleBLANK_NODE_LABELEx; /* Prevent compiler warnings */
    ruleBLANK_NODE_LABELEx: ;

    t = NULL;

}
// $ANTLR end BLANK_NODE_LABEL

//   Comes from: 907:6: ( QUESTION_MARK v= VARNAME )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start VAR1
 *
 * Looks to match the characters the constitute the token VAR1
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mVAR1(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;
    pANTLR3_COMMON_TOKEN v;


    v = NULL;

    _type	    = VAR1;


    // Sparql.g:907:6: ( QUESTION_MARK v= VARNAME )
    // Sparql.g:907:8: QUESTION_MARK v= VARNAME
    {
        /* 907:8: QUESTION_MARK v= VARNAME */
        mQUESTION_MARK(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleVAR1Ex;
        }
        if (HASFAILED())
        {
            return ;
        }



        /* 907:8: QUESTION_MARK v= VARNAME */
        {
            ANTLR3_MARKER vStart3513 = GETCHARINDEX();
        mVARNAME(ctx );
            if  (HASEXCEPTION())
            {
                goto ruleVAR1Ex;
            }
            if (HASFAILED())
            {
                return ;
            }

            v = LEXSTATE->tokFactory->newToken(LEXSTATE->tokFactory);
            v->setType(v, ANTLR3_TOKEN_INVALID);
            v->setStartIndex(v, vStart3513);
            v->setStopIndex(v, GETCHARINDEX()-1);
            v->input = INPUT;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleVAR1Ex; /* Prevent compiler warnings */
    ruleVAR1Ex: ;

    v = NULL;

}
// $ANTLR end VAR1

//   Comes from: 909:6: ( '$' v= VARNAME )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start VAR2
 *
 * Looks to match the characters the constitute the token VAR2
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mVAR2(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;
    pANTLR3_COMMON_TOKEN v;


    v = NULL;

    _type	    = VAR2;


    // Sparql.g:909:6: ( '$' v= VARNAME )
    // Sparql.g:909:8: '$' v= VARNAME
    {
        MATCHC('$');
        if  (HASEXCEPTION())
        {
            goto ruleVAR2Ex;
        }
        if (HASFAILED())
        {
            return ;
        }


        /* 909:8: '$' v= VARNAME */
        {
            ANTLR3_MARKER vStart3524 = GETCHARINDEX();
        mVARNAME(ctx );
            if  (HASEXCEPTION())
            {
                goto ruleVAR2Ex;
            }
            if (HASFAILED())
            {
                return ;
            }

            v = LEXSTATE->tokFactory->newToken(LEXSTATE->tokFactory);
            v->setType(v, ANTLR3_TOKEN_INVALID);
            v->setStartIndex(v, vStart3524);
            v->setStopIndex(v, GETCHARINDEX()-1);
            v->input = INPUT;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleVAR2Ex; /* Prevent compiler warnings */
    ruleVAR2Ex: ;

    v = NULL;

}
// $ANTLR end VAR2

//   Comes from: 911:9: ( '@' ( 'A' .. 'Z' | 'a' .. 'z' )+ ( MINUS ( 'A' .. 'Z' | 'a' .. 'z' | DIGIT )+ )* )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start LANGTAG
 *
 * Looks to match the characters the constitute the token LANGTAG
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mLANGTAG(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = LANGTAG;


    // Sparql.g:911:9: ( '@' ( 'A' .. 'Z' | 'a' .. 'z' )+ ( MINUS ( 'A' .. 'Z' | 'a' .. 'z' | DIGIT )+ )* )
    // Sparql.g:911:11: '@' ( 'A' .. 'Z' | 'a' .. 'z' )+ ( MINUS ( 'A' .. 'Z' | 'a' .. 'z' | DIGIT )+ )*
    {
        MATCHC('@');
        if  (HASEXCEPTION())
        {
            goto ruleLANGTAGEx;
        }
        if (HASFAILED())
        {
            return ;
        }


        // Sparql.g:911:15: ( 'A' .. 'Z' | 'a' .. 'z' )+
        {
            int cnt3=0;

            for (;;)
            {
                int alt3=2;
        	switch ( LA(1) )
        	{
        	case 'A':
        	case 'B':
        	case 'C':
        	case 'D':
        	case 'E':
        	case 'F':
        	case 'G':
        	case 'H':
        	case 'I':
        	case 'J':
        	case 'K':
        	case 'L':
        	case 'M':
        	case 'N':
        	case 'O':
        	case 'P':
        	case 'Q':
        	case 'R':
        	case 'S':
        	case 'T':
        	case 'U':
        	case 'V':
        	case 'W':
        	case 'X':
        	case 'Y':
        	case 'Z':
        	case 'a':
        	case 'b':
        	case 'c':
        	case 'd':
        	case 'e':
        	case 'f':
        	case 'g':
        	case 'h':
        	case 'i':
        	case 'j':
        	case 'k':
        	case 'l':
        	case 'm':
        	case 'n':
        	case 'o':
        	case 'p':
        	case 'q':
        	case 'r':
        	case 's':
        	case 't':
        	case 'u':
        	case 'v':
        	case 'w':
        	case 'x':
        	case 'y':
        	case 'z':
        		{
        			alt3=1;
        		}
        	    break;

        	}

        	switch (alt3)
        	{
        	    case 1:
        	        // Sparql.g:
        	        {
        	            if ( ((LA(1) >= 'A') && (LA(1) <= 'Z')) || ((LA(1) >= 'a') && (LA(1) <= 'z')) )
        	            {
        	                CONSUME();
        	                FAILEDFLAG=ANTLR3_FALSE;

        	            }
        	            else
        	            {
        	                if (BACKTRACKING>0)
        	                {
        	                    FAILEDFLAG = ANTLR3_TRUE;
        	                    return ;
        	                }

        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

        	                LRECOVER();
        	                goto ruleLANGTAGEx;
        	            }


        	        }
        	        break;

        	    default:

        		if ( cnt3 >= 1 )
        		{
        		    goto loop3;
        		}
        		if (BACKTRACKING>0)
        		{
        		    FAILEDFLAG = ANTLR3_TRUE;
        		    return ;
        		}

        		/* mismatchedSetEx()
        		 */
        		CONSTRUCTEX();
        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


        		goto ruleLANGTAGEx;
        	}
        	cnt3++;
            }
            loop3: ;	/* Jump to here if this rule does not match */
        }

        // Sparql.g:911:36: ( MINUS ( 'A' .. 'Z' | 'a' .. 'z' | DIGIT )+ )*

        for (;;)
        {
            int alt5=2;
            switch ( LA(1) )
            {
            case '-':
            	{
            		alt5=1;
            	}
                break;

            }

            switch (alt5)
            {
        	case 1:
        	    // Sparql.g:911:37: MINUS ( 'A' .. 'Z' | 'a' .. 'z' | DIGIT )+
        	    {
        	        /* 911:37: MINUS ( 'A' .. 'Z' | 'a' .. 'z' | DIGIT )+ */
        	        mMINUS(ctx );
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleLANGTAGEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }



        	        // Sparql.g:911:43: ( 'A' .. 'Z' | 'a' .. 'z' | DIGIT )+
        	        {
        	            int cnt4=0;

        	            for (;;)
        	            {
        	                int alt4=2;
        	        	switch ( LA(1) )
        	        	{
        	        	case '0':
        	        	case '1':
        	        	case '2':
        	        	case '3':
        	        	case '4':
        	        	case '5':
        	        	case '6':
        	        	case '7':
        	        	case '8':
        	        	case '9':
        	        	case 'A':
        	        	case 'B':
        	        	case 'C':
        	        	case 'D':
        	        	case 'E':
        	        	case 'F':
        	        	case 'G':
        	        	case 'H':
        	        	case 'I':
        	        	case 'J':
        	        	case 'K':
        	        	case 'L':
        	        	case 'M':
        	        	case 'N':
        	        	case 'O':
        	        	case 'P':
        	        	case 'Q':
        	        	case 'R':
        	        	case 'S':
        	        	case 'T':
        	        	case 'U':
        	        	case 'V':
        	        	case 'W':
        	        	case 'X':
        	        	case 'Y':
        	        	case 'Z':
        	        	case 'a':
        	        	case 'b':
        	        	case 'c':
        	        	case 'd':
        	        	case 'e':
        	        	case 'f':
        	        	case 'g':
        	        	case 'h':
        	        	case 'i':
        	        	case 'j':
        	        	case 'k':
        	        	case 'l':
        	        	case 'm':
        	        	case 'n':
        	        	case 'o':
        	        	case 'p':
        	        	case 'q':
        	        	case 'r':
        	        	case 's':
        	        	case 't':
        	        	case 'u':
        	        	case 'v':
        	        	case 'w':
        	        	case 'x':
        	        	case 'y':
        	        	case 'z':
        	        		{
        	        			alt4=1;
        	        		}
        	        	    break;

        	        	}

        	        	switch (alt4)
        	        	{
        	        	    case 1:
        	        	        // Sparql.g:
        	        	        {
        	        	            if ( ((LA(1) >= '0') && (LA(1) <= '9')) || ((LA(1) >= 'A') && (LA(1) <= 'Z')) || ((LA(1) >= 'a') && (LA(1) <= 'z')) )
        	        	            {
        	        	                CONSUME();
        	        	                FAILEDFLAG=ANTLR3_FALSE;

        	        	            }
        	        	            else
        	        	            {
        	        	                if (BACKTRACKING>0)
        	        	                {
        	        	                    FAILEDFLAG = ANTLR3_TRUE;
        	        	                    return ;
        	        	                }

        	        	                CONSTRUCTEX();
        	        	                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	        	                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

        	        	                LRECOVER();
        	        	                goto ruleLANGTAGEx;
        	        	            }


        	        	        }
        	        	        break;

        	        	    default:

        	        		if ( cnt4 >= 1 )
        	        		{
        	        		    goto loop4;
        	        		}
        	        		if (BACKTRACKING>0)
        	        		{
        	        		    FAILEDFLAG = ANTLR3_TRUE;
        	        		    return ;
        	        		}

        	        		/* mismatchedSetEx()
        	        		 */
        	        		CONSTRUCTEX();
        	        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
        	        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


        	        		goto ruleLANGTAGEx;
        	        	}
        	        	cnt4++;
        	            }
        	            loop4: ;	/* Jump to here if this rule does not match */
        	        }

        	    }
        	    break;

        	default:
        	    goto loop5;	/* break out of the loop */
        	    break;
            }
        }
        loop5: ; /* Jump out to here if this rule does not match */


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleLANGTAGEx; /* Prevent compiler warnings */
    ruleLANGTAGEx: ;

}
// $ANTLR end LANGTAG

//   Comes from: 913:9: ( ( DIGIT )+ )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start INTEGER
 *
 * Looks to match the characters the constitute the token INTEGER
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mINTEGER(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = INTEGER;


    // Sparql.g:913:9: ( ( DIGIT )+ )
    // Sparql.g:913:11: ( DIGIT )+
    {
        // Sparql.g:913:11: ( DIGIT )+
        {
            int cnt6=0;

            for (;;)
            {
                int alt6=2;
        	switch ( LA(1) )
        	{
        	case '0':
        	case '1':
        	case '2':
        	case '3':
        	case '4':
        	case '5':
        	case '6':
        	case '7':
        	case '8':
        	case '9':
        		{
        			alt6=1;
        		}
        	    break;

        	}

        	switch (alt6)
        	{
        	    case 1:
        	        // Sparql.g:
        	        {
        	            if ( ((LA(1) >= '0') && (LA(1) <= '9')) )
        	            {
        	                CONSUME();
        	                FAILEDFLAG=ANTLR3_FALSE;

        	            }
        	            else
        	            {
        	                if (BACKTRACKING>0)
        	                {
        	                    FAILEDFLAG = ANTLR3_TRUE;
        	                    return ;
        	                }

        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

        	                LRECOVER();
        	                goto ruleINTEGEREx;
        	            }


        	        }
        	        break;

        	    default:

        		if ( cnt6 >= 1 )
        		{
        		    goto loop6;
        		}
        		if (BACKTRACKING>0)
        		{
        		    FAILEDFLAG = ANTLR3_TRUE;
        		    return ;
        		}

        		/* mismatchedSetEx()
        		 */
        		CONSTRUCTEX();
        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


        		goto ruleINTEGEREx;
        	}
        	cnt6++;
            }
            loop6: ;	/* Jump to here if this rule does not match */
        }

    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleINTEGEREx; /* Prevent compiler warnings */
    ruleINTEGEREx: ;

}
// $ANTLR end INTEGER

//   Comes from: 916:5: ( ( DIGIT )+ DOT ( DIGIT )* | DOT ( DIGIT )+ )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start DECIMAL
 *
 * Looks to match the characters the constitute the token DECIMAL
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mDECIMAL(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = DECIMAL;


    {
        //  Sparql.g:916:5: ( ( DIGIT )+ DOT ( DIGIT )* | DOT ( DIGIT )+ )

        ANTLR3_UINT32 alt10;

        alt10=2;

        switch ( LA(1) )
        {
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
        	{
        		alt10=1;
        	}
            break;
        case '.':
        	{
        		alt10=2;
        	}
            break;

        default:
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            EXCEPTION->message      = (void *)"";
            EXCEPTION->decisionNum  = 10;
            EXCEPTION->state        = 0;


            goto ruleDECIMALEx;

        }

        switch (alt10)
        {
    	case 1:
    	    // Sparql.g:916:7: ( DIGIT )+ DOT ( DIGIT )*
    	    {
    	        // Sparql.g:916:7: ( DIGIT )+
    	        {
    	            int cnt7=0;

    	            for (;;)
    	            {
    	                int alt7=2;
    	        	switch ( LA(1) )
    	        	{
    	        	case '0':
    	        	case '1':
    	        	case '2':
    	        	case '3':
    	        	case '4':
    	        	case '5':
    	        	case '6':
    	        	case '7':
    	        	case '8':
    	        	case '9':
    	        		{
    	        			alt7=1;
    	        		}
    	        	    break;

    	        	}

    	        	switch (alt7)
    	        	{
    	        	    case 1:
    	        	        // Sparql.g:
    	        	        {
    	        	            if ( ((LA(1) >= '0') && (LA(1) <= '9')) )
    	        	            {
    	        	                CONSUME();
    	        	                FAILEDFLAG=ANTLR3_FALSE;

    	        	            }
    	        	            else
    	        	            {
    	        	                if (BACKTRACKING>0)
    	        	                {
    	        	                    FAILEDFLAG = ANTLR3_TRUE;
    	        	                    return ;
    	        	                }

    	        	                CONSTRUCTEX();
    	        	                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
    	        	                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

    	        	                LRECOVER();
    	        	                goto ruleDECIMALEx;
    	        	            }


    	        	        }
    	        	        break;

    	        	    default:

    	        		if ( cnt7 >= 1 )
    	        		{
    	        		    goto loop7;
    	        		}
    	        		if (BACKTRACKING>0)
    	        		{
    	        		    FAILEDFLAG = ANTLR3_TRUE;
    	        		    return ;
    	        		}

    	        		/* mismatchedSetEx()
    	        		 */
    	        		CONSTRUCTEX();
    	        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
    	        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


    	        		goto ruleDECIMALEx;
    	        	}
    	        	cnt7++;
    	            }
    	            loop7: ;	/* Jump to here if this rule does not match */
    	        }

    	        /* 916:7: ( DIGIT )+ DOT ( DIGIT )* */
    	        mDOT(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleDECIMALEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	        // Sparql.g:916:18: ( DIGIT )*

    	        for (;;)
    	        {
    	            int alt8=2;
    	            switch ( LA(1) )
    	            {
    	            case '0':
    	            case '1':
    	            case '2':
    	            case '3':
    	            case '4':
    	            case '5':
    	            case '6':
    	            case '7':
    	            case '8':
    	            case '9':
    	            	{
    	            		alt8=1;
    	            	}
    	                break;

    	            }

    	            switch (alt8)
    	            {
    	        	case 1:
    	        	    // Sparql.g:
    	        	    {
    	        	        if ( ((LA(1) >= '0') && (LA(1) <= '9')) )
    	        	        {
    	        	            CONSUME();
    	        	            FAILEDFLAG=ANTLR3_FALSE;

    	        	        }
    	        	        else
    	        	        {
    	        	            if (BACKTRACKING>0)
    	        	            {
    	        	                FAILEDFLAG = ANTLR3_TRUE;
    	        	                return ;
    	        	            }

    	        	            CONSTRUCTEX();
    	        	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
    	        	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

    	        	            LRECOVER();
    	        	            goto ruleDECIMALEx;
    	        	        }


    	        	    }
    	        	    break;

    	        	default:
    	        	    goto loop8;	/* break out of the loop */
    	        	    break;
    	            }
    	        }
    	        loop8: ; /* Jump out to here if this rule does not match */


    	    }
    	    break;
    	case 2:
    	    // Sparql.g:917:7: DOT ( DIGIT )+
    	    {
    	        /* 917:7: DOT ( DIGIT )+ */
    	        mDOT(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleDECIMALEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	        // Sparql.g:917:11: ( DIGIT )+
    	        {
    	            int cnt9=0;

    	            for (;;)
    	            {
    	                int alt9=2;
    	        	switch ( LA(1) )
    	        	{
    	        	case '0':
    	        	case '1':
    	        	case '2':
    	        	case '3':
    	        	case '4':
    	        	case '5':
    	        	case '6':
    	        	case '7':
    	        	case '8':
    	        	case '9':
    	        		{
    	        			alt9=1;
    	        		}
    	        	    break;

    	        	}

    	        	switch (alt9)
    	        	{
    	        	    case 1:
    	        	        // Sparql.g:
    	        	        {
    	        	            if ( ((LA(1) >= '0') && (LA(1) <= '9')) )
    	        	            {
    	        	                CONSUME();
    	        	                FAILEDFLAG=ANTLR3_FALSE;

    	        	            }
    	        	            else
    	        	            {
    	        	                if (BACKTRACKING>0)
    	        	                {
    	        	                    FAILEDFLAG = ANTLR3_TRUE;
    	        	                    return ;
    	        	                }

    	        	                CONSTRUCTEX();
    	        	                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
    	        	                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

    	        	                LRECOVER();
    	        	                goto ruleDECIMALEx;
    	        	            }


    	        	        }
    	        	        break;

    	        	    default:

    	        		if ( cnt9 >= 1 )
    	        		{
    	        		    goto loop9;
    	        		}
    	        		if (BACKTRACKING>0)
    	        		{
    	        		    FAILEDFLAG = ANTLR3_TRUE;
    	        		    return ;
    	        		}

    	        		/* mismatchedSetEx()
    	        		 */
    	        		CONSTRUCTEX();
    	        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
    	        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


    	        		goto ruleDECIMALEx;
    	        	}
    	        	cnt9++;
    	            }
    	            loop9: ;	/* Jump to here if this rule does not match */
    	        }

    	    }
    	    break;

        }
    }
	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleDECIMALEx; /* Prevent compiler warnings */
    ruleDECIMALEx: ;

}
// $ANTLR end DECIMAL

//   Comes from: 921:5: ( ( DIGIT )+ DOT ( DIGIT )* EXPONENT | DOT ( DIGIT )+ EXPONENT | ( DIGIT )+ EXPONENT )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start DOUBLE
 *
 * Looks to match the characters the constitute the token DOUBLE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mDOUBLE(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = DOUBLE_PP;


    {
        //  Sparql.g:921:5: ( ( DIGIT )+ DOT ( DIGIT )* EXPONENT | DOT ( DIGIT )+ EXPONENT | ( DIGIT )+ EXPONENT )

        ANTLR3_UINT32 alt15;

        alt15=3;

        alt15 = cdfa15.predict(ctx, RECOGNIZER, ISTREAM, &cdfa15);
        if  (HASEXCEPTION())
        {
            goto ruleDOUBLEEx;
        }
        if (HASFAILED())
        {
            return ;
        }

        switch (alt15)
        {
    	case 1:
    	    // Sparql.g:921:7: ( DIGIT )+ DOT ( DIGIT )* EXPONENT
    	    {
    	        // Sparql.g:921:7: ( DIGIT )+
    	        {
    	            int cnt11=0;

    	            for (;;)
    	            {
    	                int alt11=2;
    	        	switch ( LA(1) )
    	        	{
    	        	case '0':
    	        	case '1':
    	        	case '2':
    	        	case '3':
    	        	case '4':
    	        	case '5':
    	        	case '6':
    	        	case '7':
    	        	case '8':
    	        	case '9':
    	        		{
    	        			alt11=1;
    	        		}
    	        	    break;

    	        	}

    	        	switch (alt11)
    	        	{
    	        	    case 1:
    	        	        // Sparql.g:
    	        	        {
    	        	            if ( ((LA(1) >= '0') && (LA(1) <= '9')) )
    	        	            {
    	        	                CONSUME();
    	        	                FAILEDFLAG=ANTLR3_FALSE;

    	        	            }
    	        	            else
    	        	            {
    	        	                if (BACKTRACKING>0)
    	        	                {
    	        	                    FAILEDFLAG = ANTLR3_TRUE;
    	        	                    return ;
    	        	                }

    	        	                CONSTRUCTEX();
    	        	                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
    	        	                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

    	        	                LRECOVER();
    	        	                goto ruleDOUBLEEx;
    	        	            }


    	        	        }
    	        	        break;

    	        	    default:

    	        		if ( cnt11 >= 1 )
    	        		{
    	        		    goto loop11;
    	        		}
    	        		if (BACKTRACKING>0)
    	        		{
    	        		    FAILEDFLAG = ANTLR3_TRUE;
    	        		    return ;
    	        		}

    	        		/* mismatchedSetEx()
    	        		 */
    	        		CONSTRUCTEX();
    	        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
    	        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


    	        		goto ruleDOUBLEEx;
    	        	}
    	        	cnt11++;
    	            }
    	            loop11: ;	/* Jump to here if this rule does not match */
    	        }

    	        /* 921:7: ( DIGIT )+ DOT ( DIGIT )* EXPONENT */
    	        mDOT(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleDOUBLEEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	        // Sparql.g:921:18: ( DIGIT )*

    	        for (;;)
    	        {
    	            int alt12=2;
    	            switch ( LA(1) )
    	            {
    	            case '0':
    	            case '1':
    	            case '2':
    	            case '3':
    	            case '4':
    	            case '5':
    	            case '6':
    	            case '7':
    	            case '8':
    	            case '9':
    	            	{
    	            		alt12=1;
    	            	}
    	                break;

    	            }

    	            switch (alt12)
    	            {
    	        	case 1:
    	        	    // Sparql.g:
    	        	    {
    	        	        if ( ((LA(1) >= '0') && (LA(1) <= '9')) )
    	        	        {
    	        	            CONSUME();
    	        	            FAILEDFLAG=ANTLR3_FALSE;

    	        	        }
    	        	        else
    	        	        {
    	        	            if (BACKTRACKING>0)
    	        	            {
    	        	                FAILEDFLAG = ANTLR3_TRUE;
    	        	                return ;
    	        	            }

    	        	            CONSTRUCTEX();
    	        	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
    	        	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

    	        	            LRECOVER();
    	        	            goto ruleDOUBLEEx;
    	        	        }


    	        	    }
    	        	    break;

    	        	default:
    	        	    goto loop12;	/* break out of the loop */
    	        	    break;
    	            }
    	        }
    	        loop12: ; /* Jump out to here if this rule does not match */


    	        /* 921:7: ( DIGIT )+ DOT ( DIGIT )* EXPONENT */
    	        mEXPONENT(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleDOUBLEEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 2:
    	    // Sparql.g:922:7: DOT ( DIGIT )+ EXPONENT
    	    {
    	        /* 922:7: DOT ( DIGIT )+ EXPONENT */
    	        mDOT(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleDOUBLEEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	        // Sparql.g:922:11: ( DIGIT )+
    	        {
    	            int cnt13=0;

    	            for (;;)
    	            {
    	                int alt13=2;
    	        	switch ( LA(1) )
    	        	{
    	        	case '0':
    	        	case '1':
    	        	case '2':
    	        	case '3':
    	        	case '4':
    	        	case '5':
    	        	case '6':
    	        	case '7':
    	        	case '8':
    	        	case '9':
    	        		{
    	        			alt13=1;
    	        		}
    	        	    break;

    	        	}

    	        	switch (alt13)
    	        	{
    	        	    case 1:
    	        	        // Sparql.g:
    	        	        {
    	        	            if ( ((LA(1) >= '0') && (LA(1) <= '9')) )
    	        	            {
    	        	                CONSUME();
    	        	                FAILEDFLAG=ANTLR3_FALSE;

    	        	            }
    	        	            else
    	        	            {
    	        	                if (BACKTRACKING>0)
    	        	                {
    	        	                    FAILEDFLAG = ANTLR3_TRUE;
    	        	                    return ;
    	        	                }

    	        	                CONSTRUCTEX();
    	        	                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
    	        	                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

    	        	                LRECOVER();
    	        	                goto ruleDOUBLEEx;
    	        	            }


    	        	        }
    	        	        break;

    	        	    default:

    	        		if ( cnt13 >= 1 )
    	        		{
    	        		    goto loop13;
    	        		}
    	        		if (BACKTRACKING>0)
    	        		{
    	        		    FAILEDFLAG = ANTLR3_TRUE;
    	        		    return ;
    	        		}

    	        		/* mismatchedSetEx()
    	        		 */
    	        		CONSTRUCTEX();
    	        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
    	        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


    	        		goto ruleDOUBLEEx;
    	        	}
    	        	cnt13++;
    	            }
    	            loop13: ;	/* Jump to here if this rule does not match */
    	        }

    	        /* 922:7: DOT ( DIGIT )+ EXPONENT */
    	        mEXPONENT(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleDOUBLEEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 3:
    	    // Sparql.g:923:7: ( DIGIT )+ EXPONENT
    	    {
    	        // Sparql.g:923:7: ( DIGIT )+
    	        {
    	            int cnt14=0;

    	            for (;;)
    	            {
    	                int alt14=2;
    	        	switch ( LA(1) )
    	        	{
    	        	case '0':
    	        	case '1':
    	        	case '2':
    	        	case '3':
    	        	case '4':
    	        	case '5':
    	        	case '6':
    	        	case '7':
    	        	case '8':
    	        	case '9':
    	        		{
    	        			alt14=1;
    	        		}
    	        	    break;

    	        	}

    	        	switch (alt14)
    	        	{
    	        	    case 1:
    	        	        // Sparql.g:
    	        	        {
    	        	            if ( ((LA(1) >= '0') && (LA(1) <= '9')) )
    	        	            {
    	        	                CONSUME();
    	        	                FAILEDFLAG=ANTLR3_FALSE;

    	        	            }
    	        	            else
    	        	            {
    	        	                if (BACKTRACKING>0)
    	        	                {
    	        	                    FAILEDFLAG = ANTLR3_TRUE;
    	        	                    return ;
    	        	                }

    	        	                CONSTRUCTEX();
    	        	                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
    	        	                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

    	        	                LRECOVER();
    	        	                goto ruleDOUBLEEx;
    	        	            }


    	        	        }
    	        	        break;

    	        	    default:

    	        		if ( cnt14 >= 1 )
    	        		{
    	        		    goto loop14;
    	        		}
    	        		if (BACKTRACKING>0)
    	        		{
    	        		    FAILEDFLAG = ANTLR3_TRUE;
    	        		    return ;
    	        		}

    	        		/* mismatchedSetEx()
    	        		 */
    	        		CONSTRUCTEX();
    	        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
    	        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


    	        		goto ruleDOUBLEEx;
    	        	}
    	        	cnt14++;
    	            }
    	            loop14: ;	/* Jump to here if this rule does not match */
    	        }

    	        /* 923:7: ( DIGIT )+ EXPONENT */
    	        mEXPONENT(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleDOUBLEEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;

        }
    }
	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleDOUBLEEx; /* Prevent compiler warnings */
    ruleDOUBLEEx: ;

}
// $ANTLR end DOUBLE

//   Comes from: 926:18: ( PLUS INTEGER )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start INTEGER_POSITIVE
 *
 * Looks to match the characters the constitute the token INTEGER_POSITIVE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mINTEGER_POSITIVE(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = INTEGER_POSITIVE;


    // Sparql.g:926:18: ( PLUS INTEGER )
    // Sparql.g:926:20: PLUS INTEGER
    {
        /* 926:20: PLUS INTEGER */
        mPLUS(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleINTEGER_POSITIVEEx;
        }
        if (HASFAILED())
        {
            return ;
        }



        /* 926:20: PLUS INTEGER */
        mINTEGER(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleINTEGER_POSITIVEEx;
        }
        if (HASFAILED())
        {
            return ;
        }



    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleINTEGER_POSITIVEEx; /* Prevent compiler warnings */
    ruleINTEGER_POSITIVEEx: ;

}
// $ANTLR end INTEGER_POSITIVE

//   Comes from: 928:18: ( PLUS DECIMAL )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start DECIMAL_POSITIVE
 *
 * Looks to match the characters the constitute the token DECIMAL_POSITIVE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mDECIMAL_POSITIVE(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = DECIMAL_POSITIVE;


    // Sparql.g:928:18: ( PLUS DECIMAL )
    // Sparql.g:928:20: PLUS DECIMAL
    {
        /* 928:20: PLUS DECIMAL */
        mPLUS(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleDECIMAL_POSITIVEEx;
        }
        if (HASFAILED())
        {
            return ;
        }



        /* 928:20: PLUS DECIMAL */
        mDECIMAL(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleDECIMAL_POSITIVEEx;
        }
        if (HASFAILED())
        {
            return ;
        }



    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleDECIMAL_POSITIVEEx; /* Prevent compiler warnings */
    ruleDECIMAL_POSITIVEEx: ;

}
// $ANTLR end DECIMAL_POSITIVE

//   Comes from: 930:17: ( PLUS DOUBLE )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start DOUBLE_POSITIVE
 *
 * Looks to match the characters the constitute the token DOUBLE_POSITIVE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mDOUBLE_POSITIVE(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = DOUBLE_POSITIVE;


    // Sparql.g:930:17: ( PLUS DOUBLE )
    // Sparql.g:930:19: PLUS DOUBLE
    {
        /* 930:19: PLUS DOUBLE */
        mPLUS(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleDOUBLE_POSITIVEEx;
        }
        if (HASFAILED())
        {
            return ;
        }



        /* 930:19: PLUS DOUBLE */
        mDOUBLE(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleDOUBLE_POSITIVEEx;
        }
        if (HASFAILED())
        {
            return ;
        }



    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleDOUBLE_POSITIVEEx; /* Prevent compiler warnings */
    ruleDOUBLE_POSITIVEEx: ;

}
// $ANTLR end DOUBLE_POSITIVE

//   Comes from: 932:18: ( MINUS INTEGER )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start INTEGER_NEGATIVE
 *
 * Looks to match the characters the constitute the token INTEGER_NEGATIVE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mINTEGER_NEGATIVE(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = INTEGER_NEGATIVE;


    // Sparql.g:932:18: ( MINUS INTEGER )
    // Sparql.g:932:20: MINUS INTEGER
    {
        /* 932:20: MINUS INTEGER */
        mMINUS(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleINTEGER_NEGATIVEEx;
        }
        if (HASFAILED())
        {
            return ;
        }



        /* 932:20: MINUS INTEGER */
        mINTEGER(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleINTEGER_NEGATIVEEx;
        }
        if (HASFAILED())
        {
            return ;
        }



    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleINTEGER_NEGATIVEEx; /* Prevent compiler warnings */
    ruleINTEGER_NEGATIVEEx: ;

}
// $ANTLR end INTEGER_NEGATIVE

//   Comes from: 934:18: ( MINUS DECIMAL )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start DECIMAL_NEGATIVE
 *
 * Looks to match the characters the constitute the token DECIMAL_NEGATIVE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mDECIMAL_NEGATIVE(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = DECIMAL_NEGATIVE;


    // Sparql.g:934:18: ( MINUS DECIMAL )
    // Sparql.g:934:20: MINUS DECIMAL
    {
        /* 934:20: MINUS DECIMAL */
        mMINUS(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleDECIMAL_NEGATIVEEx;
        }
        if (HASFAILED())
        {
            return ;
        }



        /* 934:20: MINUS DECIMAL */
        mDECIMAL(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleDECIMAL_NEGATIVEEx;
        }
        if (HASFAILED())
        {
            return ;
        }



    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleDECIMAL_NEGATIVEEx; /* Prevent compiler warnings */
    ruleDECIMAL_NEGATIVEEx: ;

}
// $ANTLR end DECIMAL_NEGATIVE

//   Comes from: 936:17: ( MINUS DOUBLE )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start DOUBLE_NEGATIVE
 *
 * Looks to match the characters the constitute the token DOUBLE_NEGATIVE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mDOUBLE_NEGATIVE(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = DOUBLE_NEGATIVE;


    // Sparql.g:936:17: ( MINUS DOUBLE )
    // Sparql.g:936:19: MINUS DOUBLE
    {
        /* 936:19: MINUS DOUBLE */
        mMINUS(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleDOUBLE_NEGATIVEEx;
        }
        if (HASFAILED())
        {
            return ;
        }



        /* 936:19: MINUS DOUBLE */
        mDOUBLE(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleDOUBLE_NEGATIVEEx;
        }
        if (HASFAILED())
        {
            return ;
        }



    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleDOUBLE_NEGATIVEEx; /* Prevent compiler warnings */
    ruleDOUBLE_NEGATIVEEx: ;

}
// $ANTLR end DOUBLE_NEGATIVE

//   Comes from: 940:10: ( ( 'e' | 'E' ) ( SIGN )? ( DIGIT )+ )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start EXPONENT
 *
 * Looks to match the characters the constitute the token EXPONENT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mEXPONENT(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;


    // Sparql.g:940:10: ( ( 'e' | 'E' ) ( SIGN )? ( DIGIT )+ )
    // Sparql.g:940:12: ( 'e' | 'E' ) ( SIGN )? ( DIGIT )+
    {
        if ( LA(1) == 'E' || LA(1) == 'e' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleEXPONENTEx;
        }


        // Sparql.g:940:22: ( SIGN )?
        {
            int alt16=2;
            switch ( LA(1) )
            {
                case '+':
                case '-':
                	{
                		alt16=1;
                	}
                    break;
            }

            switch (alt16)
            {
        	case 1:
        	    // Sparql.g:
        	    {
        	        if ( LA(1) == '+' || LA(1) == '-' )
        	        {
        	            CONSUME();
        	            FAILEDFLAG=ANTLR3_FALSE;

        	        }
        	        else
        	        {
        	            if (BACKTRACKING>0)
        	            {
        	                FAILEDFLAG = ANTLR3_TRUE;
        	                return ;
        	            }

        	            CONSTRUCTEX();
        	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

        	            LRECOVER();
        	            goto ruleEXPONENTEx;
        	        }


        	    }
        	    break;

            }
        }

        // Sparql.g:940:28: ( DIGIT )+
        {
            int cnt17=0;

            for (;;)
            {
                int alt17=2;
        	switch ( LA(1) )
        	{
        	case '0':
        	case '1':
        	case '2':
        	case '3':
        	case '4':
        	case '5':
        	case '6':
        	case '7':
        	case '8':
        	case '9':
        		{
        			alt17=1;
        		}
        	    break;

        	}

        	switch (alt17)
        	{
        	    case 1:
        	        // Sparql.g:
        	        {
        	            if ( ((LA(1) >= '0') && (LA(1) <= '9')) )
        	            {
        	                CONSUME();
        	                FAILEDFLAG=ANTLR3_FALSE;

        	            }
        	            else
        	            {
        	                if (BACKTRACKING>0)
        	                {
        	                    FAILEDFLAG = ANTLR3_TRUE;
        	                    return ;
        	                }

        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

        	                LRECOVER();
        	                goto ruleEXPONENTEx;
        	            }


        	        }
        	        break;

        	    default:

        		if ( cnt17 >= 1 )
        		{
        		    goto loop17;
        		}
        		if (BACKTRACKING>0)
        		{
        		    FAILEDFLAG = ANTLR3_TRUE;
        		    return ;
        		}

        		/* mismatchedSetEx()
        		 */
        		CONSTRUCTEX();
        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


        		goto ruleEXPONENTEx;
        	}
        	cnt17++;
            }
            loop17: ;	/* Jump to here if this rule does not match */
        }

    }


    // This is where rules clean up and exit
    //
    goto ruleEXPONENTEx; /* Prevent compiler warnings */
    ruleEXPONENTEx: ;

}
// $ANTLR end EXPONENT

//   Comes from: 941:17: ( '\\'' ( options {greedy=false; } :~ ( '\\'' | '\\\\' | EOL ) | ECHAR )* '\\'' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start STRING_LITERAL1
 *
 * Looks to match the characters the constitute the token STRING_LITERAL1
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mSTRING_LITERAL1(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = STRING_LITERAL1;


    // Sparql.g:941:17: ( '\\'' ( options {greedy=false; } :~ ( '\\'' | '\\\\' | EOL ) | ECHAR )* '\\'' )
    // Sparql.g:941:19: '\\'' ( options {greedy=false; } :~ ( '\\'' | '\\\\' | EOL ) | ECHAR )* '\\''
    {
        MATCHC('\'');
        if  (HASEXCEPTION())
        {
            goto ruleSTRING_LITERAL1Ex;
        }
        if (HASFAILED())
        {
            return ;
        }


        // Sparql.g:941:24: ( options {greedy=false; } :~ ( '\\'' | '\\\\' | EOL ) | ECHAR )*

        for (;;)
        {
            int alt18=3;
            {
               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                */
                int LA18_0 = LA(1);
                if ( (((LA18_0 >= 0x0000) && (LA18_0 <= '\t')) || ((LA18_0 >= 0x000B) && (LA18_0 <= '\f')) || ((LA18_0 >= 0x000E) && (LA18_0 <= '&')) || ((LA18_0 >= '(') && (LA18_0 <= '[')) || ((LA18_0 >= ']') && (LA18_0 <= 0xFFFF))))
                {
                    alt18=1;
                }
                else if ( (LA18_0 == '\\'))
                {
                    alt18=2;
                }
                else if ( (LA18_0 == '\''))
                {
                    alt18=3;
                }

            }
            switch (alt18)
            {
        	case 1:
        	    // Sparql.g:941:51: ~ ( '\\'' | '\\\\' | EOL )
        	    {
        	        if ( ((LA(1) >= 0x0000) && (LA(1) <= '\t')) || ((LA(1) >= 0x000B) && (LA(1) <= '\f')) || ((LA(1) >= 0x000E) && (LA(1) <= '&')) || ((LA(1) >= '(') && (LA(1) <= '[')) || ((LA(1) >= ']') && (LA(1) <= 0xFFFF)) )
        	        {
        	            CONSUME();
        	            FAILEDFLAG=ANTLR3_FALSE;

        	        }
        	        else
        	        {
        	            if (BACKTRACKING>0)
        	            {
        	                FAILEDFLAG = ANTLR3_TRUE;
        	                return ;
        	            }

        	            CONSTRUCTEX();
        	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

        	            LRECOVER();
        	            goto ruleSTRING_LITERAL1Ex;
        	        }


        	    }
        	    break;
        	case 2:
        	    // Sparql.g:941:74: ECHAR
        	    {
        	        /* 941:74: ECHAR */
        	        mECHAR(ctx );
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleSTRING_LITERAL1Ex;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }



        	    }
        	    break;

        	default:
        	    goto loop18;	/* break out of the loop */
        	    break;
            }
        }
        loop18: ; /* Jump out to here if this rule does not match */


        MATCHC('\'');
        if  (HASEXCEPTION())
        {
            goto ruleSTRING_LITERAL1Ex;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleSTRING_LITERAL1Ex; /* Prevent compiler warnings */
    ruleSTRING_LITERAL1Ex: ;

}
// $ANTLR end STRING_LITERAL1

//   Comes from: 943:17: ( '\"' ( options {greedy=false; } :~ ( '\"' | '\\\\' | EOL ) | ECHAR )* '\"' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start STRING_LITERAL2
 *
 * Looks to match the characters the constitute the token STRING_LITERAL2
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mSTRING_LITERAL2(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = STRING_LITERAL2;


    // Sparql.g:943:17: ( '\"' ( options {greedy=false; } :~ ( '\"' | '\\\\' | EOL ) | ECHAR )* '\"' )
    // Sparql.g:943:19: '\"' ( options {greedy=false; } :~ ( '\"' | '\\\\' | EOL ) | ECHAR )* '\"'
    {
        MATCHC('"');
        if  (HASEXCEPTION())
        {
            goto ruleSTRING_LITERAL2Ex;
        }
        if (HASFAILED())
        {
            return ;
        }


        // Sparql.g:943:23: ( options {greedy=false; } :~ ( '\"' | '\\\\' | EOL ) | ECHAR )*

        for (;;)
        {
            int alt19=3;
            {
               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                */
                int LA19_0 = LA(1);
                if ( (((LA19_0 >= 0x0000) && (LA19_0 <= '\t')) || ((LA19_0 >= 0x000B) && (LA19_0 <= '\f')) || ((LA19_0 >= 0x000E) && (LA19_0 <= '!')) || ((LA19_0 >= '#') && (LA19_0 <= '[')) || ((LA19_0 >= ']') && (LA19_0 <= 0xFFFF))))
                {
                    alt19=1;
                }
                else if ( (LA19_0 == '\\'))
                {
                    alt19=2;
                }
                else if ( (LA19_0 == '"'))
                {
                    alt19=3;
                }

            }
            switch (alt19)
            {
        	case 1:
        	    // Sparql.g:943:50: ~ ( '\"' | '\\\\' | EOL )
        	    {
        	        if ( ((LA(1) >= 0x0000) && (LA(1) <= '\t')) || ((LA(1) >= 0x000B) && (LA(1) <= '\f')) || ((LA(1) >= 0x000E) && (LA(1) <= '!')) || ((LA(1) >= '#') && (LA(1) <= '[')) || ((LA(1) >= ']') && (LA(1) <= 0xFFFF)) )
        	        {
        	            CONSUME();
        	            FAILEDFLAG=ANTLR3_FALSE;

        	        }
        	        else
        	        {
        	            if (BACKTRACKING>0)
        	            {
        	                FAILEDFLAG = ANTLR3_TRUE;
        	                return ;
        	            }

        	            CONSTRUCTEX();
        	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

        	            LRECOVER();
        	            goto ruleSTRING_LITERAL2Ex;
        	        }


        	    }
        	    break;
        	case 2:
        	    // Sparql.g:943:72: ECHAR
        	    {
        	        /* 943:72: ECHAR */
        	        mECHAR(ctx );
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleSTRING_LITERAL2Ex;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }



        	    }
        	    break;

        	default:
        	    goto loop19;	/* break out of the loop */
        	    break;
            }
        }
        loop19: ; /* Jump out to here if this rule does not match */


        MATCHC('"');
        if  (HASEXCEPTION())
        {
            goto ruleSTRING_LITERAL2Ex;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleSTRING_LITERAL2Ex; /* Prevent compiler warnings */
    ruleSTRING_LITERAL2Ex: ;

}
// $ANTLR end STRING_LITERAL2

//   Comes from: 945:22: ( '\\'\\'\\'' ( options {greedy=false; } : ( '\\'' | '\\'\\'' )? (~ ( '\\'' | '\\\\' ) | ECHAR ) )* '\\'\\'\\'' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start STRING_LITERAL_LONG1
 *
 * Looks to match the characters the constitute the token STRING_LITERAL_LONG1
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mSTRING_LITERAL_LONG1(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = STRING_LITERAL_LONG1;


    // Sparql.g:945:22: ( '\\'\\'\\'' ( options {greedy=false; } : ( '\\'' | '\\'\\'' )? (~ ( '\\'' | '\\\\' ) | ECHAR ) )* '\\'\\'\\'' )
    // Sparql.g:945:24: '\\'\\'\\'' ( options {greedy=false; } : ( '\\'' | '\\'\\'' )? (~ ( '\\'' | '\\\\' ) | ECHAR ) )* '\\'\\'\\''
    {
        MATCHS(lit_6);
        if  (HASEXCEPTION())
        {
            goto ruleSTRING_LITERAL_LONG1Ex;
        }
        if (HASFAILED())
        {
            return ;
        }




        // Sparql.g:945:33: ( options {greedy=false; } : ( '\\'' | '\\'\\'' )? (~ ( '\\'' | '\\\\' ) | ECHAR ) )*

        for (;;)
        {
            int alt22=2;
            {
               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                */
                int LA22_0 = LA(1);
                if ( (LA22_0 == '\''))
                {
                    {
                       /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                        */
                        int LA22_1 = LA(2);
                        if ( (LA22_1 == '\''))
                        {
                            {
                               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                                */
                                int LA22_3 = LA(3);
                                if ( (LA22_3 == '\''))
                                {
                                    alt22=2;
                                }
                                else if ( (((LA22_3 >= 0x0000) && (LA22_3 <= '&')) || ((LA22_3 >= '(') && (LA22_3 <= 0xFFFF))))
                                {
                                    alt22=1;
                                }

                            }
                        }
                        else if ( (((LA22_1 >= 0x0000) && (LA22_1 <= '&')) || ((LA22_1 >= '(') && (LA22_1 <= 0xFFFF))))
                        {
                            alt22=1;
                        }

                    }
                }
                else if ( (((LA22_0 >= 0x0000) && (LA22_0 <= '&')) || ((LA22_0 >= '(') && (LA22_0 <= 0xFFFF))))
                {
                    alt22=1;
                }

            }
            switch (alt22)
            {
        	case 1:
        	    // Sparql.g:945:60: ( '\\'' | '\\'\\'' )? (~ ( '\\'' | '\\\\' ) | ECHAR )
        	    {
        	        // Sparql.g:945:60: ( '\\'' | '\\'\\'' )?
        	        {
        	            int alt20=3;
        	            switch ( LA(1) )
        	            {
        	                case '\'':
        	                	{
        	                		{
        	                		    int LA20_1 = LA(2);
        	                		    if ( (LA20_1 == '\''))
        	                		    {
        	                		        alt20=2;
        	                		    }
        	                		    else if ( (((LA20_1 >= 0x0000) && (LA20_1 <= '&')) || ((LA20_1 >= '(') && (LA20_1 <= 0xFFFF))))
        	                		    {
        	                		        alt20=1;
        	                		    }
        	                		}
        	                	}
        	                    break;
        	            }

        	            switch (alt20)
        	            {
        	        	case 1:
        	        	    // Sparql.g:945:61: '\\''
        	        	    {
        	        	        MATCHC('\'');
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleSTRING_LITERAL_LONG1Ex;
        	        	        }
        	        	        if (HASFAILED())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // Sparql.g:945:68: '\\'\\''
        	        	    {
        	        	        MATCHS(lit_7);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleSTRING_LITERAL_LONG1Ex;
        	        	        }
        	        	        if (HASFAILED())
        	        	        {
        	        	            return ;
        	        	        }




        	        	    }
        	        	    break;

        	            }
        	        }

        	        // Sparql.g:945:77: (~ ( '\\'' | '\\\\' ) | ECHAR )
        	        {
        	            int alt21=2;
        	            {
        	                int LA21_0 = LA(1);
        	                if ( (((LA21_0 >= 0x0000) && (LA21_0 <= '&')) || ((LA21_0 >= '(') && (LA21_0 <= '[')) || ((LA21_0 >= ']') && (LA21_0 <= 0xFFFF))))
        	                {
        	                    alt21=1;
        	                }
        	                else if ( (LA21_0 == '\\'))
        	                {
        	                    alt21=2;
        	                }
        	                else
        	                {
        	                    if (BACKTRACKING>0)
        	                    {
        	                        FAILEDFLAG = ANTLR3_TRUE;
        	                        return ;
        	                    }


        	                    CONSTRUCTEX();
        	                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                    EXCEPTION->message      = (void *)"";
        	                    EXCEPTION->decisionNum  = 21;
        	                    EXCEPTION->state        = 0;


        	                    goto ruleSTRING_LITERAL_LONG1Ex;

        	                }
        	            }
        	            switch (alt21)
        	            {
        	        	case 1:
        	        	    // Sparql.g:945:78: ~ ( '\\'' | '\\\\' )
        	        	    {
        	        	        if ( ((LA(1) >= 0x0000) && (LA(1) <= '&')) || ((LA(1) >= '(') && (LA(1) <= '[')) || ((LA(1) >= ']') && (LA(1) <= 0xFFFF)) )
        	        	        {
        	        	            CONSUME();
        	        	            FAILEDFLAG=ANTLR3_FALSE;

        	        	        }
        	        	        else
        	        	        {
        	        	            if (BACKTRACKING>0)
        	        	            {
        	        	                FAILEDFLAG = ANTLR3_TRUE;
        	        	                return ;
        	        	            }

        	        	            CONSTRUCTEX();
        	        	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	        	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

        	        	            LRECOVER();
        	        	            goto ruleSTRING_LITERAL_LONG1Ex;
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // Sparql.g:945:93: ECHAR
        	        	    {
        	        	        /* 945:93: ECHAR */
        	        	        mECHAR(ctx );
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleSTRING_LITERAL_LONG1Ex;
        	        	        }
        	        	        if (HASFAILED())
        	        	        {
        	        	            return ;
        	        	        }



        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;

        	default:
        	    goto loop22;	/* break out of the loop */
        	    break;
            }
        }
        loop22: ; /* Jump out to here if this rule does not match */


        MATCHS(lit_6);
        if  (HASEXCEPTION())
        {
            goto ruleSTRING_LITERAL_LONG1Ex;
        }
        if (HASFAILED())
        {
            return ;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleSTRING_LITERAL_LONG1Ex; /* Prevent compiler warnings */
    ruleSTRING_LITERAL_LONG1Ex: ;

}
// $ANTLR end STRING_LITERAL_LONG1

//   Comes from: 947:22: ( '\"\"\"' ( options {greedy=false; } : ( '\"' | '\"\"' )? (~ ( '\"' | '\\\\' ) | ECHAR ) )* '\"\"\"' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start STRING_LITERAL_LONG2
 *
 * Looks to match the characters the constitute the token STRING_LITERAL_LONG2
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mSTRING_LITERAL_LONG2(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = STRING_LITERAL_LONG2;


    // Sparql.g:947:22: ( '\"\"\"' ( options {greedy=false; } : ( '\"' | '\"\"' )? (~ ( '\"' | '\\\\' ) | ECHAR ) )* '\"\"\"' )
    // Sparql.g:947:24: '\"\"\"' ( options {greedy=false; } : ( '\"' | '\"\"' )? (~ ( '\"' | '\\\\' ) | ECHAR ) )* '\"\"\"'
    {
        MATCHS(lit_8);
        if  (HASEXCEPTION())
        {
            goto ruleSTRING_LITERAL_LONG2Ex;
        }
        if (HASFAILED())
        {
            return ;
        }




        // Sparql.g:947:30: ( options {greedy=false; } : ( '\"' | '\"\"' )? (~ ( '\"' | '\\\\' ) | ECHAR ) )*

        for (;;)
        {
            int alt25=2;
            {
               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                */
                int LA25_0 = LA(1);
                if ( (LA25_0 == '"'))
                {
                    {
                       /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                        */
                        int LA25_1 = LA(2);
                        if ( (LA25_1 == '"'))
                        {
                            {
                               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                                */
                                int LA25_3 = LA(3);
                                if ( (LA25_3 == '"'))
                                {
                                    alt25=2;
                                }
                                else if ( (((LA25_3 >= 0x0000) && (LA25_3 <= '!')) || ((LA25_3 >= '#') && (LA25_3 <= 0xFFFF))))
                                {
                                    alt25=1;
                                }

                            }
                        }
                        else if ( (((LA25_1 >= 0x0000) && (LA25_1 <= '!')) || ((LA25_1 >= '#') && (LA25_1 <= 0xFFFF))))
                        {
                            alt25=1;
                        }

                    }
                }
                else if ( (((LA25_0 >= 0x0000) && (LA25_0 <= '!')) || ((LA25_0 >= '#') && (LA25_0 <= 0xFFFF))))
                {
                    alt25=1;
                }

            }
            switch (alt25)
            {
        	case 1:
        	    // Sparql.g:947:57: ( '\"' | '\"\"' )? (~ ( '\"' | '\\\\' ) | ECHAR )
        	    {
        	        // Sparql.g:947:57: ( '\"' | '\"\"' )?
        	        {
        	            int alt23=3;
        	            switch ( LA(1) )
        	            {
        	                case '"':
        	                	{
        	                		{
        	                		    int LA23_1 = LA(2);
        	                		    if ( (LA23_1 == '"'))
        	                		    {
        	                		        alt23=2;
        	                		    }
        	                		    else if ( (((LA23_1 >= 0x0000) && (LA23_1 <= '!')) || ((LA23_1 >= '#') && (LA23_1 <= 0xFFFF))))
        	                		    {
        	                		        alt23=1;
        	                		    }
        	                		}
        	                	}
        	                    break;
        	            }

        	            switch (alt23)
        	            {
        	        	case 1:
        	        	    // Sparql.g:947:58: '\"'
        	        	    {
        	        	        MATCHC('"');
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleSTRING_LITERAL_LONG2Ex;
        	        	        }
        	        	        if (HASFAILED())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // Sparql.g:947:64: '\"\"'
        	        	    {
        	        	        MATCHS(lit_9);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleSTRING_LITERAL_LONG2Ex;
        	        	        }
        	        	        if (HASFAILED())
        	        	        {
        	        	            return ;
        	        	        }




        	        	    }
        	        	    break;

        	            }
        	        }

        	        // Sparql.g:947:71: (~ ( '\"' | '\\\\' ) | ECHAR )
        	        {
        	            int alt24=2;
        	            {
        	                int LA24_0 = LA(1);
        	                if ( (((LA24_0 >= 0x0000) && (LA24_0 <= '!')) || ((LA24_0 >= '#') && (LA24_0 <= '[')) || ((LA24_0 >= ']') && (LA24_0 <= 0xFFFF))))
        	                {
        	                    alt24=1;
        	                }
        	                else if ( (LA24_0 == '\\'))
        	                {
        	                    alt24=2;
        	                }
        	                else
        	                {
        	                    if (BACKTRACKING>0)
        	                    {
        	                        FAILEDFLAG = ANTLR3_TRUE;
        	                        return ;
        	                    }


        	                    CONSTRUCTEX();
        	                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                    EXCEPTION->message      = (void *)"";
        	                    EXCEPTION->decisionNum  = 24;
        	                    EXCEPTION->state        = 0;


        	                    goto ruleSTRING_LITERAL_LONG2Ex;

        	                }
        	            }
        	            switch (alt24)
        	            {
        	        	case 1:
        	        	    // Sparql.g:947:72: ~ ( '\"' | '\\\\' )
        	        	    {
        	        	        if ( ((LA(1) >= 0x0000) && (LA(1) <= '!')) || ((LA(1) >= '#') && (LA(1) <= '[')) || ((LA(1) >= ']') && (LA(1) <= 0xFFFF)) )
        	        	        {
        	        	            CONSUME();
        	        	            FAILEDFLAG=ANTLR3_FALSE;

        	        	        }
        	        	        else
        	        	        {
        	        	            if (BACKTRACKING>0)
        	        	            {
        	        	                FAILEDFLAG = ANTLR3_TRUE;
        	        	                return ;
        	        	            }

        	        	            CONSTRUCTEX();
        	        	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	        	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

        	        	            LRECOVER();
        	        	            goto ruleSTRING_LITERAL_LONG2Ex;
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // Sparql.g:947:86: ECHAR
        	        	    {
        	        	        /* 947:86: ECHAR */
        	        	        mECHAR(ctx );
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleSTRING_LITERAL_LONG2Ex;
        	        	        }
        	        	        if (HASFAILED())
        	        	        {
        	        	            return ;
        	        	        }



        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;

        	default:
        	    goto loop25;	/* break out of the loop */
        	    break;
            }
        }
        loop25: ; /* Jump out to here if this rule does not match */


        MATCHS(lit_8);
        if  (HASEXCEPTION())
        {
            goto ruleSTRING_LITERAL_LONG2Ex;
        }
        if (HASFAILED())
        {
            return ;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleSTRING_LITERAL_LONG2Ex; /* Prevent compiler warnings */
    ruleSTRING_LITERAL_LONG2Ex: ;

}
// $ANTLR end STRING_LITERAL_LONG2

//   Comes from: 951:7: ( '\\\\' ( 't' | 'b' | 'n' | 'r' | 'f' | '\\\\' | '\"' | '\\'' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start ECHAR
 *
 * Looks to match the characters the constitute the token ECHAR
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mECHAR(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;


    // Sparql.g:951:7: ( '\\\\' ( 't' | 'b' | 'n' | 'r' | 'f' | '\\\\' | '\"' | '\\'' ) )
    // Sparql.g:951:9: '\\\\' ( 't' | 'b' | 'n' | 'r' | 'f' | '\\\\' | '\"' | '\\'' )
    {
        MATCHC('\\');
        if  (HASEXCEPTION())
        {
            goto ruleECHAREx;
        }
        if (HASFAILED())
        {
            return ;
        }


        if ( LA(1) == '"' || LA(1) == '\'' || LA(1) == '\\' || LA(1) == 'b' || LA(1) == 'f' || LA(1) == 'n' || LA(1) == 'r' || LA(1) == 't' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleECHAREx;
        }


    }


    // This is where rules clean up and exit
    //
    goto ruleECHAREx; /* Prevent compiler warnings */
    ruleECHAREx: ;

}
// $ANTLR end ECHAR

//   Comes from: 953:5: ( ( LESS ( options {greedy=false; } : IRI_REF_CHARACTERS )* GREATER )=> LESS ( options {greedy=false; } : IRI_REF_CHARACTERS )* GREATER | LESS )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start IRI_REF
 *
 * Looks to match the characters the constitute the token IRI_REF
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mIRI_REF(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = IRI_REF;


    {
        //  Sparql.g:953:5: ( ( LESS ( options {greedy=false; } : IRI_REF_CHARACTERS )* GREATER )=> LESS ( options {greedy=false; } : IRI_REF_CHARACTERS )* GREATER | LESS )

        ANTLR3_UINT32 alt27;

        alt27=2;

        switch ( LA(1) )
        {
        case '<':
        	{
        		{
        		    int LA27_1 = LA(2);
        		    if ( (synpred1_Sparql(ctx)) && (LA27_1 == '!' || ((LA27_1 >= '#') && (LA27_1 <= ';')) || LA27_1 == '=' || ((LA27_1 >= '?') && (LA27_1 <= '[')) || LA27_1 == ']' || LA27_1 == '_' || ((LA27_1 >= 'a') && (LA27_1 <= 'z')) || ((LA27_1 >= '~') && (LA27_1 <= 0xFFFF))))
        		    {
        		        alt27=1;
        		    }
        		    else if ( (synpred1_Sparql(ctx)) && (LA27_1 == '>'))
        		    {
        		        alt27=1;
        		    }
        		    else
        		    {
        		        alt27=2;
        		    }
        		}
        	}
            break;

        default:
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            EXCEPTION->message      = (void *)"";
            EXCEPTION->decisionNum  = 27;
            EXCEPTION->state        = 0;


            goto ruleIRI_REFEx;

        }

        switch (alt27)
        {
    	case 1:
    	    // Sparql.g:953:6: ( LESS ( options {greedy=false; } : IRI_REF_CHARACTERS )* GREATER )=> LESS ( options {greedy=false; } : IRI_REF_CHARACTERS )* GREATER
    	    {
    	        /* 953:6: ( LESS ( options {greedy=false; } : IRI_REF_CHARACTERS )* GREATER )=> LESS ( options {greedy=false; } : IRI_REF_CHARACTERS )* GREATER */
    	        mLESS(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleIRI_REFEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	        // Sparql.g:953:76: ( options {greedy=false; } : IRI_REF_CHARACTERS )*

    	        for (;;)
    	        {
    	            int alt26=2;
    	            {
    	               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
    	                */
    	                int LA26_0 = LA(1);
    	                if ( (LA26_0 == '!' || ((LA26_0 >= '#') && (LA26_0 <= ';')) || LA26_0 == '=' || ((LA26_0 >= '?') && (LA26_0 <= '[')) || LA26_0 == ']' || LA26_0 == '_' || ((LA26_0 >= 'a') && (LA26_0 <= 'z')) || ((LA26_0 >= '~') && (LA26_0 <= 0xFFFF))))
    	                {
    	                    alt26=1;
    	                }
    	                else if ( (LA26_0 == '>'))
    	                {
    	                    alt26=2;
    	                }

    	            }
    	            switch (alt26)
    	            {
    	        	case 1:
    	        	    // Sparql.g:953:101: IRI_REF_CHARACTERS
    	        	    {
    	        	        /* 953:101: IRI_REF_CHARACTERS */
    	        	        mIRI_REF_CHARACTERS(ctx );
    	        	        if  (HASEXCEPTION())
    	        	        {
    	        	            goto ruleIRI_REFEx;
    	        	        }
    	        	        if (HASFAILED())
    	        	        {
    	        	            return ;
    	        	        }



    	        	    }
    	        	    break;

    	        	default:
    	        	    goto loop26;	/* break out of the loop */
    	        	    break;
    	            }
    	        }
    	        loop26: ; /* Jump out to here if this rule does not match */


    	        /* 953:6: ( LESS ( options {greedy=false; } : IRI_REF_CHARACTERS )* GREATER )=> LESS ( options {greedy=false; } : IRI_REF_CHARACTERS )* GREATER */
    	        mGREATER(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleIRI_REFEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 2:
    	    // Sparql.g:954:7: LESS
    	    {
    	        /* 954:7: LESS */
    	        mLESS(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleIRI_REFEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	        if ( BACKTRACKING==0 )
    	        {
    	             _type = LESS; 
    	        }


    	    }
    	    break;

        }
    }
	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleIRI_REFEx; /* Prevent compiler warnings */
    ruleIRI_REFEx: ;

}
// $ANTLR end IRI_REF

//   Comes from: 960:5: (~ ( LESS | GREATER | '\"' | OPEN_CURLY_BRACE | CLOSE_CURLY_BRACE | PIPE | INVERSE | '`' | '\\\\' | ( '\\u0000' .. '\\u0020' ) ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start IRI_REF_CHARACTERS
 *
 * Looks to match the characters the constitute the token IRI_REF_CHARACTERS
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mIRI_REF_CHARACTERS(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;


    // Sparql.g:960:5: (~ ( LESS | GREATER | '\"' | OPEN_CURLY_BRACE | CLOSE_CURLY_BRACE | PIPE | INVERSE | '`' | '\\\\' | ( '\\u0000' .. '\\u0020' ) ) )
    // Sparql.g:
    {
        if ( LA(1) == '!' || ((LA(1) >= '#') && (LA(1) <= ';')) || LA(1) == '=' || ((LA(1) >= '?') && (LA(1) <= '[')) || LA(1) == ']' || LA(1) == '_' || ((LA(1) >= 'a') && (LA(1) <= 'z')) || ((LA(1) >= '~') && (LA(1) <= 0xFFFF)) )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleIRI_REF_CHARACTERSEx;
        }


    }


    // This is where rules clean up and exit
    //
    goto ruleIRI_REF_CHARACTERSEx; /* Prevent compiler warnings */
    ruleIRI_REF_CHARACTERSEx: ;

}
// $ANTLR end IRI_REF_CHARACTERS

//   Comes from: 964:12: ( PN_CHARS_BASE | '_' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start PN_CHARS_U
 *
 * Looks to match the characters the constitute the token PN_CHARS_U
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mPN_CHARS_U(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;


    // Sparql.g:964:12: ( PN_CHARS_BASE | '_' )
    // Sparql.g:
    {
        if ( ((LA(1) >= 'A') && (LA(1) <= 'Z')) || LA(1) == '_' || ((LA(1) >= 'a') && (LA(1) <= 'z')) || ((LA(1) >= 0x00C0) && (LA(1) <= 0x00D6)) || ((LA(1) >= 0x00D8) && (LA(1) <= 0x00F6)) || ((LA(1) >= 0x00F8) && (LA(1) <= 0x02FF)) || ((LA(1) >= 0x0370) && (LA(1) <= 0x037D)) || ((LA(1) >= 0x037F) && (LA(1) <= 0x1FFF)) || ((LA(1) >= 0x200C) && (LA(1) <= 0x200D)) || ((LA(1) >= 0x2070) && (LA(1) <= 0x218F)) || ((LA(1) >= 0x2C00) && (LA(1) <= 0x2FEF)) || ((LA(1) >= 0x3001) && (LA(1) <= 0xD7FF)) || ((LA(1) >= 0xF900) && (LA(1) <= 0xFDCF)) || ((LA(1) >= 0xFDF0) && (LA(1) <= 0xFFFD)) )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto rulePN_CHARS_UEx;
        }


    }


    // This is where rules clean up and exit
    //
    goto rulePN_CHARS_UEx; /* Prevent compiler warnings */
    rulePN_CHARS_UEx: ;

}
// $ANTLR end PN_CHARS_U

//   Comes from: 967:9: ( ( PN_CHARS_U | DIGIT ) ( PN_CHARS_U | DIGIT | '\\u00B7' | '\\u0300' .. '\\u036F' | '\\u203F' .. '\\u2040' )* )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start VARNAME
 *
 * Looks to match the characters the constitute the token VARNAME
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mVARNAME(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;


    // Sparql.g:967:9: ( ( PN_CHARS_U | DIGIT ) ( PN_CHARS_U | DIGIT | '\\u00B7' | '\\u0300' .. '\\u036F' | '\\u203F' .. '\\u2040' )* )
    // Sparql.g:967:11: ( PN_CHARS_U | DIGIT ) ( PN_CHARS_U | DIGIT | '\\u00B7' | '\\u0300' .. '\\u036F' | '\\u203F' .. '\\u2040' )*
    {
        if ( ((LA(1) >= '0') && (LA(1) <= '9')) || ((LA(1) >= 'A') && (LA(1) <= 'Z')) || LA(1) == '_' || ((LA(1) >= 'a') && (LA(1) <= 'z')) || ((LA(1) >= 0x00C0) && (LA(1) <= 0x00D6)) || ((LA(1) >= 0x00D8) && (LA(1) <= 0x00F6)) || ((LA(1) >= 0x00F8) && (LA(1) <= 0x02FF)) || ((LA(1) >= 0x0370) && (LA(1) <= 0x037D)) || ((LA(1) >= 0x037F) && (LA(1) <= 0x1FFF)) || ((LA(1) >= 0x200C) && (LA(1) <= 0x200D)) || ((LA(1) >= 0x2070) && (LA(1) <= 0x218F)) || ((LA(1) >= 0x2C00) && (LA(1) <= 0x2FEF)) || ((LA(1) >= 0x3001) && (LA(1) <= 0xD7FF)) || ((LA(1) >= 0xF900) && (LA(1) <= 0xFDCF)) || ((LA(1) >= 0xFDF0) && (LA(1) <= 0xFFFD)) )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleVARNAMEEx;
        }


        // Sparql.g:967:32: ( PN_CHARS_U | DIGIT | '\\u00B7' | '\\u0300' .. '\\u036F' | '\\u203F' .. '\\u2040' )*

        for (;;)
        {
            int alt28=2;
            {
               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                */
                int LA28_0 = LA(1);
                if ( (((LA28_0 >= '0') && (LA28_0 <= '9')) || ((LA28_0 >= 'A') && (LA28_0 <= 'Z')) || LA28_0 == '_' || ((LA28_0 >= 'a') && (LA28_0 <= 'z')) || LA28_0 == 0x00B7 || ((LA28_0 >= 0x00C0) && (LA28_0 <= 0x00D6)) || ((LA28_0 >= 0x00D8) && (LA28_0 <= 0x00F6)) || ((LA28_0 >= 0x00F8) && (LA28_0 <= 0x037D)) || ((LA28_0 >= 0x037F) && (LA28_0 <= 0x1FFF)) || ((LA28_0 >= 0x200C) && (LA28_0 <= 0x200D)) || ((LA28_0 >= 0x203F) && (LA28_0 <= 0x2040)) || ((LA28_0 >= 0x2070) && (LA28_0 <= 0x218F)) || ((LA28_0 >= 0x2C00) && (LA28_0 <= 0x2FEF)) || ((LA28_0 >= 0x3001) && (LA28_0 <= 0xD7FF)) || ((LA28_0 >= 0xF900) && (LA28_0 <= 0xFDCF)) || ((LA28_0 >= 0xFDF0) && (LA28_0 <= 0xFFFD))))
                {
                    alt28=1;
                }

            }
            switch (alt28)
            {
        	case 1:
        	    // Sparql.g:
        	    {
        	        if ( ((LA(1) >= '0') && (LA(1) <= '9')) || ((LA(1) >= 'A') && (LA(1) <= 'Z')) || LA(1) == '_' || ((LA(1) >= 'a') && (LA(1) <= 'z')) || LA(1) == 0x00B7 || ((LA(1) >= 0x00C0) && (LA(1) <= 0x00D6)) || ((LA(1) >= 0x00D8) && (LA(1) <= 0x00F6)) || ((LA(1) >= 0x00F8) && (LA(1) <= 0x037D)) || ((LA(1) >= 0x037F) && (LA(1) <= 0x1FFF)) || ((LA(1) >= 0x200C) && (LA(1) <= 0x200D)) || ((LA(1) >= 0x203F) && (LA(1) <= 0x2040)) || ((LA(1) >= 0x2070) && (LA(1) <= 0x218F)) || ((LA(1) >= 0x2C00) && (LA(1) <= 0x2FEF)) || ((LA(1) >= 0x3001) && (LA(1) <= 0xD7FF)) || ((LA(1) >= 0xF900) && (LA(1) <= 0xFDCF)) || ((LA(1) >= 0xFDF0) && (LA(1) <= 0xFFFD)) )
        	        {
        	            CONSUME();
        	            FAILEDFLAG=ANTLR3_FALSE;

        	        }
        	        else
        	        {
        	            if (BACKTRACKING>0)
        	            {
        	                FAILEDFLAG = ANTLR3_TRUE;
        	                return ;
        	            }

        	            CONSTRUCTEX();
        	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

        	            LRECOVER();
        	            goto ruleVARNAMEEx;
        	        }


        	    }
        	    break;

        	default:
        	    goto loop28;	/* break out of the loop */
        	    break;
            }
        }
        loop28: ; /* Jump out to here if this rule does not match */


    }


    // This is where rules clean up and exit
    //
    goto ruleVARNAMEEx; /* Prevent compiler warnings */
    ruleVARNAMEEx: ;

}
// $ANTLR end VARNAME

//   Comes from: 971:5: ( PN_CHARS_U | MINUS | DIGIT | '\\u00B7' | '\\u0300' .. '\\u036F' | '\\u203F' .. '\\u2040' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start PN_CHARS
 *
 * Looks to match the characters the constitute the token PN_CHARS
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mPN_CHARS(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;


    // Sparql.g:971:5: ( PN_CHARS_U | MINUS | DIGIT | '\\u00B7' | '\\u0300' .. '\\u036F' | '\\u203F' .. '\\u2040' )
    // Sparql.g:
    {
        if ( LA(1) == '-' || ((LA(1) >= '0') && (LA(1) <= '9')) || ((LA(1) >= 'A') && (LA(1) <= 'Z')) || LA(1) == '_' || ((LA(1) >= 'a') && (LA(1) <= 'z')) || LA(1) == 0x00B7 || ((LA(1) >= 0x00C0) && (LA(1) <= 0x00D6)) || ((LA(1) >= 0x00D8) && (LA(1) <= 0x00F6)) || ((LA(1) >= 0x00F8) && (LA(1) <= 0x037D)) || ((LA(1) >= 0x037F) && (LA(1) <= 0x1FFF)) || ((LA(1) >= 0x200C) && (LA(1) <= 0x200D)) || ((LA(1) >= 0x203F) && (LA(1) <= 0x2040)) || ((LA(1) >= 0x2070) && (LA(1) <= 0x218F)) || ((LA(1) >= 0x2C00) && (LA(1) <= 0x2FEF)) || ((LA(1) >= 0x3001) && (LA(1) <= 0xD7FF)) || ((LA(1) >= 0xF900) && (LA(1) <= 0xFDCF)) || ((LA(1) >= 0xFDF0) && (LA(1) <= 0xFFFD)) )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto rulePN_CHARSEx;
        }


    }


    // This is where rules clean up and exit
    //
    goto rulePN_CHARSEx; /* Prevent compiler warnings */
    rulePN_CHARSEx: ;

}
// $ANTLR end PN_CHARS

//   Comes from: 980:11: ( PN_CHARS_BASE ( ( PN_CHARS | DOT )* PN_CHARS )? )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start PN_PREFIX
 *
 * Looks to match the characters the constitute the token PN_PREFIX
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mPN_PREFIX(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;


    // Sparql.g:980:11: ( PN_CHARS_BASE ( ( PN_CHARS | DOT )* PN_CHARS )? )
    // Sparql.g:980:13: PN_CHARS_BASE ( ( PN_CHARS | DOT )* PN_CHARS )?
    {
        /* 980:13: PN_CHARS_BASE ( ( PN_CHARS | DOT )* PN_CHARS )? */
        mPN_CHARS_BASE(ctx );
        if  (HASEXCEPTION())
        {
            goto rulePN_PREFIXEx;
        }
        if (HASFAILED())
        {
            return ;
        }



        // Sparql.g:980:27: ( ( PN_CHARS | DOT )* PN_CHARS )?
        {
            int alt30=2;
            {
                int LA30_0 = LA(1);
                if ( (((LA30_0 >= '-') && (LA30_0 <= '.')) || ((LA30_0 >= '0') && (LA30_0 <= '9')) || ((LA30_0 >= 'A') && (LA30_0 <= 'Z')) || LA30_0 == '_' || ((LA30_0 >= 'a') && (LA30_0 <= 'z')) || LA30_0 == 0x00B7 || ((LA30_0 >= 0x00C0) && (LA30_0 <= 0x00D6)) || ((LA30_0 >= 0x00D8) && (LA30_0 <= 0x00F6)) || ((LA30_0 >= 0x00F8) && (LA30_0 <= 0x037D)) || ((LA30_0 >= 0x037F) && (LA30_0 <= 0x1FFF)) || ((LA30_0 >= 0x200C) && (LA30_0 <= 0x200D)) || ((LA30_0 >= 0x203F) && (LA30_0 <= 0x2040)) || ((LA30_0 >= 0x2070) && (LA30_0 <= 0x218F)) || ((LA30_0 >= 0x2C00) && (LA30_0 <= 0x2FEF)) || ((LA30_0 >= 0x3001) && (LA30_0 <= 0xD7FF)) || ((LA30_0 >= 0xF900) && (LA30_0 <= 0xFDCF)) || ((LA30_0 >= 0xFDF0) && (LA30_0 <= 0xFFFD))))
                {
                    alt30=1;
                }
            }
            switch (alt30)
            {
        	case 1:
        	    // Sparql.g:980:28: ( PN_CHARS | DOT )* PN_CHARS
        	    {
        	        // Sparql.g:980:28: ( PN_CHARS | DOT )*

        	        for (;;)
        	        {
        	            int alt29=2;
        	            {
        	               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
        	                */
        	                int LA29_0 = LA(1);
        	                if ( (LA29_0 == '-' || ((LA29_0 >= '0') && (LA29_0 <= '9')) || ((LA29_0 >= 'A') && (LA29_0 <= 'Z')) || LA29_0 == '_' || ((LA29_0 >= 'a') && (LA29_0 <= 'z')) || LA29_0 == 0x00B7 || ((LA29_0 >= 0x00C0) && (LA29_0 <= 0x00D6)) || ((LA29_0 >= 0x00D8) && (LA29_0 <= 0x00F6)) || ((LA29_0 >= 0x00F8) && (LA29_0 <= 0x037D)) || ((LA29_0 >= 0x037F) && (LA29_0 <= 0x1FFF)) || ((LA29_0 >= 0x200C) && (LA29_0 <= 0x200D)) || ((LA29_0 >= 0x203F) && (LA29_0 <= 0x2040)) || ((LA29_0 >= 0x2070) && (LA29_0 <= 0x218F)) || ((LA29_0 >= 0x2C00) && (LA29_0 <= 0x2FEF)) || ((LA29_0 >= 0x3001) && (LA29_0 <= 0xD7FF)) || ((LA29_0 >= 0xF900) && (LA29_0 <= 0xFDCF)) || ((LA29_0 >= 0xFDF0) && (LA29_0 <= 0xFFFD))))
        	                {
        	                    {
        	                       /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
        	                        */
        	                        int LA29_1 = LA(2);
        	                        if ( (((LA29_1 >= '-') && (LA29_1 <= '.')) || ((LA29_1 >= '0') && (LA29_1 <= '9')) || ((LA29_1 >= 'A') && (LA29_1 <= 'Z')) || LA29_1 == '_' || ((LA29_1 >= 'a') && (LA29_1 <= 'z')) || LA29_1 == 0x00B7 || ((LA29_1 >= 0x00C0) && (LA29_1 <= 0x00D6)) || ((LA29_1 >= 0x00D8) && (LA29_1 <= 0x00F6)) || ((LA29_1 >= 0x00F8) && (LA29_1 <= 0x037D)) || ((LA29_1 >= 0x037F) && (LA29_1 <= 0x1FFF)) || ((LA29_1 >= 0x200C) && (LA29_1 <= 0x200D)) || ((LA29_1 >= 0x203F) && (LA29_1 <= 0x2040)) || ((LA29_1 >= 0x2070) && (LA29_1 <= 0x218F)) || ((LA29_1 >= 0x2C00) && (LA29_1 <= 0x2FEF)) || ((LA29_1 >= 0x3001) && (LA29_1 <= 0xD7FF)) || ((LA29_1 >= 0xF900) && (LA29_1 <= 0xFDCF)) || ((LA29_1 >= 0xFDF0) && (LA29_1 <= 0xFFFD))))
        	                        {
        	                            alt29=1;
        	                        }

        	                    }
        	                }
        	                else if ( (LA29_0 == '.'))
        	                {
        	                    alt29=1;
        	                }

        	            }
        	            switch (alt29)
        	            {
        	        	case 1:
        	        	    // Sparql.g:
        	        	    {
        	        	        if ( ((LA(1) >= '-') && (LA(1) <= '.')) || ((LA(1) >= '0') && (LA(1) <= '9')) || ((LA(1) >= 'A') && (LA(1) <= 'Z')) || LA(1) == '_' || ((LA(1) >= 'a') && (LA(1) <= 'z')) || LA(1) == 0x00B7 || ((LA(1) >= 0x00C0) && (LA(1) <= 0x00D6)) || ((LA(1) >= 0x00D8) && (LA(1) <= 0x00F6)) || ((LA(1) >= 0x00F8) && (LA(1) <= 0x037D)) || ((LA(1) >= 0x037F) && (LA(1) <= 0x1FFF)) || ((LA(1) >= 0x200C) && (LA(1) <= 0x200D)) || ((LA(1) >= 0x203F) && (LA(1) <= 0x2040)) || ((LA(1) >= 0x2070) && (LA(1) <= 0x218F)) || ((LA(1) >= 0x2C00) && (LA(1) <= 0x2FEF)) || ((LA(1) >= 0x3001) && (LA(1) <= 0xD7FF)) || ((LA(1) >= 0xF900) && (LA(1) <= 0xFDCF)) || ((LA(1) >= 0xFDF0) && (LA(1) <= 0xFFFD)) )
        	        	        {
        	        	            CONSUME();
        	        	            FAILEDFLAG=ANTLR3_FALSE;

        	        	        }
        	        	        else
        	        	        {
        	        	            if (BACKTRACKING>0)
        	        	            {
        	        	                FAILEDFLAG = ANTLR3_TRUE;
        	        	                return ;
        	        	            }

        	        	            CONSTRUCTEX();
        	        	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	        	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

        	        	            LRECOVER();
        	        	            goto rulePN_PREFIXEx;
        	        	        }


        	        	    }
        	        	    break;

        	        	default:
        	        	    goto loop29;	/* break out of the loop */
        	        	    break;
        	            }
        	        }
        	        loop29: ; /* Jump out to here if this rule does not match */


        	        /* 980:28: ( PN_CHARS | DOT )* PN_CHARS */
        	        mPN_CHARS(ctx );
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulePN_PREFIXEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }



        	    }
        	    break;

            }
        }

    }


    // This is where rules clean up and exit
    //
    goto rulePN_PREFIXEx; /* Prevent compiler warnings */
    rulePN_PREFIXEx: ;

}
// $ANTLR end PN_PREFIX

//   Comes from: 983:10: ( ( PN_CHARS_U | DIGIT ) ( ( PN_CHARS | DOT )* PN_CHARS )? )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start PN_LOCAL
 *
 * Looks to match the characters the constitute the token PN_LOCAL
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mPN_LOCAL(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;


    // Sparql.g:983:10: ( ( PN_CHARS_U | DIGIT ) ( ( PN_CHARS | DOT )* PN_CHARS )? )
    // Sparql.g:983:12: ( PN_CHARS_U | DIGIT ) ( ( PN_CHARS | DOT )* PN_CHARS )?
    {
        if ( ((LA(1) >= '0') && (LA(1) <= '9')) || ((LA(1) >= 'A') && (LA(1) <= 'Z')) || LA(1) == '_' || ((LA(1) >= 'a') && (LA(1) <= 'z')) || ((LA(1) >= 0x00C0) && (LA(1) <= 0x00D6)) || ((LA(1) >= 0x00D8) && (LA(1) <= 0x00F6)) || ((LA(1) >= 0x00F8) && (LA(1) <= 0x02FF)) || ((LA(1) >= 0x0370) && (LA(1) <= 0x037D)) || ((LA(1) >= 0x037F) && (LA(1) <= 0x1FFF)) || ((LA(1) >= 0x200C) && (LA(1) <= 0x200D)) || ((LA(1) >= 0x2070) && (LA(1) <= 0x218F)) || ((LA(1) >= 0x2C00) && (LA(1) <= 0x2FEF)) || ((LA(1) >= 0x3001) && (LA(1) <= 0xD7FF)) || ((LA(1) >= 0xF900) && (LA(1) <= 0xFDCF)) || ((LA(1) >= 0xFDF0) && (LA(1) <= 0xFFFD)) )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto rulePN_LOCALEx;
        }


        // Sparql.g:983:32: ( ( PN_CHARS | DOT )* PN_CHARS )?
        {
            int alt32=2;
            {
                int LA32_0 = LA(1);
                if ( (((LA32_0 >= '-') && (LA32_0 <= '.')) || ((LA32_0 >= '0') && (LA32_0 <= '9')) || ((LA32_0 >= 'A') && (LA32_0 <= 'Z')) || LA32_0 == '_' || ((LA32_0 >= 'a') && (LA32_0 <= 'z')) || LA32_0 == 0x00B7 || ((LA32_0 >= 0x00C0) && (LA32_0 <= 0x00D6)) || ((LA32_0 >= 0x00D8) && (LA32_0 <= 0x00F6)) || ((LA32_0 >= 0x00F8) && (LA32_0 <= 0x037D)) || ((LA32_0 >= 0x037F) && (LA32_0 <= 0x1FFF)) || ((LA32_0 >= 0x200C) && (LA32_0 <= 0x200D)) || ((LA32_0 >= 0x203F) && (LA32_0 <= 0x2040)) || ((LA32_0 >= 0x2070) && (LA32_0 <= 0x218F)) || ((LA32_0 >= 0x2C00) && (LA32_0 <= 0x2FEF)) || ((LA32_0 >= 0x3001) && (LA32_0 <= 0xD7FF)) || ((LA32_0 >= 0xF900) && (LA32_0 <= 0xFDCF)) || ((LA32_0 >= 0xFDF0) && (LA32_0 <= 0xFFFD))))
                {
                    alt32=1;
                }
            }
            switch (alt32)
            {
        	case 1:
        	    // Sparql.g:983:33: ( PN_CHARS | DOT )* PN_CHARS
        	    {
        	        // Sparql.g:983:33: ( PN_CHARS | DOT )*

        	        for (;;)
        	        {
        	            int alt31=3;
        	            {
        	               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
        	                */
        	                int LA31_0 = LA(1);
        	                if ( (LA31_0 == '-' || ((LA31_0 >= '0') && (LA31_0 <= '9')) || ((LA31_0 >= 'A') && (LA31_0 <= 'Z')) || LA31_0 == '_' || ((LA31_0 >= 'a') && (LA31_0 <= 'z')) || LA31_0 == 0x00B7 || ((LA31_0 >= 0x00C0) && (LA31_0 <= 0x00D6)) || ((LA31_0 >= 0x00D8) && (LA31_0 <= 0x00F6)) || ((LA31_0 >= 0x00F8) && (LA31_0 <= 0x037D)) || ((LA31_0 >= 0x037F) && (LA31_0 <= 0x1FFF)) || ((LA31_0 >= 0x200C) && (LA31_0 <= 0x200D)) || ((LA31_0 >= 0x203F) && (LA31_0 <= 0x2040)) || ((LA31_0 >= 0x2070) && (LA31_0 <= 0x218F)) || ((LA31_0 >= 0x2C00) && (LA31_0 <= 0x2FEF)) || ((LA31_0 >= 0x3001) && (LA31_0 <= 0xD7FF)) || ((LA31_0 >= 0xF900) && (LA31_0 <= 0xFDCF)) || ((LA31_0 >= 0xFDF0) && (LA31_0 <= 0xFFFD))))
        	                {
        	                    {
        	                       /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
        	                        */
        	                        int LA31_1 = LA(2);
        	                        if ( (((LA31_1 >= '-') && (LA31_1 <= '.')) || ((LA31_1 >= '0') && (LA31_1 <= '9')) || ((LA31_1 >= 'A') && (LA31_1 <= 'Z')) || LA31_1 == '_' || ((LA31_1 >= 'a') && (LA31_1 <= 'z')) || LA31_1 == 0x00B7 || ((LA31_1 >= 0x00C0) && (LA31_1 <= 0x00D6)) || ((LA31_1 >= 0x00D8) && (LA31_1 <= 0x00F6)) || ((LA31_1 >= 0x00F8) && (LA31_1 <= 0x037D)) || ((LA31_1 >= 0x037F) && (LA31_1 <= 0x1FFF)) || ((LA31_1 >= 0x200C) && (LA31_1 <= 0x200D)) || ((LA31_1 >= 0x203F) && (LA31_1 <= 0x2040)) || ((LA31_1 >= 0x2070) && (LA31_1 <= 0x218F)) || ((LA31_1 >= 0x2C00) && (LA31_1 <= 0x2FEF)) || ((LA31_1 >= 0x3001) && (LA31_1 <= 0xD7FF)) || ((LA31_1 >= 0xF900) && (LA31_1 <= 0xFDCF)) || ((LA31_1 >= 0xFDF0) && (LA31_1 <= 0xFFFD))))
        	                        {
        	                            alt31=1;
        	                        }

        	                    }
        	                }
        	                else if ( (LA31_0 == '.'))
        	                {
        	                    alt31=2;
        	                }

        	            }
        	            switch (alt31)
        	            {
        	        	case 1:
        	        	    // Sparql.g:983:34: PN_CHARS
        	        	    {
        	        	        /* 983:34: PN_CHARS */
        	        	        mPN_CHARS(ctx );
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulePN_LOCALEx;
        	        	        }
        	        	        if (HASFAILED())
        	        	        {
        	        	            return ;
        	        	        }



        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // Sparql.g:983:43: DOT
        	        	    {
        	        	        if ( BACKTRACKING==0 )
        	        	        {
        	        	                
        	        	                                	                       if (LA(1)=='.') {
        	        	                                	                          int LA2 = LA(2);
        	        	                                	       	                  if (!((LA2>='-' && LA2<='.')||(LA2>='0' && LA2<='9')||(LA2>='A' && LA2<='Z')||LA2=='_'||(LA2>='a' && LA2<='z')||LA2=='\u00B7'||(LA2>='\u00C0' && LA2<='\u00D6')||(LA2>='\u00D8' && LA2<='\u00F6')||(LA2>='\u00F8' && LA2<='\u037D')||(LA2>='\u037F' && LA2<='\u1FFF')||(LA2>='\u200C' && LA2<='\u200D')||(LA2>='\u203F' && LA2<='\u2040')||(LA2>='\u2070' && LA2<='\u218F')||(LA2>='\u2C00' && LA2<='\u2FEF')||(LA2>='\u3001' && LA2<='\uD7FF')||(LA2>='\uF900' && LA2<='\uFDCF')||(LA2>='\uFDF0' && LA2<='\uFFFD'))) {
        	        	                                	       	                     return;
        	        	                                	       	                  }
        	        	                                	                       }
        	        	                                                       
        	        	        }


        	        	        /* 983:43: DOT */
        	        	        mDOT(ctx );
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulePN_LOCALEx;
        	        	        }
        	        	        if (HASFAILED())
        	        	        {
        	        	            return ;
        	        	        }



        	        	    }
        	        	    break;

        	        	default:
        	        	    goto loop31;	/* break out of the loop */
        	        	    break;
        	            }
        	        }
        	        loop31: ; /* Jump out to here if this rule does not match */


        	        /* 983:33: ( PN_CHARS | DOT )* PN_CHARS */
        	        mPN_CHARS(ctx );
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulePN_LOCALEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }



        	    }
        	    break;

            }
        }

    }


    // This is where rules clean up and exit
    //
    goto rulePN_LOCALEx; /* Prevent compiler warnings */
    rulePN_LOCALEx: ;

}
// $ANTLR end PN_LOCAL

//   Comes from: 994:5: ( 'A' .. 'Z' | 'a' .. 'z' | '\\u00C0' .. '\\u00D6' | '\\u00D8' .. '\\u00F6' | '\\u00F8' .. '\\u02FF' | '\\u0370' .. '\\u037D' | '\\u037F' .. '\\u1FFF' | '\\u200C' .. '\\u200D' | '\\u2070' .. '\\u218F' | '\\u2C00' .. '\\u2FEF' | '\\u3001' .. '\\uD7FF' | '\\uF900' .. '\\uFDCF' | '\\uFDF0' .. '\\uFFFD' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start PN_CHARS_BASE
 *
 * Looks to match the characters the constitute the token PN_CHARS_BASE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mPN_CHARS_BASE(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;


    // Sparql.g:994:5: ( 'A' .. 'Z' | 'a' .. 'z' | '\\u00C0' .. '\\u00D6' | '\\u00D8' .. '\\u00F6' | '\\u00F8' .. '\\u02FF' | '\\u0370' .. '\\u037D' | '\\u037F' .. '\\u1FFF' | '\\u200C' .. '\\u200D' | '\\u2070' .. '\\u218F' | '\\u2C00' .. '\\u2FEF' | '\\u3001' .. '\\uD7FF' | '\\uF900' .. '\\uFDCF' | '\\uFDF0' .. '\\uFFFD' )
    // Sparql.g:
    {
        if ( ((LA(1) >= 'A') && (LA(1) <= 'Z')) || ((LA(1) >= 'a') && (LA(1) <= 'z')) || ((LA(1) >= 0x00C0) && (LA(1) <= 0x00D6)) || ((LA(1) >= 0x00D8) && (LA(1) <= 0x00F6)) || ((LA(1) >= 0x00F8) && (LA(1) <= 0x02FF)) || ((LA(1) >= 0x0370) && (LA(1) <= 0x037D)) || ((LA(1) >= 0x037F) && (LA(1) <= 0x1FFF)) || ((LA(1) >= 0x200C) && (LA(1) <= 0x200D)) || ((LA(1) >= 0x2070) && (LA(1) <= 0x218F)) || ((LA(1) >= 0x2C00) && (LA(1) <= 0x2FEF)) || ((LA(1) >= 0x3001) && (LA(1) <= 0xD7FF)) || ((LA(1) >= 0xF900) && (LA(1) <= 0xFDCF)) || ((LA(1) >= 0xFDF0) && (LA(1) <= 0xFFFD)) )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto rulePN_CHARS_BASEEx;
        }


    }


    // This is where rules clean up and exit
    //
    goto rulePN_CHARS_BASEEx; /* Prevent compiler warnings */
    rulePN_CHARS_BASEEx: ;

}
// $ANTLR end PN_CHARS_BASE

//   Comes from: 1010:7: ( '0' .. '9' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start DIGIT
 *
 * Looks to match the characters the constitute the token DIGIT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mDIGIT(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;


    // Sparql.g:1010:7: ( '0' .. '9' )
    // Sparql.g:
    {
        if ( ((LA(1) >= '0') && (LA(1) <= '9')) )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleDIGITEx;
        }


    }


    // This is where rules clean up and exit
    //
    goto ruleDIGITEx; /* Prevent compiler warnings */
    ruleDIGITEx: ;

}
// $ANTLR end DIGIT

//   Comes from: 1011:9: ( '#' ( options {greedy=false; } : . )* EOL )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start COMMENT
 *
 * Looks to match the characters the constitute the token COMMENT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mCOMMENT(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = COMMENT;


    // Sparql.g:1011:9: ( '#' ( options {greedy=false; } : . )* EOL )
    // Sparql.g:1011:11: '#' ( options {greedy=false; } : . )* EOL
    {
        MATCHC('#');
        if  (HASEXCEPTION())
        {
            goto ruleCOMMENTEx;
        }
        if (HASFAILED())
        {
            return ;
        }


        // Sparql.g:1011:15: ( options {greedy=false; } : . )*

        for (;;)
        {
            int alt33=2;
            {
               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                */
                int LA33_0 = LA(1);
                if ( (LA33_0 == '\n' || LA33_0 == '\r'))
                {
                    alt33=2;
                }
                else if ( (((LA33_0 >= 0x0000) && (LA33_0 <= '\t')) || ((LA33_0 >= 0x000B) && (LA33_0 <= '\f')) || ((LA33_0 >= 0x000E) && (LA33_0 <= 0xFFFF))))
                {
                    alt33=1;
                }

            }
            switch (alt33)
            {
        	case 1:
        	    // Sparql.g:1011:41: .
        	    {
        	        MATCHANY();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleCOMMENTEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

        	default:
        	    goto loop33;	/* break out of the loop */
        	    break;
            }
        }
        loop33: ; /* Jump out to here if this rule does not match */


        /* 1011:11: '#' ( options {greedy=false; } : . )* EOL */
        mEOL(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleCOMMENTEx;
        }
        if (HASFAILED())
        {
            return ;
        }



        if ( BACKTRACKING==0 )
        {
             LEXSTATE->channel=HIDDEN; 
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleCOMMENTEx; /* Prevent compiler warnings */
    ruleCOMMENTEx: ;

}
// $ANTLR end COMMENT

//   Comes from: 1015:5: ( '\\n' | '\\r' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start EOL
 *
 * Looks to match the characters the constitute the token EOL
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mEOL(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;


    // Sparql.g:1015:5: ( '\\n' | '\\r' )
    // Sparql.g:
    {
        if ( LA(1) == '\n' || LA(1) == '\r' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleEOLEx;
        }


    }


    // This is where rules clean up and exit
    //
    goto ruleEOLEx; /* Prevent compiler warnings */
    ruleEOLEx: ;

}
// $ANTLR end EOL

//   Comes from: 1016:11: ( '^^' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start REFERENCE
 *
 * Looks to match the characters the constitute the token REFERENCE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mREFERENCE(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = REFERENCE;


    // Sparql.g:1016:11: ( '^^' )
    // Sparql.g:1016:13: '^^'
    {
        MATCHS(lit_10);
        if  (HASEXCEPTION())
        {
            goto ruleREFERENCEEx;
        }
        if (HASFAILED())
        {
            return ;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleREFERENCEEx; /* Prevent compiler warnings */
    ruleREFERENCEEx: ;

}
// $ANTLR end REFERENCE

//   Comes from: 1018:12: ( '<=' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start LESS_EQUAL
 *
 * Looks to match the characters the constitute the token LESS_EQUAL
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mLESS_EQUAL(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = LESS_EQUAL;


    // Sparql.g:1018:12: ( '<=' )
    // Sparql.g:1018:14: '<='
    {
        MATCHS(lit_11);
        if  (HASEXCEPTION())
        {
            goto ruleLESS_EQUALEx;
        }
        if (HASFAILED())
        {
            return ;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleLESS_EQUALEx; /* Prevent compiler warnings */
    ruleLESS_EQUALEx: ;

}
// $ANTLR end LESS_EQUAL

//   Comes from: 1020:15: ( '>=' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start GREATER_EQUAL
 *
 * Looks to match the characters the constitute the token GREATER_EQUAL
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mGREATER_EQUAL(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = GREATER_EQUAL;


    // Sparql.g:1020:15: ( '>=' )
    // Sparql.g:1020:17: '>='
    {
        MATCHS(lit_12);
        if  (HASEXCEPTION())
        {
            goto ruleGREATER_EQUALEx;
        }
        if (HASFAILED())
        {
            return ;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleGREATER_EQUALEx; /* Prevent compiler warnings */
    ruleGREATER_EQUALEx: ;

}
// $ANTLR end GREATER_EQUAL

//   Comes from: 1022:11: ( '!=' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start NOT_EQUAL
 *
 * Looks to match the characters the constitute the token NOT_EQUAL
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mNOT_EQUAL(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = NOT_EQUAL;


    // Sparql.g:1022:11: ( '!=' )
    // Sparql.g:1022:13: '!='
    {
        MATCHS(lit_13);
        if  (HASEXCEPTION())
        {
            goto ruleNOT_EQUALEx;
        }
        if (HASFAILED())
        {
            return ;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleNOT_EQUALEx; /* Prevent compiler warnings */
    ruleNOT_EQUALEx: ;

}
// $ANTLR end NOT_EQUAL

//   Comes from: 1024:5: ( '&&' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start AND
 *
 * Looks to match the characters the constitute the token AND
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mAND(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = AND;


    // Sparql.g:1024:5: ( '&&' )
    // Sparql.g:1024:7: '&&'
    {
        MATCHS(lit_14);
        if  (HASEXCEPTION())
        {
            goto ruleANDEx;
        }
        if (HASFAILED())
        {
            return ;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleANDEx; /* Prevent compiler warnings */
    ruleANDEx: ;

}
// $ANTLR end AND

//   Comes from: 1026:4: ( '||' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start OR
 *
 * Looks to match the characters the constitute the token OR
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mOR(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = OR;


    // Sparql.g:1026:4: ( '||' )
    // Sparql.g:1026:6: '||'
    {
        MATCHS(lit_15);
        if  (HASEXCEPTION())
        {
            goto ruleOREx;
        }
        if (HASFAILED())
        {
            return ;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleOREx; /* Prevent compiler warnings */
    ruleOREx: ;

}
// $ANTLR end OR

//   Comes from: 1028:9: ( '^' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start INVERSE
 *
 * Looks to match the characters the constitute the token INVERSE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mINVERSE(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = INVERSE;


    // Sparql.g:1028:9: ( '^' )
    // Sparql.g:1028:11: '^'
    {
        MATCHC('^');
        if  (HASEXCEPTION())
        {
            goto ruleINVERSEEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleINVERSEEx; /* Prevent compiler warnings */
    ruleINVERSEEx: ;

}
// $ANTLR end INVERSE

//   Comes from: 1030:12: ( '(' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start OPEN_BRACE
 *
 * Looks to match the characters the constitute the token OPEN_BRACE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mOPEN_BRACE(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = OPEN_BRACE;


    // Sparql.g:1030:12: ( '(' )
    // Sparql.g:1030:14: '('
    {
        MATCHC('(');
        if  (HASEXCEPTION())
        {
            goto ruleOPEN_BRACEEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleOPEN_BRACEEx; /* Prevent compiler warnings */
    ruleOPEN_BRACEEx: ;

}
// $ANTLR end OPEN_BRACE

//   Comes from: 1032:13: ( ')' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start CLOSE_BRACE
 *
 * Looks to match the characters the constitute the token CLOSE_BRACE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mCLOSE_BRACE(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = CLOSE_BRACE;


    // Sparql.g:1032:13: ( ')' )
    // Sparql.g:1032:15: ')'
    {
        MATCHC(')');
        if  (HASEXCEPTION())
        {
            goto ruleCLOSE_BRACEEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleCLOSE_BRACEEx; /* Prevent compiler warnings */
    ruleCLOSE_BRACEEx: ;

}
// $ANTLR end CLOSE_BRACE

//   Comes from: 1034:18: ( '{' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start OPEN_CURLY_BRACE
 *
 * Looks to match the characters the constitute the token OPEN_CURLY_BRACE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mOPEN_CURLY_BRACE(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = OPEN_CURLY_BRACE;


    // Sparql.g:1034:18: ( '{' )
    // Sparql.g:1034:20: '{'
    {
        MATCHC('{');
        if  (HASEXCEPTION())
        {
            goto ruleOPEN_CURLY_BRACEEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleOPEN_CURLY_BRACEEx; /* Prevent compiler warnings */
    ruleOPEN_CURLY_BRACEEx: ;

}
// $ANTLR end OPEN_CURLY_BRACE

//   Comes from: 1036:19: ( '}' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start CLOSE_CURLY_BRACE
 *
 * Looks to match the characters the constitute the token CLOSE_CURLY_BRACE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mCLOSE_CURLY_BRACE(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = CLOSE_CURLY_BRACE;


    // Sparql.g:1036:19: ( '}' )
    // Sparql.g:1036:21: '}'
    {
        MATCHC('}');
        if  (HASEXCEPTION())
        {
            goto ruleCLOSE_CURLY_BRACEEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleCLOSE_CURLY_BRACEEx; /* Prevent compiler warnings */
    ruleCLOSE_CURLY_BRACEEx: ;

}
// $ANTLR end CLOSE_CURLY_BRACE

//   Comes from: 1038:21: ( '[' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start OPEN_SQUARE_BRACKET
 *
 * Looks to match the characters the constitute the token OPEN_SQUARE_BRACKET
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mOPEN_SQUARE_BRACKET(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = OPEN_SQUARE_BRACKET;


    // Sparql.g:1038:21: ( '[' )
    // Sparql.g:1038:23: '['
    {
        MATCHC('[');
        if  (HASEXCEPTION())
        {
            goto ruleOPEN_SQUARE_BRACKETEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleOPEN_SQUARE_BRACKETEx; /* Prevent compiler warnings */
    ruleOPEN_SQUARE_BRACKETEx: ;

}
// $ANTLR end OPEN_SQUARE_BRACKET

//   Comes from: 1040:22: ( ']' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start CLOSE_SQUARE_BRACKET
 *
 * Looks to match the characters the constitute the token CLOSE_SQUARE_BRACKET
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mCLOSE_SQUARE_BRACKET(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = CLOSE_SQUARE_BRACKET;


    // Sparql.g:1040:22: ( ']' )
    // Sparql.g:1040:24: ']'
    {
        MATCHC(']');
        if  (HASEXCEPTION())
        {
            goto ruleCLOSE_SQUARE_BRACKETEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleCLOSE_SQUARE_BRACKETEx; /* Prevent compiler warnings */
    ruleCLOSE_SQUARE_BRACKETEx: ;

}
// $ANTLR end CLOSE_SQUARE_BRACKET

//   Comes from: 1042:11: ( ';' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SEMICOLON
 *
 * Looks to match the characters the constitute the token SEMICOLON
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mSEMICOLON(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = SEMICOLON;


    // Sparql.g:1042:11: ( ';' )
    // Sparql.g:1042:13: ';'
    {
        MATCHC(';');
        if  (HASEXCEPTION())
        {
            goto ruleSEMICOLONEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleSEMICOLONEx; /* Prevent compiler warnings */
    ruleSEMICOLONEx: ;

}
// $ANTLR end SEMICOLON

//   Comes from: 1044:5: ( '.' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start DOT
 *
 * Looks to match the characters the constitute the token DOT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mDOT(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = DOT;


    // Sparql.g:1044:5: ( '.' )
    // Sparql.g:1044:7: '.'
    {
        MATCHC('.');
        if  (HASEXCEPTION())
        {
            goto ruleDOTEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleDOTEx; /* Prevent compiler warnings */
    ruleDOTEx: ;

}
// $ANTLR end DOT

//   Comes from: 1046:6: ( '+' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start PLUS
 *
 * Looks to match the characters the constitute the token PLUS
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mPLUS(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = PLUS;


    // Sparql.g:1046:6: ( '+' )
    // Sparql.g:1046:8: '+'
    {
        MATCHC('+');
        if  (HASEXCEPTION())
        {
            goto rulePLUSEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto rulePLUSEx; /* Prevent compiler warnings */
    rulePLUSEx: ;

}
// $ANTLR end PLUS

//   Comes from: 1048:7: ( '-' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start MINUS
 *
 * Looks to match the characters the constitute the token MINUS
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mMINUS(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = MINUS;


    // Sparql.g:1048:7: ( '-' )
    // Sparql.g:1048:9: '-'
    {
        MATCHC('-');
        if  (HASEXCEPTION())
        {
            goto ruleMINUSEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleMINUSEx; /* Prevent compiler warnings */
    ruleMINUSEx: ;

}
// $ANTLR end MINUS

//   Comes from: 1052:6: ( ( PLUS | MINUS ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SIGN
 *
 * Looks to match the characters the constitute the token SIGN
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mSIGN(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;


    // Sparql.g:1052:6: ( ( PLUS | MINUS ) )
    // Sparql.g:
    {
        if ( LA(1) == '+' || LA(1) == '-' )
        {
            CONSUME();
            FAILEDFLAG=ANTLR3_FALSE;

        }
        else
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }

            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleSIGNEx;
        }


    }


    // This is where rules clean up and exit
    //
    goto ruleSIGNEx; /* Prevent compiler warnings */
    ruleSIGNEx: ;

}
// $ANTLR end SIGN

//   Comes from: 1053:10: ( '*' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start ASTERISK
 *
 * Looks to match the characters the constitute the token ASTERISK
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mASTERISK(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = ASTERISK;


    // Sparql.g:1053:10: ( '*' )
    // Sparql.g:1053:12: '*'
    {
        MATCHC('*');
        if  (HASEXCEPTION())
        {
            goto ruleASTERISKEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleASTERISKEx; /* Prevent compiler warnings */
    ruleASTERISKEx: ;

}
// $ANTLR end ASTERISK

//   Comes from: 1055:15: ( '?' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start QUESTION_MARK
 *
 * Looks to match the characters the constitute the token QUESTION_MARK
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mQUESTION_MARK(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = QUESTION_MARK;


    // Sparql.g:1055:15: ( '?' )
    // Sparql.g:1055:17: '?'
    {
        MATCHC('?');
        if  (HASEXCEPTION())
        {
            goto ruleQUESTION_MARKEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleQUESTION_MARKEx; /* Prevent compiler warnings */
    ruleQUESTION_MARKEx: ;

}
// $ANTLR end QUESTION_MARK

//   Comes from: 1057:7: ( ',' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start COMMA
 *
 * Looks to match the characters the constitute the token COMMA
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mCOMMA(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = COMMA;


    // Sparql.g:1057:7: ( ',' )
    // Sparql.g:1057:9: ','
    {
        MATCHC(',');
        if  (HASEXCEPTION())
        {
            goto ruleCOMMAEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleCOMMAEx; /* Prevent compiler warnings */
    ruleCOMMAEx: ;

}
// $ANTLR end COMMA

//   Comes from: 1059:10: ( '!' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start NEGATION
 *
 * Looks to match the characters the constitute the token NEGATION
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mNEGATION(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = NEGATION;


    // Sparql.g:1059:10: ( '!' )
    // Sparql.g:1059:12: '!'
    {
        MATCHC('!');
        if  (HASEXCEPTION())
        {
            goto ruleNEGATIONEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleNEGATIONEx; /* Prevent compiler warnings */
    ruleNEGATIONEx: ;

}
// $ANTLR end NEGATION

//   Comes from: 1061:8: ( '/' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start DIVIDE
 *
 * Looks to match the characters the constitute the token DIVIDE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mDIVIDE(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = DIVIDE;


    // Sparql.g:1061:8: ( '/' )
    // Sparql.g:1061:10: '/'
    {
        MATCHC('/');
        if  (HASEXCEPTION())
        {
            goto ruleDIVIDEEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleDIVIDEEx; /* Prevent compiler warnings */
    ruleDIVIDEEx: ;

}
// $ANTLR end DIVIDE

//   Comes from: 1063:7: ( '=' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start EQUAL
 *
 * Looks to match the characters the constitute the token EQUAL
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mEQUAL(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = EQUAL;


    // Sparql.g:1063:7: ( '=' )
    // Sparql.g:1063:9: '='
    {
        MATCHC('=');
        if  (HASEXCEPTION())
        {
            goto ruleEQUALEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleEQUALEx; /* Prevent compiler warnings */
    ruleEQUALEx: ;

}
// $ANTLR end EQUAL

//   Comes from: 1067:6: ( '<' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start LESS
 *
 * Looks to match the characters the constitute the token LESS
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mLESS(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;


    // Sparql.g:1067:6: ( '<' )
    // Sparql.g:1067:8: '<'
    {
        MATCHC('<');
        if  (HASEXCEPTION())
        {
            goto ruleLESSEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }


    // This is where rules clean up and exit
    //
    goto ruleLESSEx; /* Prevent compiler warnings */
    ruleLESSEx: ;

}
// $ANTLR end LESS

//   Comes from: 1068:9: ( '>' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start GREATER
 *
 * Looks to match the characters the constitute the token GREATER
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mGREATER(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = GREATER;


    // Sparql.g:1068:9: ( '>' )
    // Sparql.g:1068:11: '>'
    {
        MATCHC('>');
        if  (HASEXCEPTION())
        {
            goto ruleGREATEREx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleGREATEREx; /* Prevent compiler warnings */
    ruleGREATEREx: ;

}
// $ANTLR end GREATER

//   Comes from: 1070:6: ( '|' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start PIPE
 *
 * Looks to match the characters the constitute the token PIPE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mPIPE(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = PIPE;


    // Sparql.g:1070:6: ( '|' )
    // Sparql.g:1070:8: '|'
    {
        MATCHC('|');
        if  (HASEXCEPTION())
        {
            goto rulePIPEEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto rulePIPEEx; /* Prevent compiler warnings */
    rulePIPEEx: ;

}
// $ANTLR end PIPE

//   Comes from: 1072:5: ( . )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start ANY
 *
 * Looks to match the characters the constitute the token ANY
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mANY(pSparqlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = ANY;


    // Sparql.g:1072:5: ( . )
    // Sparql.g:1072:7: .
    {
        MATCHANY();
        if  (HASEXCEPTION())
        {
            goto ruleANYEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleANYEx; /* Prevent compiler warnings */
    ruleANYEx: ;

}
// $ANTLR end ANY

/** This is the entry point in to the lexer from an object that
 *  wants to generate the next token, such as a pCOMMON_TOKEN_STREAM
 */
static void
mTokens(pSparqlLexer ctx)
{
    {
        //  Sparql.g:1:8: ( WS | BASE | PREFIX | SELECT | DISTINCT | REDUCED | CONSTRUCT | DESCRIBE | ASK | FROM | NAMED | WHERE | ORDER | BY | ASC | DESC | LIMIT | OFFSET | OPTIONAL | GRAPH | UNION | FILTER | A | STR | LANG | LANGMATCHES | DATATYPE | BOUND | SAMETERM | ISIRI | ISURI | ISBLANK | ISLITERAL | REGEX | SUBSTR | TRUE | FALSE | LOAD | CLEAR | DROP | ADD | MOVE | COPY | CREATE | DELETE | INSERT | USING | SILENT | DEFAULT | ALL | DATA | WITH | INTO | TO | AS | GROUP | HAVING | UNDEF | BINDINGS | SERVICE | BIND | MINUS_KEYWORD | IRI | URI | BNODE | RAND | ABS | CEIL | FLOOR | ROUND | CONCAT | STRLEN | UCASE | LCASE | ENCODE_FOR_URI | CONTAINS | STRSTARTS | STRENDS | YEAR | MONTH | DAY | HOURS | MINUTES | SECONDS | TIMEZONE | TZ | NOW | MD5 | SHA1 | SHA224 | SHA256 | SHA384 | SHA512 | COALESCE | IF | STRLANG | STRDT | ISNUMERIC | COUNT | SUM | MIN | MAX | AVG | SAMPLE | GROUP_CONCAT | NOT | IN | EXISTS | SEPARATOR | PNAME_NS | PNAME_LN | BLANK_NODE_LABEL | VAR1 | VAR2 | LANGTAG | INTEGER | DECIMAL | DOUBLE | INTEGER_POSITIVE | DECIMAL_POSITIVE | DOUBLE_POSITIVE | INTEGER_NEGATIVE | DECIMAL_NEGATIVE | DOUBLE_NEGATIVE | STRING_LITERAL1 | STRING_LITERAL2 | STRING_LITERAL_LONG1 | STRING_LITERAL_LONG2 | IRI_REF | COMMENT | REFERENCE | LESS_EQUAL | GREATER_EQUAL | NOT_EQUAL | AND | OR | INVERSE | OPEN_BRACE | CLOSE_BRACE | OPEN_CURLY_BRACE | CLOSE_CURLY_BRACE | OPEN_SQUARE_BRACKET | CLOSE_SQUARE_BRACKET | SEMICOLON | DOT | PLUS | MINUS | ASTERISK | QUESTION_MARK | COMMA | NEGATION | DIVIDE | EQUAL | GREATER | PIPE | ANY )

        ANTLR3_UINT32 alt34;

        alt34=156;

        alt34 = cdfa34.predict(ctx, RECOGNIZER, ISTREAM, &cdfa34);
        if  (HASEXCEPTION())
        {
            goto ruleTokensEx;
        }
        if (HASFAILED())
        {
            return ;
        }

        switch (alt34)
        {
    	case 1:
    	    // Sparql.g:1:10: WS
    	    {
    	        /* 1:10: WS */
    	        mWS(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 2:
    	    // Sparql.g:1:13: BASE
    	    {
    	        /* 1:13: BASE */
    	        mBASE(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 3:
    	    // Sparql.g:1:18: PREFIX
    	    {
    	        /* 1:18: PREFIX */
    	        mPREFIX(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 4:
    	    // Sparql.g:1:25: SELECT
    	    {
    	        /* 1:25: SELECT */
    	        mSELECT(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 5:
    	    // Sparql.g:1:32: DISTINCT
    	    {
    	        /* 1:32: DISTINCT */
    	        mDISTINCT(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 6:
    	    // Sparql.g:1:41: REDUCED
    	    {
    	        /* 1:41: REDUCED */
    	        mREDUCED(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 7:
    	    // Sparql.g:1:49: CONSTRUCT
    	    {
    	        /* 1:49: CONSTRUCT */
    	        mCONSTRUCT(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 8:
    	    // Sparql.g:1:59: DESCRIBE
    	    {
    	        /* 1:59: DESCRIBE */
    	        mDESCRIBE(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 9:
    	    // Sparql.g:1:68: ASK
    	    {
    	        /* 1:68: ASK */
    	        mASK(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 10:
    	    // Sparql.g:1:72: FROM
    	    {
    	        /* 1:72: FROM */
    	        mFROM(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 11:
    	    // Sparql.g:1:77: NAMED
    	    {
    	        /* 1:77: NAMED */
    	        mNAMED(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 12:
    	    // Sparql.g:1:83: WHERE
    	    {
    	        /* 1:83: WHERE */
    	        mWHERE(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 13:
    	    // Sparql.g:1:89: ORDER
    	    {
    	        /* 1:89: ORDER */
    	        mORDER(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 14:
    	    // Sparql.g:1:95: BY
    	    {
    	        /* 1:95: BY */
    	        mBY(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 15:
    	    // Sparql.g:1:98: ASC
    	    {
    	        /* 1:98: ASC */
    	        mASC(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 16:
    	    // Sparql.g:1:102: DESC
    	    {
    	        /* 1:102: DESC */
    	        mDESC(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 17:
    	    // Sparql.g:1:107: LIMIT
    	    {
    	        /* 1:107: LIMIT */
    	        mLIMIT(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 18:
    	    // Sparql.g:1:113: OFFSET
    	    {
    	        /* 1:113: OFFSET */
    	        mOFFSET(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 19:
    	    // Sparql.g:1:120: OPTIONAL
    	    {
    	        /* 1:120: OPTIONAL */
    	        mOPTIONAL(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 20:
    	    // Sparql.g:1:129: GRAPH
    	    {
    	        /* 1:129: GRAPH */
    	        mGRAPH(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 21:
    	    // Sparql.g:1:135: UNION
    	    {
    	        /* 1:135: UNION */
    	        mUNION(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 22:
    	    // Sparql.g:1:141: FILTER
    	    {
    	        /* 1:141: FILTER */
    	        mFILTER(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 23:
    	    // Sparql.g:1:148: A
    	    {
    	        /* 1:148: A */
    	        mA(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 24:
    	    // Sparql.g:1:150: STR
    	    {
    	        /* 1:150: STR */
    	        mSTR(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 25:
    	    // Sparql.g:1:154: LANG
    	    {
    	        /* 1:154: LANG */
    	        mLANG(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 26:
    	    // Sparql.g:1:159: LANGMATCHES
    	    {
    	        /* 1:159: LANGMATCHES */
    	        mLANGMATCHES(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 27:
    	    // Sparql.g:1:171: DATATYPE
    	    {
    	        /* 1:171: DATATYPE */
    	        mDATATYPE(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 28:
    	    // Sparql.g:1:180: BOUND
    	    {
    	        /* 1:180: BOUND */
    	        mBOUND(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 29:
    	    // Sparql.g:1:186: SAMETERM
    	    {
    	        /* 1:186: SAMETERM */
    	        mSAMETERM(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 30:
    	    // Sparql.g:1:195: ISIRI
    	    {
    	        /* 1:195: ISIRI */
    	        mISIRI(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 31:
    	    // Sparql.g:1:201: ISURI
    	    {
    	        /* 1:201: ISURI */
    	        mISURI(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 32:
    	    // Sparql.g:1:207: ISBLANK
    	    {
    	        /* 1:207: ISBLANK */
    	        mISBLANK(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 33:
    	    // Sparql.g:1:215: ISLITERAL
    	    {
    	        /* 1:215: ISLITERAL */
    	        mISLITERAL(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 34:
    	    // Sparql.g:1:225: REGEX
    	    {
    	        /* 1:225: REGEX */
    	        mREGEX(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 35:
    	    // Sparql.g:1:231: SUBSTR
    	    {
    	        /* 1:231: SUBSTR */
    	        mSUBSTR(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 36:
    	    // Sparql.g:1:238: TRUE
    	    {
    	        /* 1:238: TRUE */
    	        mTRUE(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 37:
    	    // Sparql.g:1:243: FALSE
    	    {
    	        /* 1:243: FALSE */
    	        mFALSE(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 38:
    	    // Sparql.g:1:249: LOAD
    	    {
    	        /* 1:249: LOAD */
    	        mLOAD(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 39:
    	    // Sparql.g:1:254: CLEAR
    	    {
    	        /* 1:254: CLEAR */
    	        mCLEAR(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 40:
    	    // Sparql.g:1:260: DROP
    	    {
    	        /* 1:260: DROP */
    	        mDROP(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 41:
    	    // Sparql.g:1:265: ADD
    	    {
    	        /* 1:265: ADD */
    	        mADD(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 42:
    	    // Sparql.g:1:269: MOVE
    	    {
    	        /* 1:269: MOVE */
    	        mMOVE(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 43:
    	    // Sparql.g:1:274: COPY
    	    {
    	        /* 1:274: COPY */
    	        mCOPY(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 44:
    	    // Sparql.g:1:279: CREATE
    	    {
    	        /* 1:279: CREATE */
    	        mCREATE(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 45:
    	    // Sparql.g:1:286: DELETE
    	    {
    	        /* 1:286: DELETE */
    	        mDELETE(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 46:
    	    // Sparql.g:1:293: INSERT
    	    {
    	        /* 1:293: INSERT */
    	        mINSERT(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 47:
    	    // Sparql.g:1:300: USING
    	    {
    	        /* 1:300: USING */
    	        mUSING(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 48:
    	    // Sparql.g:1:306: SILENT
    	    {
    	        /* 1:306: SILENT */
    	        mSILENT(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 49:
    	    // Sparql.g:1:313: DEFAULT
    	    {
    	        /* 1:313: DEFAULT */
    	        mDEFAULT(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 50:
    	    // Sparql.g:1:321: ALL
    	    {
    	        /* 1:321: ALL */
    	        mALL(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 51:
    	    // Sparql.g:1:325: DATA
    	    {
    	        /* 1:325: DATA */
    	        mDATA(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 52:
    	    // Sparql.g:1:330: WITH
    	    {
    	        /* 1:330: WITH */
    	        mWITH(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 53:
    	    // Sparql.g:1:335: INTO
    	    {
    	        /* 1:335: INTO */
    	        mINTO(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 54:
    	    // Sparql.g:1:340: TO
    	    {
    	        /* 1:340: TO */
    	        mTO(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 55:
    	    // Sparql.g:1:343: AS
    	    {
    	        /* 1:343: AS */
    	        mAS(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 56:
    	    // Sparql.g:1:346: GROUP
    	    {
    	        /* 1:346: GROUP */
    	        mGROUP(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 57:
    	    // Sparql.g:1:352: HAVING
    	    {
    	        /* 1:352: HAVING */
    	        mHAVING(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 58:
    	    // Sparql.g:1:359: UNDEF
    	    {
    	        /* 1:359: UNDEF */
    	        mUNDEF(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 59:
    	    // Sparql.g:1:365: BINDINGS
    	    {
    	        /* 1:365: BINDINGS */
    	        mBINDINGS(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 60:
    	    // Sparql.g:1:374: SERVICE
    	    {
    	        /* 1:374: SERVICE */
    	        mSERVICE(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 61:
    	    // Sparql.g:1:382: BIND
    	    {
    	        /* 1:382: BIND */
    	        mBIND(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 62:
    	    // Sparql.g:1:387: MINUS_KEYWORD
    	    {
    	        /* 1:387: MINUS_KEYWORD */
    	        mMINUS_KEYWORD(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 63:
    	    // Sparql.g:1:401: IRI
    	    {
    	        /* 1:401: IRI */
    	        mIRI(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 64:
    	    // Sparql.g:1:405: URI
    	    {
    	        /* 1:405: URI */
    	        mURI(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 65:
    	    // Sparql.g:1:409: BNODE
    	    {
    	        /* 1:409: BNODE */
    	        mBNODE(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 66:
    	    // Sparql.g:1:415: RAND
    	    {
    	        /* 1:415: RAND */
    	        mRAND(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 67:
    	    // Sparql.g:1:420: ABS
    	    {
    	        /* 1:420: ABS */
    	        mABS(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 68:
    	    // Sparql.g:1:424: CEIL
    	    {
    	        /* 1:424: CEIL */
    	        mCEIL(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 69:
    	    // Sparql.g:1:429: FLOOR
    	    {
    	        /* 1:429: FLOOR */
    	        mFLOOR(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 70:
    	    // Sparql.g:1:435: ROUND
    	    {
    	        /* 1:435: ROUND */
    	        mROUND(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 71:
    	    // Sparql.g:1:441: CONCAT
    	    {
    	        /* 1:441: CONCAT */
    	        mCONCAT(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 72:
    	    // Sparql.g:1:448: STRLEN
    	    {
    	        /* 1:448: STRLEN */
    	        mSTRLEN(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 73:
    	    // Sparql.g:1:455: UCASE
    	    {
    	        /* 1:455: UCASE */
    	        mUCASE(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 74:
    	    // Sparql.g:1:461: LCASE
    	    {
    	        /* 1:461: LCASE */
    	        mLCASE(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 75:
    	    // Sparql.g:1:467: ENCODE_FOR_URI
    	    {
    	        /* 1:467: ENCODE_FOR_URI */
    	        mENCODE_FOR_URI(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 76:
    	    // Sparql.g:1:482: CONTAINS
    	    {
    	        /* 1:482: CONTAINS */
    	        mCONTAINS(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 77:
    	    // Sparql.g:1:491: STRSTARTS
    	    {
    	        /* 1:491: STRSTARTS */
    	        mSTRSTARTS(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 78:
    	    // Sparql.g:1:501: STRENDS
    	    {
    	        /* 1:501: STRENDS */
    	        mSTRENDS(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 79:
    	    // Sparql.g:1:509: YEAR
    	    {
    	        /* 1:509: YEAR */
    	        mYEAR(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 80:
    	    // Sparql.g:1:514: MONTH
    	    {
    	        /* 1:514: MONTH */
    	        mMONTH(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 81:
    	    // Sparql.g:1:520: DAY
    	    {
    	        /* 1:520: DAY */
    	        mDAY(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 82:
    	    // Sparql.g:1:524: HOURS
    	    {
    	        /* 1:524: HOURS */
    	        mHOURS(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 83:
    	    // Sparql.g:1:530: MINUTES
    	    {
    	        /* 1:530: MINUTES */
    	        mMINUTES(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 84:
    	    // Sparql.g:1:538: SECONDS
    	    {
    	        /* 1:538: SECONDS */
    	        mSECONDS(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 85:
    	    // Sparql.g:1:546: TIMEZONE
    	    {
    	        /* 1:546: TIMEZONE */
    	        mTIMEZONE(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 86:
    	    // Sparql.g:1:555: TZ
    	    {
    	        /* 1:555: TZ */
    	        mTZ(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 87:
    	    // Sparql.g:1:558: NOW
    	    {
    	        /* 1:558: NOW */
    	        mNOW(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 88:
    	    // Sparql.g:1:562: MD5
    	    {
    	        /* 1:562: MD5 */
    	        mMD5(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 89:
    	    // Sparql.g:1:566: SHA1
    	    {
    	        /* 1:566: SHA1 */
    	        mSHA1(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 90:
    	    // Sparql.g:1:571: SHA224
    	    {
    	        /* 1:571: SHA224 */
    	        mSHA224(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 91:
    	    // Sparql.g:1:578: SHA256
    	    {
    	        /* 1:578: SHA256 */
    	        mSHA256(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 92:
    	    // Sparql.g:1:585: SHA384
    	    {
    	        /* 1:585: SHA384 */
    	        mSHA384(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 93:
    	    // Sparql.g:1:592: SHA512
    	    {
    	        /* 1:592: SHA512 */
    	        mSHA512(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 94:
    	    // Sparql.g:1:599: COALESCE
    	    {
    	        /* 1:599: COALESCE */
    	        mCOALESCE(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 95:
    	    // Sparql.g:1:608: IF
    	    {
    	        /* 1:608: IF */
    	        mIF(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 96:
    	    // Sparql.g:1:611: STRLANG
    	    {
    	        /* 1:611: STRLANG */
    	        mSTRLANG(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 97:
    	    // Sparql.g:1:619: STRDT
    	    {
    	        /* 1:619: STRDT */
    	        mSTRDT(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 98:
    	    // Sparql.g:1:625: ISNUMERIC
    	    {
    	        /* 1:625: ISNUMERIC */
    	        mISNUMERIC(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 99:
    	    // Sparql.g:1:635: COUNT
    	    {
    	        /* 1:635: COUNT */
    	        mCOUNT(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 100:
    	    // Sparql.g:1:641: SUM
    	    {
    	        /* 1:641: SUM */
    	        mSUM(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 101:
    	    // Sparql.g:1:645: MIN
    	    {
    	        /* 1:645: MIN */
    	        mMIN(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 102:
    	    // Sparql.g:1:649: MAX
    	    {
    	        /* 1:649: MAX */
    	        mMAX(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 103:
    	    // Sparql.g:1:653: AVG
    	    {
    	        /* 1:653: AVG */
    	        mAVG(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 104:
    	    // Sparql.g:1:657: SAMPLE
    	    {
    	        /* 1:657: SAMPLE */
    	        mSAMPLE(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 105:
    	    // Sparql.g:1:664: GROUP_CONCAT
    	    {
    	        /* 1:664: GROUP_CONCAT */
    	        mGROUP_CONCAT(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 106:
    	    // Sparql.g:1:677: NOT
    	    {
    	        /* 1:677: NOT */
    	        mNOT(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 107:
    	    // Sparql.g:1:681: IN
    	    {
    	        /* 1:681: IN */
    	        mIN(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 108:
    	    // Sparql.g:1:684: EXISTS
    	    {
    	        /* 1:684: EXISTS */
    	        mEXISTS(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 109:
    	    // Sparql.g:1:691: SEPARATOR
    	    {
    	        /* 1:691: SEPARATOR */
    	        mSEPARATOR(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 110:
    	    // Sparql.g:1:701: PNAME_NS
    	    {
    	        /* 1:701: PNAME_NS */
    	        mPNAME_NS(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 111:
    	    // Sparql.g:1:710: PNAME_LN
    	    {
    	        /* 1:710: PNAME_LN */
    	        mPNAME_LN(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 112:
    	    // Sparql.g:1:719: BLANK_NODE_LABEL
    	    {
    	        /* 1:719: BLANK_NODE_LABEL */
    	        mBLANK_NODE_LABEL(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 113:
    	    // Sparql.g:1:736: VAR1
    	    {
    	        /* 1:736: VAR1 */
    	        mVAR1(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 114:
    	    // Sparql.g:1:741: VAR2
    	    {
    	        /* 1:741: VAR2 */
    	        mVAR2(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 115:
    	    // Sparql.g:1:746: LANGTAG
    	    {
    	        /* 1:746: LANGTAG */
    	        mLANGTAG(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 116:
    	    // Sparql.g:1:754: INTEGER
    	    {
    	        /* 1:754: INTEGER */
    	        mINTEGER(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 117:
    	    // Sparql.g:1:762: DECIMAL
    	    {
    	        /* 1:762: DECIMAL */
    	        mDECIMAL(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 118:
    	    // Sparql.g:1:770: DOUBLE
    	    {
    	        /* 1:770: DOUBLE */
    	        mDOUBLE(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 119:
    	    // Sparql.g:1:777: INTEGER_POSITIVE
    	    {
    	        /* 1:777: INTEGER_POSITIVE */
    	        mINTEGER_POSITIVE(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 120:
    	    // Sparql.g:1:794: DECIMAL_POSITIVE
    	    {
    	        /* 1:794: DECIMAL_POSITIVE */
    	        mDECIMAL_POSITIVE(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 121:
    	    // Sparql.g:1:811: DOUBLE_POSITIVE
    	    {
    	        /* 1:811: DOUBLE_POSITIVE */
    	        mDOUBLE_POSITIVE(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 122:
    	    // Sparql.g:1:827: INTEGER_NEGATIVE
    	    {
    	        /* 1:827: INTEGER_NEGATIVE */
    	        mINTEGER_NEGATIVE(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 123:
    	    // Sparql.g:1:844: DECIMAL_NEGATIVE
    	    {
    	        /* 1:844: DECIMAL_NEGATIVE */
    	        mDECIMAL_NEGATIVE(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 124:
    	    // Sparql.g:1:861: DOUBLE_NEGATIVE
    	    {
    	        /* 1:861: DOUBLE_NEGATIVE */
    	        mDOUBLE_NEGATIVE(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 125:
    	    // Sparql.g:1:877: STRING_LITERAL1
    	    {
    	        /* 1:877: STRING_LITERAL1 */
    	        mSTRING_LITERAL1(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 126:
    	    // Sparql.g:1:893: STRING_LITERAL2
    	    {
    	        /* 1:893: STRING_LITERAL2 */
    	        mSTRING_LITERAL2(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 127:
    	    // Sparql.g:1:909: STRING_LITERAL_LONG1
    	    {
    	        /* 1:909: STRING_LITERAL_LONG1 */
    	        mSTRING_LITERAL_LONG1(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 128:
    	    // Sparql.g:1:930: STRING_LITERAL_LONG2
    	    {
    	        /* 1:930: STRING_LITERAL_LONG2 */
    	        mSTRING_LITERAL_LONG2(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 129:
    	    // Sparql.g:1:951: IRI_REF
    	    {
    	        /* 1:951: IRI_REF */
    	        mIRI_REF(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 130:
    	    // Sparql.g:1:959: COMMENT
    	    {
    	        /* 1:959: COMMENT */
    	        mCOMMENT(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 131:
    	    // Sparql.g:1:967: REFERENCE
    	    {
    	        /* 1:967: REFERENCE */
    	        mREFERENCE(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 132:
    	    // Sparql.g:1:977: LESS_EQUAL
    	    {
    	        /* 1:977: LESS_EQUAL */
    	        mLESS_EQUAL(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 133:
    	    // Sparql.g:1:988: GREATER_EQUAL
    	    {
    	        /* 1:988: GREATER_EQUAL */
    	        mGREATER_EQUAL(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 134:
    	    // Sparql.g:1:1002: NOT_EQUAL
    	    {
    	        /* 1:1002: NOT_EQUAL */
    	        mNOT_EQUAL(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 135:
    	    // Sparql.g:1:1012: AND
    	    {
    	        /* 1:1012: AND */
    	        mAND(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 136:
    	    // Sparql.g:1:1016: OR
    	    {
    	        /* 1:1016: OR */
    	        mOR(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 137:
    	    // Sparql.g:1:1019: INVERSE
    	    {
    	        /* 1:1019: INVERSE */
    	        mINVERSE(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 138:
    	    // Sparql.g:1:1027: OPEN_BRACE
    	    {
    	        /* 1:1027: OPEN_BRACE */
    	        mOPEN_BRACE(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 139:
    	    // Sparql.g:1:1038: CLOSE_BRACE
    	    {
    	        /* 1:1038: CLOSE_BRACE */
    	        mCLOSE_BRACE(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 140:
    	    // Sparql.g:1:1050: OPEN_CURLY_BRACE
    	    {
    	        /* 1:1050: OPEN_CURLY_BRACE */
    	        mOPEN_CURLY_BRACE(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 141:
    	    // Sparql.g:1:1067: CLOSE_CURLY_BRACE
    	    {
    	        /* 1:1067: CLOSE_CURLY_BRACE */
    	        mCLOSE_CURLY_BRACE(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 142:
    	    // Sparql.g:1:1085: OPEN_SQUARE_BRACKET
    	    {
    	        /* 1:1085: OPEN_SQUARE_BRACKET */
    	        mOPEN_SQUARE_BRACKET(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 143:
    	    // Sparql.g:1:1105: CLOSE_SQUARE_BRACKET
    	    {
    	        /* 1:1105: CLOSE_SQUARE_BRACKET */
    	        mCLOSE_SQUARE_BRACKET(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 144:
    	    // Sparql.g:1:1126: SEMICOLON
    	    {
    	        /* 1:1126: SEMICOLON */
    	        mSEMICOLON(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 145:
    	    // Sparql.g:1:1136: DOT
    	    {
    	        /* 1:1136: DOT */
    	        mDOT(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 146:
    	    // Sparql.g:1:1140: PLUS
    	    {
    	        /* 1:1140: PLUS */
    	        mPLUS(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 147:
    	    // Sparql.g:1:1145: MINUS
    	    {
    	        /* 1:1145: MINUS */
    	        mMINUS(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 148:
    	    // Sparql.g:1:1151: ASTERISK
    	    {
    	        /* 1:1151: ASTERISK */
    	        mASTERISK(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 149:
    	    // Sparql.g:1:1160: QUESTION_MARK
    	    {
    	        /* 1:1160: QUESTION_MARK */
    	        mQUESTION_MARK(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 150:
    	    // Sparql.g:1:1174: COMMA
    	    {
    	        /* 1:1174: COMMA */
    	        mCOMMA(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 151:
    	    // Sparql.g:1:1180: NEGATION
    	    {
    	        /* 1:1180: NEGATION */
    	        mNEGATION(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 152:
    	    // Sparql.g:1:1189: DIVIDE
    	    {
    	        /* 1:1189: DIVIDE */
    	        mDIVIDE(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 153:
    	    // Sparql.g:1:1196: EQUAL
    	    {
    	        /* 1:1196: EQUAL */
    	        mEQUAL(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 154:
    	    // Sparql.g:1:1202: GREATER
    	    {
    	        /* 1:1202: GREATER */
    	        mGREATER(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 155:
    	    // Sparql.g:1:1210: PIPE
    	    {
    	        /* 1:1210: PIPE */
    	        mPIPE(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;
    	case 156:
    	    // Sparql.g:1:1215: ANY
    	    {
    	        /* 1:1215: ANY */
    	        mANY(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }



    	    }
    	    break;

        }
    }


    goto ruleTokensEx; /* Prevent compiler warnings */
ruleTokensEx: ;
}

// $ANTLR start synpred1_Sparql
static void synpred1_Sparql_fragment(pSparqlLexer ctx )
{
    // Sparql.g:953:6: ( LESS ( options {greedy=false; } : IRI_REF_CHARACTERS )* GREATER )
    // Sparql.g:953:7: LESS ( options {greedy=false; } : IRI_REF_CHARACTERS )* GREATER
    {
        /* 953:7: LESS ( options {greedy=false; } : IRI_REF_CHARACTERS )* GREATER */
        mLESS(ctx );
        if  (HASEXCEPTION())
        {
            goto rulesynpred1_SparqlEx;
        }
        if (HASFAILED())
        {
            return ;
        }



        // Sparql.g:953:12: ( options {greedy=false; } : IRI_REF_CHARACTERS )*

        for (;;)
        {
            int alt35=2;
            {
               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                */
                int LA35_0 = LA(1);
                if ( (LA35_0 == '!' || ((LA35_0 >= '#') && (LA35_0 <= ';')) || LA35_0 == '=' || ((LA35_0 >= '?') && (LA35_0 <= '[')) || LA35_0 == ']' || LA35_0 == '_' || ((LA35_0 >= 'a') && (LA35_0 <= 'z')) || ((LA35_0 >= '~') && (LA35_0 <= 0xFFFF))))
                {
                    alt35=1;
                }
                else if ( (LA35_0 == '>'))
                {
                    alt35=2;
                }

            }
            switch (alt35)
            {
        	case 1:
        	    // Sparql.g:953:37: IRI_REF_CHARACTERS
        	    {
        	        /* 953:37: IRI_REF_CHARACTERS */
        	        mIRI_REF_CHARACTERS(ctx );
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesynpred1_SparqlEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }



        	    }
        	    break;

        	default:
        	    goto loop35;	/* break out of the loop */
        	    break;
            }
        }
        loop35: ; /* Jump out to here if this rule does not match */


        /* 953:7: LESS ( options {greedy=false; } : IRI_REF_CHARACTERS )* GREATER */
        mGREATER(ctx );
        if  (HASEXCEPTION())
        {
            goto rulesynpred1_SparqlEx;
        }
        if (HASFAILED())
        {
            return ;
        }



    }

// This is where rules clean up and exit
//
goto rulesynpred1_SparqlEx; /* Prevent compiler warnings */
rulesynpred1_SparqlEx: ;

}
// $ANTLR end synpred1_Sparql

/* =========================================================================
 * Lexer matching rules end.
 * =========================================================================
 */

/* =========================================================================
 * Lexer syntactic predicates
 */
static ANTLR3_BOOLEAN synpred1_Sparql(pSparqlLexer ctx)
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred1_Sparql_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}

/* =========================================================================
 * Lexer syntactic predicates end.
 * =========================================================================
 */

/* End of Lexer code
 * ================================================
 * ================================================
 */


/* End of code
 * =============================================================================
 */
